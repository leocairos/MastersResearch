differencing uml models a domain specific vs a domain agnostic method comparing software artifacts to identify their similarities and differences is a task ubiquitous in software engineering logical design comparison is particularly interesting since it can serve multiple purposes when comparing the as intended vs the as implemented designs one can evaluate implementation to design conformance when comparing newer code versions against earlier ones one may better understand the development process of the system recognize the refactorings it has gone through and the qualities motivating them and infer high order patterns in its history given its importance design differencing has been the subject of much research and a variety of algorithms have been developed to compare different types of software artifacts in support of a variety of different software engineering activities our team has developed two different algorithms for differencing logical design models of object oriented software both algorithms adopt a similar conceptual model of uml logical designs as containment trees however one of them is heuristic whereas the other relies on a generic tree differencing algorithm in this paper we describe the two approaches and we compare them on multiple versions of an open source software system springer verlag berlin heidelberg 2013 software differencing software evolution uml semi automatic refactoring to aspect oriented platform refactoring is necessary in large software projects and an aspect oriented approach can help to maintain concerns in the source code while tools for object oriented refactoring are the usual part of development environments support for aspect oriented refactoring is minimal we analyzed object oriented bad smells applicable for an aspect oriented approach and propose a method for the detection of crosscutting concerns and consecutive refactoring 2013 ieee a study of cyclic dependencies on defect profile of software components background empirical evidence shows that dependency cycles among software components are pervasive in real life software systems although such cycles are known to be detrimental to software quality attributes such as understandability testability reusability build ability and maintainability research goals can the use of extended object oriented metrics make us better understand the relationships among cyclic related components and their defect proneness approach first we extend such metrics to mine and classify software components into two groups the cyclic and the non cyclic ones next we have performed an empirical study of six software applications using standard statistical tests on four different hypotheses we have determined the significance of the defect profiles of both groups results our results show that most defects and defective components are concentrated in cyclic dependent components either directly or indirectly discussion and conclusion these results have important implications for software maintenance and system testing by identifying the most defect prone set in a software system it is possible to effectively allocate testing resources in a cost efficient manner based on these results we demonstrate how additional structural properties could be collected to understand component s defect proneness and aid decision process in refactoring defect prone cyclic related components 2013 elsevier inc all rights reserved defect prone components defects dependency cycle identification of refused bequest code smells accumulated technical debt can be alleviated by means of refactoring application aiming at architectural improvement a prerequisite for wide scale refactoring application is the automated identification of the corresponding refactoring opportunities or code smells one of the major architectural problems that has received limited attention is the so called refused bequest which refers to inappropriate use of inheritance in object oriented systems this code smell occurs when subclasses do not take advantage of the inherited behavior implying that replacement by delegation should be used instead in this paper we propose a technique for the identification of refused bequest code smells whose major novelty lies in the intentional introduction of errors in the inherited methods the essence of inheritance is evaluated by exercising the system s functionality through the corresponding unit tests in order to reveal whether inherited methods are actually employed by clients based on the results of this approach and other structural information an indication of the smell strength on a thermometer is obtained the proposed approach has been implemented as an eclipse plugin 2013 ieee code smell refactoring refused bequest software maintenance unifying clone analysis and refactoring activity advancement towards c applications refactoring involves improve the quality of software and reduce the software complexity without affecting its external behavior the research focuses code clones is a vital target of refactoring and code clones increase the internal complexity maintenance effort and reduce the quality of software a clone consists of two or more segments of code that duplicates with each other on the basis of distinct type of similar measurements the developed algorithm insist a new semantic based clone management and refactoring system to detect and manage as well as refactor both exact and near miss code clones the major goal has to remove the clones in source code fragments by unifying the process of clone detection and refactoring the implemented clone refactoring technique detects and fixes the clones in multiple classes using graph structure and methods the code analyzer analyzes the user typed code by separating the auto generated code based on a graph structure a new abstract semantic graph refactoring algorithm for detecting the clones in multiple classes of source code fragments have been experimented in this research 2013 ieee abstract syntax tree ast clone detection code clones parsing refactoring software maintenance source code fragments research on the model of legacy software reuse based on code clone detection the construction of large scale engineering project usually relies on the development of many new software systems whereas it would be very expensive and time consuming if these new software systems are completely developed anew in order to solve the problem a model of legacy software reuse is proposed in this paper the model is based on code clone detection firstly code clone in source code of legacy software is detected by means of code clone detection tool secondly abstract syntax trees of the functions which contain code clone are created thirdly the degree of variation between the functions which contain the code clone belongs to the same clone set is calculated according to their abstract syntax trees and then some functions whose similarities of abstract syntax trees are in the allowed range are combined finally the combined functions and other frequently invoked functions are refactored into new functions or encapsulated into new classes and all of these functions or classes can be reused as components in the development of new software systems the test result shows that the reuse method based on this model can shrink the scope for searching the reusable component in legacy software systems and thus improve the efficiency of legacy software reuse 2013 ieee code clone legacy system refactoring refactoring clones an optimization problem the refactoring of software clones is achieved by extracting their common functionality into a single method any differences in identifiers and literals between the clones have to become parameters in the extracted method obviously a large number of differences leads to an extracted method with limited reusability due to the large number of introduced parameters we support that minimizing the differences between the matched statements of clones is crucial for the purpose of refactoring and propose an algorithm that treats the matching process as an optimization problem 2013 ieee maximum common subgraph optimization program dependence graph refactoring software clones constructing defect predictors and communicating the outcomes to practitioners background an alternative to expert based decisions is to take data driven decisions and software analytics is the key enabler for this evidence based management approach defect prediction is one popular application area of software analytics however with serious challenges to deploy into practice goal we aim at developing and deploying a defect prediction model for guiding practitioners to focus their activities on the most problematic parts of the software and improve the efficiency of the testing process method we present a pilot study where we developed a defect prediction model and different modes of information representation of the data and the model outcomes namely commit hotness ranking error probability mapping to the source and visualization of interactions among teams through errors we also share the challenges and lessons learned in the process result in terms of standard performance measures the constructed defect prediction model performs similar to those reported in earlier studies e g 80 of errors can be detected by inspecting 30 of the source however the feedback from practitioners indicates that such performance figures are not useful to have an impact in their daily work pointing out most problematic source files even isolating error prone sections within files are regarded as stating the obvious by the practitioners though the latter is found to be helpful for activities such as refactoring on the other hand visualizing the interactions among teams based on the errors introduced and fixed turns out to be the most helpful representation as it helps pinpointing communication related issues within and across teams conclusion the constructed predictor can give accurate information about the most error prone parts creating practical representations from this data is possible but takes effort the error prediction research done in elektrobit wireless ltd is concluded to be useful and we will further improve the presentations made from the error prediction data 2013 ieee data driven decisions error prediction machine learning algorithms prediction algorithms software testing an initial investigation into change based reconstruction of floss refactorings today it is widely accepted that if refactoring is applied in practice it is mainly interweaved with normal software development so called floss refactoring unfortunately the current state of the art is poorly equipped to mine floss refactoring from version histories mainly because they infer refactorings by comparing two snapshots of a system and making educated guesses about the precise edit operations applied in between in this paper we propose a solution that reconstructs refactorings not on snapshots of a system but using the actual changes as they are performed in an integrated development environment we compare our solution against reffinder and demonstrate that on a small yet representative program the well known video rental system our approach is more accurate in identifying occurrences of the move method and rename method refactorings 2013 ieee first class changes floss refactoring refactoring detection agent based tool for topologically sorting badsmells and refactoring by analyzing complexities in source code code smells are smells found in source code as the source code becomes larger and larger we find bad smells in the source code these bad smells are removed using refactoring hence experts say the method of removing bad smells without changing the quality of code is called as refactoring 1 but this refactoring if not done properly is risky and can take time i e might be days or weeks hence here we provide a technique to arrange these bad smells analyze the complexities found in the source code and then refactor them these bad smell detection and scheduling has been done manually or semi automatically this paper provides a method of automatically detecting theses bad smells this automatic detection of bad smells are done with the help of java agent development jade 2013 ieee refactoring scheduling badsmells software engineering optimising conceptual data models through profiling in object databases agile methods promote iterative development with short cycles where user feedback from the previous iteration is used to refactor and improve the current version for information systems development we propose to extend this feedback loop by using database profiling information to propose adaptations to the conceptual model to improve performance for every software release our database profiler identifies and analyses navigational access patterns and proposes model optimisations based on data characteristics access patterns and a cost benefit model the proposed model optimisations are based on common database and data model refactoring patterns the database profiler has been implemented as part of an open source object database and integrated into an existing agile development environment where the model optimisations are presented as part of the ide we evaluate our approach based on an example of agile development of a research publication system springer verlag 2013 database profiling model optimisation object database design based re engineering of biosynthetic gene clusters plug and play in practice synthetic biology is revolutionizing the way in which the biosphere is explored for natural products through computational genome mining thousands of biosynthetic gene clusters are being identified in microbial genomes which constitute a rich source of potential novel pharmaceuticals new methods are currently being devised to prioritize these gene clusters in terms of their potential for yielding biochemical novelty high potential gene clusters from any biological source can then be activated by refactoring their native regulatory machinery replacing it by synthetic orthogonal regulation and optimizing enzyme expression to function effectively in an industry compatible target host various part libraries and assembly technologies have recently been developed which facilitate this process 2013 elsevier ltd extracting identifying and visualisation of the content users and authors in software projects the paper proposes a method for extracting identifying and visualisation of topics code tiers users and authors in software projects in addition to standard information retrieval techniques we use ast for source code and wordnet ontology to enrich document vectors extracted from parsed code lsi to reduce its dimensionality and the swarm intelligence in the bee behaviour inspired algorithms to cluster documents contained in it we extract topics from the identified clusters and visualise them in 3d graphs developers within and outside the teams can receive and utilize visualized information from the code and apply them to their projects this new level of aggregated 3d visualization improves refactoring source code reusing implementing new features and exchanging knowledge 2013 springer verlag berlin heidelberg ast authorship bee behaviour inspired algorithms latent semantic indexing software project source code swarm intelligence topic identification and extraction visualisation wordnet ontology concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones reengineering object oriented software oo into aspect oriented software ao is a challenging task mainly when it is done by means of refactorings in the code level the reason for it is that direct transformations from oo code to ao one involve several design decisions due to syntactic and semantic differences of both paradigms to make this task more controlled and systematic we can make use of concern based refactorings supported by models this type of refactorings concentrates on transforming broader scenarios into a set of context dependent scenarios rather than specific ones as in code level refactorings in this paper we propose a set of concern based refactorings that allows design decisions to be made during the reengineering process improving the quality of the final models two of them are presented in more details in this paper an example is presented to assess the applicability of the proposed refactorings moreover we also present a case study in which ao class models created based on the refactorings are compared with ao class models obtained without the aid of these refactorings the data obtained in this case study indicated to us that the use of the proposed refactorings can improve the efficacy and productivity of a maintenance group during the process of software reengineering aspect orientation class models concern based refactorings reengineering iceis 2013 proceedings of the 15th international conference on enterprise information systems the proceedings contain 189 papers the topics discussed include fairtrace a semantic web oriented traceability solution applied to the textile traceability selecting adequate samples for approximate decision support queries a data adaptive trace abstraction approach to the prediction of business process performances bridging the gap between multidimensional business problem formulation and the implementation of multidimensional data models deriving the conceptual model of a data warehouse from information requirements predicting fault proneness of object oriented system developed with agile process using learned bayesian network concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones evolutionary learning of business process models from legacy systems using incremental process mining multi perspective enterprise modelling as a foundation of method engineering and self referential enterprise systems and log analysis of human computer interactions regarding break the glass accesses to genetic reports iceis 2013 proceedings of the 15th international conference on enterprise information systems the proceedings contain 189 papers the topics discussed include fairtrace a semantic web oriented traceability solution applied to the textile traceability selecting adequate samples for approximate decision support queries a data adaptive trace abstraction approach to the prediction of business process performances bridging the gap between multidimensional business problem formulation and the implementation of multidimensional data models deriving the conceptual model of a data warehouse from information requirements predicting fault proneness of object oriented system developed with agile process using learned bayesian network concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones evolutionary learning of business process models from legacy systems using incremental process mining multi perspective enterprise modelling as a foundation of method engineering and self referential enterprise systems and log analysis of human computer interactions regarding break the glass accesses to genetic reports iceis 2013 proceedings of the 15th international conference on enterprise information systems the proceedings contain 189 papers the topics discussed include fairtrace a semantic web oriented traceability solution applied to the textile traceability selecting adequate samples for approximate decision support queries a data adaptive trace abstraction approach to the prediction of business process performances bridging the gap between multidimensional business problem formulation and the implementation of multidimensional data models deriving the conceptual model of a data warehouse from information requirements predicting fault proneness of object oriented system developed with agile process using learned bayesian network concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones evolutionary learning of business process models from legacy systems using incremental process mining multi perspective enterprise modelling as a foundation of method engineering and self referential enterprise systems and log analysis of human computer interactions regarding break the glass accesses to genetic reports measuring architecture quality by structure plus history analysis this case study combines known software structure and revision history analysis techniques in known and new ways to predict bug related change frequency and uncover architecture related risks in an agile industrial software development project we applied a suite of structure and history measures and statistically analyzed the correlations between them we detected architecture issues by identifying outliers in the distributions of measured values and investigating the architectural significance of the associated classes we used a clustering method to identify sets of files that often change together without being structurally close together investigating whether architecture issues were among the root causes the development team confirmed that the identified clusters reflected significant architectural violations unstable key interfaces and important undocumented assumptions shared between modules the combined structure diagrams and history data justified a refactoring proposal that was accepted by the project manager and implemented 2013 ieee change history fault prediction measure software architecture structure insight into a method co change pattern to identify highly coupled methods an empirical study in this paper we describe an empirical study of a unique method co change pattern that has the potential to pinpoint design deficiency in a software system we automatically identify this pattern by inspecting the method co change history using reasonable constraints on method association rules we also investigate the effect of code clones on the method co changes identified according to the pattern because there is a common intuition that clone fragments from the same clone class often require corresponding changes to ensure they remain consistent with each other according to our in depth investigation on hundreds of revisions of seven open source software systems considering three types of clones type 1 type 2 type 3 our identified pattern helps us detect methods that are logically coupled with multiple other methods and that exhibit a significantly higher modification frequency than other methods we call the methods detected by the pattern mmcgs methods appearing in multiple commit groups considering the pattern semantic mmcgs can be considered as the candidates for restructuring in order to minimize coupling as well as to reduce the change proneness of a software system according to our observation code clones have a significant effect on method co changes as well as on mmcgs we believe that clone refactoring can help us minimize evolutionary coupling among methods 2013 ieee association rules evolutionary coupling life span method co change pattern method genealogy modification occurrence rate refactoring packages of object oriented software using genetic algorithm based community detection technique refactoring is regarded as an effective way to address the software quality deterioration problem although many refactoring approaches have been proposed there is little work at the package level this paper proposes to use the community detection technique to refactor the packages of object oriented software it uses software class network to represent classes and their dependencies proposes a genetic algorithm based community detection algorithm to obtain the optimised package structures and finally provides a list of classes that should be moved by comparing the optimised package structures with the real package structures the empirical evaluation of the proposed approach has been performed in two open source java projects and the benefits of our approach are illustrated in comparison with the only one software refactoring approach at the package level viz adaptive k nearest neighbour algorithm and other five community detection algorithms used in the complex networks literature 2013 inderscience enterprises ltd community detection complex network genetic algorithm java object oriented open source package refactoring software software network where is the business logic one of the challenges in maintaining legacy systems is to be able to locate business logic in the code and isolate it for different purposes including implementing requested changes refactoring eliminating duplication unit testing and extracting business logic into a rule engine our new idea is an iterative method to identify the business logic in the code and visualize this information to gain better understanding of the logic distribution in the code as well as developing a domain specific business vocabulary this new method combines and extends several existing technologies including search aggregation and visualization we evaluated the visualization method on a large scale application and found that it yields useful results provided an appropriate vocabulary is available copyright 2013 acm business glossary business logic context based search tree map visualization obey optimal batched refactoring plan execution for class responsibility redistribution the redistribution of class responsibilities is a common reengineering practice in object oriented oo software evolution during the redistribution developers frequently construct batched refactoring plans for moving multiple methods and fields among various classes with an objective of carefully maintaining the cohesion and coupling degree of the class design executing a batched refactoring plan without introducing any objective violating side effect into the refactored code is essential however using most refactoring engines for batched refactoring plan execution introduces coupling increasing middle man bad smell in the final refactored code and therefore makes the refactoring execution suboptimal in achieving the redistribution objective this work proposes obey a methodology for optimal batched refactoring plan execution obey analyzes a batched refactoring plan identifies middle man symptoms that cause suboptimal execution and renovates the plan for optimal execution we have conducted an empirical study on three open source software projects to confirm the effectiveness of obey in a practical context 1976 2012 ieee batched refactoring execution change impact analysis class responsibility redistribution optimization reengineering identifying the move method refactoring opportunities based on evolutionary algorithm evolution is an intrinsic property of real world software which is usually accompanied by the degrading in software quality software refactoring is regarded as an effective way to improve the design of the code and many refactoring approaches have been proposed in this paper we transform the software refactoring problem as an optimisation problem and present a simple evolutionary algorithm ea to identify the move method refactorings it uses software networks at the feature i e method and attribute level namely sfn to represent features and their dependencies it uses an ea to obtain the optimised class structures in sfn it finally provides a list of methods that should be moved by comparing the optimised class structures with the real class structures the empirical evaluation of the proposed approach has been performed on one widely known refactoring example and the feasibility of our approach is illustrated copyright 2013 inderscience enterprises ltd community detection ea evolutionary algorithm refactoring software networks a scalable helmholtz solver in grapes over large scale multicore cluster this paper discusses performance optimization on the dynamical core of global numerical weather prediction model in global regional assimilation and prediction system grapes grapes is a new generation of numerical weather prediction system developed and currently used by chinese meteorology administration the computational performance of the dynamical core in grapes relies on the efficient solution of three dimensional helmholtz equations which lead to large scale and sparse linear systems formulated by the discretization in space and time we choose generalized conjugate residual gcr algorithm to solve the corresponding linear systems and further propose algorithm optimizations for large scale parallelism in two aspects i reduction of iteration number for solution and ii performance enhancement of each gcr iteration the reduction of iteration number is achieved by advanced preconditioning techniques combining block incomplete lu factorization k preconditioner over 7 diagonals of the coefficient matrix with the restricted additive schwarz method effectively the improvement for gcr iteration is to reduce the global communication operations by refactoring the gcr algorithm which decreases the communication overhead over large number of cores performance evaluation on the tianhe 1a system shows that the new preconditioning techniques reduce almost one third iterations for solving the linear systems the proposed methods can obtain 25 performance improvement on average compared with the original version of helmholtz solver in grapes and the speedup with our algorithms can reach 10 using 2048 cores compared with 256 cores copyright 2013 john wiley sons ltd additive schwarz method helmholtz equation ilu improved gcr algorithm numerical weather prediction proceedings of the 51st acm southeast conference acmse 2013 the proceedings contain 36 papers the topics discussed include mining probabilistic generalized frequent itemsets in uncertain databases a reduced dimensional approach to fast visually assisted search through high dimensional data exploiting sound latency using low level affective video features in amateur video generalization refactorings for reusable aspects identification and application of a model transformation design pattern towards a recursive iterative preconditioner developing computational models some aspects of conceptualization and implementation automated parameter estimation process for clustering algorithms used in software maintenance texture classification of landsat tm imagery using bayes point machine an environment for automated power measurements on mobile computing platforms novel method for using q learning in small microcontrollers and observing industrial control system attacks launched via metasploit framework monitor based instant software refactoring software refactoring is an effective method for improvement of software quality while software external behavior remains unchanged to facilitate software refactoring a number of tools have been proposed for code smell detection and or for automatic or semi automatic refactoring however these tools are passive and human driven thus making software refactoring dependent on developers spontaneity as a result software engineers with little experience in software refactoring might miss a number of potential refactorings or may conduct refactorings later than expected few refactorings might result in poor software quality and delayed refactorings may incur higher refactoring cost to this end we propose a monitor based instant refactoring framework to drive inexperienced software engineers to conduct more refactorings promptly changes in the source code are instantly analyzed by a monitor running in the background if these changes have the potential to introduce code smells i e signs of potential problems in the code that might require refactorings the monitor invokes corresponding smell detection tools and warns developers to resolve detected smells promptly feedback from developers i e whether detected smells have been acknowledged and resolved is consequently used to optimize smell detection algorithms the proposed framework has been implemented evaluated and compared with the traditional human driven refactoring tools evaluation results suggest that the proposed framework could drive inexperienced engineers to resolve more code smells by an increase of 140 percent promptly the average lifespan of resolved smells was reduced by 92 percent results also suggest that the proposed framework could help developers to avoid similar code smells through timely warnings at the early stages of software development thus reducing the total number of code smells by 51 percent 1976 2012 ieee code smell detection instant refactoring monitor software refactoring quantifying the effect of code smells on maintenance effort context code smells are assumed to indicate bad design that leads to less maintainable code however this assumption has not been investigated in controlled studies with professional software developers aim this paper investigates the relationship between code smells and maintenance effort method six developers were hired to perform three maintenance tasks each on four functionally equivalent java systems originally implemented by different companies each developer spent three to four weeks in total they modified 298 java files in the four systems an eclipse ide plug in measured the exact amount of time a developer spent maintaining each file regression analysis was used to explain the effort using file properties including the number of smells result none of the 12 investigated smells was significantly associated with increased effort after we adjusted for file size and the number of changes refused bequest was significantly associated with decreased effort file size and the number of changes explained almost all of the modeled variation in effort conclusion the effects of the 12 smells on maintenance effort were limited to reduce maintenance effort a focus on reducing code size and the work practices that limit the number of changes may be more beneficial than refactoring code smells 1976 2012 ieee code churn maintainability object oriented design product metrics a systematic mapping study on software product line evolution from legacy system reengineering to product line refactoring software product lines spls are used in industry to develop families of similar software systems legacy systems either highly configurable or with a story of versions and local variations are potential candidates for reconfiguration as spls using reengineering techniques existing spls can also be restructured using specific refactorings to improve their internal quality although many contributions including industrial experiences can be found in the literature we lack a global vision covering the whole life cycle of an evolving product line this study aims to survey existing research on the reengineering of legacy systems into spls and the refactoring of existing spls in order to identify proven approaches and pending challenges for future research in both subfields we launched a systematic mapping study to find as much literature as possible covering the diverse terms involved in the search string restructuring refactoring reengineering etc always connected with spls and filtering the papers using relevance criteria the 74 papers selected were classified with respect to several dimensions main focus research and contribution type academic or industrial validation if included etc we classified the research approaches and analyzed their feasibility for use in industry the results of the study indicate that the initial works focused on the adaptation of generic reengineering processes to spl extraction starting from that foundation several trends have been detected in recent research the integrated or guided reengineering of typically object oriented legacy code and requirements specific aspect oriented or feature oriented refactoring into spls and more recently refactoring for the evolution of existing product lines a majority of papers include academic or industrial case studies though only a few are based on quantitative data the degree of maturity of both subfields is different industry examples for the reengineering of the legacy system subfield are abundant although more evaluation research is needed to provide better evidence for adoption in industry product line evolution through refactoring is an emerging topic with some pending challenges although it has recently received some attention the theoretical foundation is rather limited in this subfield and should be addressed in the near future to sum up the main contributions of this work are the classification of research approaches as well as the analysis of remaining challenges open issues and research opportunities 2012 elsevier b v all rights reserved evolution legacy system reengineering refactoring software product line detecting refactored clones the availability of automated refactoring tools in modern development environments allows programmers to refactor their code with ease such tools however enable developers to inadvertently create code clones that quickly diverge in form but not in meaning furthermore in the hands of those looking to confuse plagiarism detection tools automated refactoring may be abused to avoid discovery of copied code we present cider an algorithm that can detect code clones regardless of various refactorings that may have been applied to some of the copies but not to others most significant is the ability to discover interprocedural clones where parts of one copy have been extracted to separate methods we evaluated cider on several open source java projects attempting to detect interprocedural clones between successive versions of each project interprocedural clones were detected in all evaluated projects demonstrating the pervasive nature of the problem compared to a manual assessment cider performed well in terms of both recall and precision 2013 springer verlag berlin heidelberg trading obliviousness for modularity with cooperative aspect oriented programming the potential of aspect oriented programming to adequately capture crosscutting concerns has yet to be fully realized for example authors have detailed significant challenges in creating reusable aspect component libraries one proposed solution is to introduce explicit join points ejps to increase modularity by reducing obliviousness enabling a cooperative aspect oriented programming co aop methodology where base code and aspects synergistically collaborate this article explores the trade offs between obliviousness and modularity we briefly introduce ejps and co aop and hypothesize how to balance obliviousness and modularity using co aop we build upon a prior empirical study to refactor three real life java applications to implement the exception handling concern using three distinct strategies 1 using fully oblivious aspects in aspectj 2 using ejps in a fully explicit fashion and 3 using ejps while following the co aop methodology we study other crosscutting concerns by refactoring a fourth application jhotdraw the differences in terms of common code metrics are analyzed and the impact on modularity is assessed using design structure matrices results indicate that the co aop methodology can in many cases significantly improve code quality attributes versus fully oblivious or fully explicit approaches we conclude with guiding principles on the proper use of ejps within the co aop methodology 2013 acm aspect oriented programming design structure matrix explicit join points modularity obliviousness sealion an eclipse based ide for answer set programming with advanced debugging support in this paper we present sealion an integrated development environment ide for answer set programming asp sealion provides source code editors for the languages of gringo and dlv and offers popular amenities like syntax highlighting syntax checking code completion visual program outline and refactoring functionality the tool has been realised in the context of a research project whose goal is the development of techniques to support the practical coding process of answer set programs in this respect sealion is the first ide for asp that provides debugging features that work for real world answer set programs and supports the rich languages of modern answer set solvers indeed sealion implements a stepping based debugging approach that allows the developer to quickly track down programming errors by simply following his or her intuitions on the intended semantics besides that sealion supports asp development using model driven engineering techniques including domain modelling with extended uml class diagrams and visualisation of answer sets in corresponding instance diagrams moreover customised visualisation as well as visual editing of answer sets is realised by the kara plugin of sealion further implemented features are a documentation generator based on the lana annotation language support for external solvers and interoperability with external tools sealion comes as a plugin of the popular eclipse platform and provides interfaces for future extensions of the ide copyright 2013 paula andra busoniu johannes oetsch jörg pührer peter skočovský and hans tompits discovering unexpected information using a building energy visualization tool building energy consumption is an important problem in construction field old buildings are gap of energy and they need to be refactored energy footprint of buildings needs to be reduced new buildings are designed to be suitable with energy eficiency paradigm to improve energy eficiency building management systems bms are used bms are it information technology systems composed by a rules engine and a database connected to sensors unfortunately bms are only monitoring systems they cannot predict and mine eficiently building information rider project has emerged from this observation this project is conducted by several french companies and universities ibm at montpellier france leads the project the main goal of this project is to create a smart and scalable bms this new kind of bms will be able to dig into data and predict events this it system is based on component paradigm and the core can be extended with external components some of them are developed during the project data mining building generation model and visualization all of these components will provide new features to improve rules used by the core in this paper we will focus on the visualization component this visualization use a volume rendering method based on sensors data interpolation and a correlation method to create new views we will present the visualization method used and which rules can be provided by this component 2013 spie is t analysis techniques data visualization volume dynamic profiling based approach to identifying cost effective refactorings context object oriented software undergoes continuous changes changes often made without consideration of the software s overall structure and design rationale hence over time the design quality of the software degrades causing software aging or software decay refactoring offers a means of restructuring software design to improve maintainability in practice efforts to invest in refactoring are restricted therefore the problem calls for a method for identifying cost effective refactorings that efficiently improve maintainability cost effectiveness of applied refactorings can be explained as maintainability improvement over invested refactoring effort cost for the system the more cost effective refactorings are applied the greater maintainability would be improved there have been several studies of supporting the arguments that changes are more prone to occur in the pieces of codes more frequently utilized by users hence applying refactorings in these parts would fast improve maintainability of software for this reason dynamic information is needed for identifying the entities involved in given scenarios functions of a system and within these entities refactoring candidates need to be extracted objective this paper provides an automated approach to identifying cost effective refactorings using dynamic information in object oriented software method to perform cost effective refactoring refactoring candidates are extracted in a way that reduces dependencies these are referred to as the dynamic information the dynamic profiling technique is used to obtain the dependencies of entities based on dynamic method calls based on those dynamic dependencies refactoring candidate extraction rules are defined and a maintainability evaluation function is established then refactoring candidates are extracted and assessed using the defined rules and the evaluation function respectively the best refactoring i e that which most improves maintainability is selected from among refactoring candidates then refactoring candidate extraction and assessment are re performed to select the next refactoring and the refactoring identification process is iterated until no more refactoring candidates for improving maintainability are found results we evaluate our proposed approach in three open source projects the first results show that dynamic information is helpful in identifying cost effective refactorings that fast improve maintainability and considering dynamic information in addition to static information provides even more opportunities to identify cost effective refactorings the second results show that dynamic information is helpful in extracting refactoring candidates in the classes where real changes had occurred in addition the results also offer the promising support for the contention that using dynamic information helps to extracting refactoring candidates from highly ranked frequently changed classes conclusion our proposed approach helps to identify cost effective refactorings and supports an automated refactoring identification process 2012 elsevier b v all rights reserved cost effective refactoring dynamic method call dynamic profiling maintainability improvement refactoring cost refactoring identification complete high dimensional inverse characterization of fractal surfaces and volumes in the present paper we are describing a methodology for the determination of the complete set of parameters associated with the weierstrass mandelbrot w m function that can describe a fractal scalar field distribution defined by measured or computed data distributed on a surface or in a volume our effort is motivated not only by the need for accurate fractal surface and volume reconstruction but also by the need to be able to describe analytically a scalar field quantity distribution on a surface or in a volume that corresponds to various material properties distributions for engineering and science applications our method involves utilizing a refactoring of the w m function that permits defining the characterization problem as a high dimensional inverse problem solved by singular value decomposition for the so called phases of the function coupled with this process is a second level exhaustive search that enables the determination of the density of the frequencies involved in defining the trigonometric functions participating in the definition of the w m function numerical applications of the proposed method on both synthetic and actual surface and volume data validate the efficiency and the accuracy of the proposed approach this approach constitutes a radical departure from the traditional fractal dimension characterization studies and opens the road for a very large number of applications copyright 2013 by asme a study on the relation between antipatterns and the cost of class unit testing antipatterns are known as recurring poor design choices recent and past studies indicated that they negatively affect software systems in terms of understand ability and maintainability also increasing change and defect proneness for this reason refactoring actions are often suggested in this paper we investigate a different side effect of antipatterns which is their effect on testability and on testing cost in particular we consider as upper bound indicator of testing cost the number of test cases that satisfy the minimal data member usage matrix madum criterion proposed by bashir and goel a study carried out on four java programs ant 1 8 3 argouml 0 20 check style 4 0 and jfreechart 1 0 13 supports the evidence that on the one hand antipatterns unit testing requires on average a number of test cases substantially higher than unit testing for non antipattern classes on the other hand antipattern classes must be carefully tested because they are more defect prone than other classes finally we illustrate how specific refactoring actions applied to classes participating in antipatterns could reduce testing cost 2013 ieee antipatterns object oriented testing refactoring testing cost a reference architecture for organizing the internal structure of metadata based frameworks metadata based frameworks enable behavior adaptation through the configuration of custom metadata in application classes most of the current frameworks used in the industry for building enterprise applications adopt this approach however there is a lack of proven techniques for building such kind of framework allowing for a better organization of its internal structure in this paper we propose a pattern language and a reference architecture for better organizing the internal structure of metadata based frameworks which were defined as a result of a pattern mining process applied to a set of existing open source frameworks to evaluate the resulting structure generated by the reference architecture application a case study examined three frameworks developed according to the proposed reference architecture each one referring to a distinct application domain the assessment was conducted by using a metrics suite metrics thresholds derived from a large set of open source metadata based frameworks a process for automatic detection of design disharmonies and manual source code analysis as a result of this study framework developers can understand and use the proposed reference architecture to develop new frameworks and refactor existing ones the assessment revealed that the organization provided by the reference architecture is suitable for metadata based frameworks helping in the division of responsibility and functionality among their classes 2012 elsevier inc framework metadata metadata based framework pattern language reference architecture software architecture refactoring software packages via community detection in complex software networks an intrinsic property of software in a real world environment is its need to evolve which is usually accompanied by the increase of software complexity and deterioration of software quality making software maintenance a tough problem refactoring is regarded as an effective way to address this problem many refactoring approaches at the method and class level have been proposed but the research on software refactoring at the package level is very little this paper presents a novel approach to refactor the package structures of object oriented software it uses software networks to represent classes and their dependencies it proposes a constrained community detection algorithm to obtain the optimized community structures in software networks which also correspond to the optimized package structures and it finally provides a list of classes as refactoring candidates by comparing the optimized package structures with the real package structures the empirical evaluation of the proposed approach has been performed in two open source java projects and the benefits of our approach are illustrated in comparison with the other three approaches 2013 institute of automation chinese academy of sciences and springer verlag berlin heidelberg community detection complex networks package refactoring software refactoring delta oriented software product lines delta oriented programming dop is an implementation approach to develop software product lines spl deltaoriented spls evolve over time due to new or changed requirements and need to be maintained to retain their value refactorings have been proposed as behavior preserving program transformations that improve the design and structure of object oriented software systems however there is a lack of refactoring support for software product lines since refactoring of spls is more complex than of single systems for refactoring spls we have to preserve the behavior of probably thousands of programs instead of only one in this paper we address the refactoring of software product lines by presenting a catalogue of refactorings for delta oriented spls additionally we propose code smells to guide developers to potential refactoring opportunities we show how code smells can aid the identification of spl refactorings and how these refactorings improve the evolvability and maintainability of delta oriented spls copyright 2013 acm delta oriented programming evolution refactoring software product lines aoasia 2013 proceedings of the 8th international workshop on advanced modularization techniques aoasia pacific the proceedings contain 7 papers the topics discussed include an aspect oriented cpu resource reservation framework integrated in mde tools aspect jquery an aspect oriented framework for jquery modularizing tenant specific schema customization in saas applications towards generating templates of method body based on method name and related identifiers interaction awareness for aspect refactoring hierarchical concern based pointcuts and towards aspect oriented state machine language for embedded software quality of merge refactorings for product lines in this paper we consider the problem of refactoring related software products specified in uml into annotative product line representations our approach relies on identifying commonalities and variabilities in existing products and further merging those into product line representations which reduce duplications and facilitate reuse varying merge strategies can lead to producing several semantically correct yet syntactically different refactoring results depending on the goal of the refactoring one result can be preferred to another we thus propose to capture the goal using a syntactic quality function and use that function to guide the merge strategy we define and implement a quality based merge refactoring framework for uml models containing class and statechart diagrams and report on our experience applying it on three case studies 2013 springer verlag identification of generalization refactoring opportunities generalization refactoring helps relate classes and share functions including both interfaces and implementation by inheritance to apply generalization refactoring developers should first identify potential generalization refactoring opportunities i e software entities that might benefit from generalization refactoring for non trivial software systems manual identification of these opportunities is challenging and time consuming however to the best of our knowledge no existing tools have been specif ically designed for this task as a result people have to identify these opportunities manually or with the help of tools designed for other purposes e g clone detectors to this end we propose a tool genreferee generalization referee to identify potential refactoring opportunities according to conceptual relationship implementation similarity structural correspondence and inheritance hierarchies it was first calibrated on two non trivial open source applications and then evaluated on another three evaluation results suggest that the proposed approach is effective and efficient 2012 springer science business media llc generalization refactoring opportunity identification software maintenance software quality software refactoring tool support an information foraging theory perspective on tools for debugging refactoring and reuse tasks theories of human behavior are an important but largely untapped resource for software engineering research they facilitate understanding of human developers needs and activities and thus can serve as a valuable resource to researchers designing software engineering tools furthermore theories abstract beyond specific methods and tools to fundamental principles that can be applied to new situations toward filling this gap we investigate the applicability and utility of information foraging theory ift for understanding information intensive software engineering tasks drawing upon literature in three areas debugging refactoring and reuse in particular we focus on software engineering tools that aim to support information intensive activities that is activities in which developers spend time seeking information regarding applicability we consider whether and how the mathematical equations within ift can be used to explain why certain existing tools have proven empirically successful at helping software engineers regarding utility we applied an ift perspective to identify recurring design patterns in these successful tools and consider what opportunities for future research are revealed by our ift perspective 2013 acm information foraging software maintenance qualitative analysis for the impact of accounting for special methods in object oriented class cohesion measurement class cohesion is a key object oriented software quality attribute it refers to the degree of relatedness of class attributes and methods several class cohesion metrics are proposed in the literature however the impact of considering the special methods i e constructors destructors and access and delegation methods in cohesion calculation is not thoroughly theoretically studied for most of the existing cohesion metrics an incorrect determination of whether to include or exclude the special methods in cohesion measurement can lead to improper refactoring decisions according to the misleading class cohesion values that are obtained in this paper we qualitatively analyze the impact of including or excluding the special methods in cohesion measurement on the values that are obtained by applying 19 popular class cohesion metrics the study is based on analyzing the definitions and formulas that are proposed for the metrics the results show that including excluding special methods has a considerable effect on the cohesion values that are obtained and that this effect varies from one metric to another the study shows the importance of considering the types of methods that must be accounted for when proposing a cohesion metric 2013 academy publisher class cohesion class quality cohesion metric object oriented design special methods objective evaluation of software architectures in driver assistance systems methods quality model metrics this paper describes methods and the obtained results for objective evaluation of software architectures in the automotive embedded domain software architecture is the key factor for influencing and fulfilling non functional requirements that are addressed to a software system among others scalability extensibility and portability are to be mentioned as major criteria until today however there is no approach that allows evaluating and measuring the quality of such software architectures objectively and quantitatively the approach described here tries to close this gap and offers software architects methods and tools to be applied automatically to any existing architecture draft measuring an objective quality value initially a quality model is developed which consists of several quality characteristics and quality attributes which are highly adapted and specialized to the specific needs of the automotive embedded software domain after the identification of relevant quality attributes eight objective architecture metrics are developed and presented the whole methodology is fully integrable into existing development processes the suggested steps and artifacts can be added as optional upgrade for a better understanding of the surrounding environment the current development process and necessary extensions are also explained all metrics have been implemented in a fully functioning prototypical tool which can be operated via a graphical user interface gui on any java compliant system without further requirements the user can freely configure which metrics shall be applied and how they are weighted to do an individual evaluation according to the software s specific needs or requirements to prove its benefit for automotive applications and long term establishment in the software development process the approach is evaluated this is done in two consecutive steps firstly the general functioning and applicability is approved by using the metrics for several small case studies which also helped getting to know the metrics better in detail to create an initial balancing and weighting secondly the approach was applied to a complex and real practical example out of the driver assistance domain the whole longitudinal dynamics software architecture of bmw s driver assistance systems was refactored using the metrics to monitor the success and keep up a goal oriented iterative and incremental procedure 2011 springer verlag automotive embedded software driver assistance systems objective metrics software architecture software quality suggesting extract class refactoring opportunities by measuring strength of method interactions 2013 ieee for improving the modularity of a large software system metrics can be valuable to help finding refactoring opportunities for classes we define a novel metric that is intended to suggest how closely connected are the elements of a class the metric characterises the strength of the coupling between methods of a class based on invocations and the size of the parameters involved as well as attribute accesses the assessment of the strength of interactions turns out to be valuable in providing an indication on the possible changes that classes need to become more modular and prone to be reused according to the computed metric and the assessment of system wide relationships between classes we are able to suggest extract class refactoring opportunities the capability of the proposed approach to evaluate object oriented systems is demonstrated by analysing a large software system metrics modularity refactoring a clustering method for pruning false positive of clonde code detection 2013 ieee there are some false positives when detect syntax similar cloned code with clone code technology based on token in this paper we propose a novel algorithm to automatically prune false positives of clone code detection by performing clustering with different attribute and weights first closely related statements are grouped into a cluster by performing clustering second compare the hash values of the statements in the two clusters to prune false positives the experimental results show that our method can effectively prune clone code false positives caused by switching the orders of same structure statments it not only improves the accuracy of cloned code detection and cloned code related defects detection but also contribute to the following study of cloned code refactoring cloned code clustering false positives refactoring style identifying extract method opportunities based on variable references copyright 2013 by knowledge systems institute graduate school long methods are usually difficult to read and comprehend due to the length and complexity of the code as a result maintenance can be time consuming and costly one strategy to lower overall cost of software development for large systems is to produce smaller and less complex methods through method refactoring this paper presents a new technique to automate the selection process of program fragments for refactoring the soundness of this technique has been demonstrated through experiments on several different software systems long method defects can effectively be resolved by extracting code fragments identified with the support of a tool we have developed extract method refactoring long method defects placement tree sql schema comparer support of multi language refactoring with relational databases refactoring is a method to change a source code s structure without modifying its semantics and was first introduced for object oriented code since then refactorings were defined for relational databases too but database refactorings must be treated differently because a database schema s structure defines semantics used by other applications to access the data in the schema thus many database refactorings may break interaction with other applications if not treated appropriately we discuss problems of database refactoring in regard to java code and present sql schema comparer a library to detect refactorings of database schemes the sql schema comparer library is our first step to more advanced tools supporting developers in their database refactoring efforts 2013 ieee measuring the structural similarity between source code entities copyright 2013 by knowledge systems institute graduate school similarity coefficients are widely used in software engineering for several purposes such as identification of refactoring opportunities and system remodularizations although the literature provides several similarity coefficients that vary on the computing strategy there is a tendency among researchers to make habitual use of certain coefficients that others in their field are using consequently some approaches might be using an inadequate coefficient for their purpose in this paper we conduct a quantitative study that compares 18 coefficients to identify which one is the most appropriate in determining where a class should be located our evaluation contemplates 111 open source systems from qualitas corpus which totalizes more than 70 000 classes as a result we observed that jaccard one of the most used coefficients in our area has not presented the best results while jaccard correctly indicated the suitable module to 22 of the classes other coefficients were able to indicate 60 a catalog of bad smells in design by contract methodologies with java modeling language bad smells are usually related to program source code arising from bad design and programming practices refactoring activities are often motivated by the detection of bad smells with the increasing adoption of design by contract dbc methodologies in formal software development evidence of bad design practices can similarly be found in programs that combine actual production code with interface contracts these contracts can be written in languages such as the java modeling language jml an extension to the java syntax this paper presents a catalog of bad smells that appear during dbc practice considering jml as the language for specifying contracts these smells are described over jml constructs although several can appear in other dbc languages the catalog contains 6 dbc smells we evaluate the recurrence of dbc smells in two ways first by describing a small study with graduate student projects and second by counting occurrences of smells in contracts from the jml models application programming interface api this api contains classes with more than 1 600 lines in contracts along with the documented smells suggestions are provided for minimizing the impact or even removing a bad smell it is believed that initiatives towards the cataloging of bad smells are useful for establishing good design practices in dbc 2013 the korean institute of information scientists and engineers bad smells design by contract java modeling language refactoring how to extract differences from similar programs a cohesion metric approach merging similar programs is a promising solution to improve the maintainability of source code before merging programs any syntactic difference has to be extracted as a new method however it is difficult for a developer to identify and extract differences from programs appropriately because he she has to consider not only syntactic and semantic correctness but also the modularity of the programs after merging in this paper we propose a slice based cohesion metrics approach to suggesting the extractions of differences from similar java methods this approach identifies syntactic differences from two methods and then suggests sets of cohesive regions including those differences the case study shows that the proposed approach can suggest refactorings that not only merge two methods but also increase the cohesiveness 2013 ieee supporting requirements traceability through refactoring modern traceability tools employ information retrieval ir methods to generate candidate traceability links these methods track textual signs embedded in the system to establish relationships between software artifacts however as software systems evolve new and inconsistent terminology finds its way into the system s taxonomy thus corrupting its lexical structure and distorting its traceability tracks in this paper we argue that the distorted lexical tracks of the system can be systematically re established through refactoring a set of behavior preserving transformations for keeping the system quality under control during evolution to test this novel hypothesis we investigate the effect of integrating various types of refactoring on the performance of requirements to code automated tracing methods in particular we identify the problems of missing misplaced and duplicated signs in software artifacts and then examine to what extent refactorings that restore move and remove textual information can overcome these problems respectively we conduct our experimental analysis using three datasets from different application domains results show that restoring textual information in the system has a positive impact on tracing in contrast refactorings that remove redundant information impact tracing negatively refactorings that move information among the system modules are found to have no significant effect our findings address several issues related to code and requirements evolution as well as refactoring as a mechanism to enhance the practicality of automated tracing tools 2013 ieee information retrieval refactoring traceability research on the merging of feature models feature models provide an effective way to organize and reuse software requirements in a specific domain constructing a feature model needs a systematic analysis of as many applications as possible in a domain to identify commonality variability and dependencies among requirements with the increasing complexity of domains the scale of feature models can be extremely large and the construction of large feature models is an overwhelming task for human that computer aided automation is needed a feasible way is to merge existing feature models into a large one and human developers only need to do some refactoring work in this paper we survey six methods of merging feature models we propose a conceptual framework first and then analyze and compare the six methods finally we identify three problems in existing research and propose possible ideas to handle these problems algorithm feature model model merge software reuse information and knowledge retrieval within software projects and their graphical representation for collaborative programming this paper proposes information and knowledge mining in the source code of medium and large enterprise projects our methods try to recognize structures and types of source code identify authors and users to enhance collaborative programming and support knowledge management in software companies developers within and outside the teams can receive and utilize visualized information from the code and apply it to their projects this new level of aggregated 3d visualization improves refactoring source code reusing implementing new features and exchanging knowledge authors code tagging collaborative programming information and knowledge mining knowledge management recognition source code type users visualization jsnose detecting javascript code smells javascript is a powerful and flexible prototypebased scripting language that is increasingly used by developers to create interactive web applications the language is interpreted dynamic weakly typed and has first class functions in addition it interacts with other web languages such as css and html at runtime all these characteristics make javascript code particularly error prone and challenging to write and maintain code smells are patterns in the source code that can adversely influence program comprehension and maintainability of the program in the long term we propose a set of 13 javascript code smells collected from various developer resources we present a javascript code smell detection technique called jsnose our metric based approach combines static and dynamic analysis to detect smells in client side code this automated technique can help developers to spot code that could benefit from refactoring we evaluate the smell finding capabilities of our technique through an empirical study by analyzing 11 web applications we investigate which smells detected by jsnose are more prevalent 2013 ieee code smell javascript smell detection web applications refactoring boundary we argue that the limit of the propagation of the heap effects of a source code modification is determined by the aliasing structure of method parameters in a trace of the method calls that cross a boundary which partitions the heap further that this aliasing structure is sufficient to uniquely determine the state of the part of the heap which has not been affected and we give a definition of what it means for a part of the heap to be unaffected by a source code modification this can be used to determine the correctness of a refactoring object oriented refactoring 2013 21st ieee international requirements engineering conference re 2013 proceedings the proceedings contain 64 papers the topics discussed include automated text mining for requirements analysis of policy documents an empirical investigation of software engineers ability to classify legal cross references supporting requirements traceability through refactoring foundations for an expert system in domain specific traceability application of reinforcement learning to requirements engineering requirements tracing a mode based pattern for feature requirements and a generic feature interface how cloud providers elicit consumer requirements an exploratory study of nineteen companies visual notation design 2 0 towards user comprehensible requirements engineering notations assumption based risk identification method arm in dynamic service provisioning can requirements dependency network be used as early indicator of software integration bugs and requirements reviews revisited residual challenges and open research questions on proving the concept of an ontology aided software refactoring tool through years more and more software is produced the quality of software architecture however has an important role in systems exploitation as it determines the maintainability and extensibility of an application recently more emphasis is put on quality of the design so that new features can be added with ease to preserve code readability and extensibility software architecture must be refactored from time to time to cope with the modifications nevertheless reviewing the whole source code is time consuming and does not return any surplus thus it is often skipped causing the software architecture to decay in time over several modifications and making it harder to add new functionality in the future an automated method of recognizing bad code would help to solve some of the issues in this article the authors propose a concept of a refactoring tool which uses ontology to find smelly design and tackle the aforementioned problems several aspects of the tool are discussed how it works and how it can be used to improve the software architecture thus augment the quality 2013 the authors and ios press all rights reserved ontology software architecture improvement software refactoring a field study of refactoring challenges and benefits it is widely believed that refactoring improves software quality and developer productivity however few empirical studies quantitatively assess refactoring benefits or investigate developers perception towards these benefits this paper presents a field study of refactoring benefits and challenges at microsoft through three complementary study methods a survey semi structured interviews with professional software engineers and quantitative analysis of version history data our survey finds that the refactoring definition in practice is not confined to a rigorous definition of semantics preserving code transformations and that developers perceive that refactoring involves substantial cost and risks we also report on interviews with a designated refactoring team that has led a multi year centralized effort on refactoring windows the quantitative analysis of windows 7 version history finds that the binary modules refactored by this team experienced significant reduction in the number of inter module dependencies and post release defects indicating a visible benefit of refactoring 2012 acm churn component dependencies defects empirical study refactoring software evolution detecting inconsistent names of source code using nlp software developers use refactoring in order to improve quality of source code refactoring is a disciplined technique for restructuring an existing body of code without changing its external behavior 3 for example extract method is the one of the refactoring approaches to improving readability of the large scale method by splitting them into several small scale methods in refactoring code smell indicates any symptom in the source code that possibly causes a deeper problem although inconsistent names of source code elements as one of the code smells are crucial it is hardly achieved by going through the whole source code furthermore it generally can be handled by several developers that understand the source code and also is easy to pass without checking because it does not affect software execution 2012 springer verlag quantifying quality of software design to measure the impact of refactoring software design plays a vital role in a software system a flexible maintainable extensible and re usable software design enables easier integration of new requirements in the current era of software development refactoring is used periodically to fine tune a software design refactoring limits technical debt and improves overall quality of a software design however providing a quantitative measure to estimate the impact of a refactoring exercise on a software design is a non trivial challenge in this paper we present a method to estimate the quality extendibility and flexibility aspects of a software design the method proposes an index namely software design quality index sdqi to estimate the quality of a software design the index can be employed to measure the impact of a refactoring exercise on software design moreover the method can be used to benchmark and compare software design quality of different software systems 2012 ieee refactoring software design quality software design quality index sdqi code smell detecting tool and code smell structure bug relationship this paper proposes an approach for detecting the socalled bad smells in software known as code smell in considering software bad smells object oriented software metrics were used to detect the source code whereby eclipse plugins were developed for detecting in which location of java source code the bad smell appeared so that software refactoring could then take place the detected source code was classified into 7 types large class long method parallel inheritance hierarchy long parameter list lazy class switch statement and data class this work conducted analysis by using 323 java classes to ascertain the relationship between the code smell and structural defects of software by using the data mining techniques of naive bayes and association rules the result of the naive bayes test showed that the lazy class caused structural defects in dls de and se also data class caused structural defects in uwf de and se while long method large class data class and switch statement caused structural defects in uwf and se finally parallel inheritance hierarchy caused structural defects in se however long parameter list caused no structural defects whatsoever the results of the association rules test found that the lazy class code smell caused structural defects in dls and de which corresponded to the results of the naive bayes test 2012 ieee code smell refactoring software metric structural bugs ecoop 2012 object oriented programming 26th european conference proceedings the proceedings contain 30 papers the topics discussed include is it dangerous to use version control histories to study source code evolution evaluating the design of the r language objects and functions for data analysis mcsaf a static analysis framework for matlab multiple aggregate entry points for ownership types inference and checking of object ownership object initialization in x10 lock inference in the presence of large libraries an analysis of the mozilla jetpack extension framework smaller footprint for java collections enhancing javascript with transactions javascript as an embedded dsl correlation tracking for points to analysis of javascript constraint based refactoring with foresight magda a new language for modularity and marco safe expressive macros for any language parameter based refactoring and the relationship with fan in fan out coupling in this paper we analyze the effect of particular refactorings on class coupling for different aggregate releases of four object oriented open source os java software systems azureus jtopen jedit and tomcat as representative of general java os systems specifically the add parameter to a method and remove parameter from a method refactorings as defined according to fowler may in uence class coupling changing fan in and fan out of classes they are applied to we investi gate both qualitatively and quantitatively using a statistical approach the global effect of the application of such refactorings providing best fitting statistical distributions able to describe the changes in fan in and fan out couplings results show a net tendency of developers to apply such refactorings to classes with relatively high fan in and fan out and a persistence of the same statistical distribution for fan in and fan out before and after refactoring finally we provide a detailed analysis of the best fitting parameters and of their changes when refactoring occurs which may be useful for estimating the effect of refactoring on coupling before it is applied since refactoring requires time and effort these estimates may help in determining costs and benefits jot 2011 coupling fan in fan out metric distribution refactoring a semantic web based approach for design pattern detection from source code design patterns provide experience reusability and increase quality of object oriented designs knowing which design patterns are implemented in a software is important in comprehending maintaining and refactoring its design however despite the interest in using design patterns traditionally their usage is not explicitly documented therefore a method is required to reveal this information from some artifacts of the systems e g source codes models and executables in this paper an approach is proposed which uses the semantic web technologies for automatically detecting design patterns from java source code it is based on the semantic data model as the internal representation and on sparql query execution as the analysis mechanism experimental evaluations demonstrate that this approach is both feasible and effective and it reduces the complexity of detecting design patterns to creating a set of sparql queries 2012 ieee design pattern ontology semantic web software analysis source code towards a multi view approach to model driven refactoring model driven engineering an emerging trend in software engineering has enabled the application of refactoring to uml models one of the important steps in refactoring is the identification of refactoring opportunities within the model also referred to as model smells an object oriented system modeled by uml is built up from many different views model refactoring in recent proposals is applied to a single view in the model hence information from other views are either not considered or later synchronized for consistency preservation in this paper we outline an approach to refactor uml models using a multi view approach we exploit the inter view relationship to suggest model smells by combining information from each uml view we restrict our scope to one diagram from each uml view class diagram structural view sequence diagram behavioral view and use case diagram functional view for each model smell we describe a steps to detect the existence of the model smell b set of composite refactorings to remove the detected smell and c demonstration using a running example we also propose a multi view model refactoring framework to realize the approach proposed in this paper 2012 ieee class diagram model refactoring sequence diagram uml use case diagram refactoring meets spreadsheet formulas the number of end users who write spreadsheet programs is at least an order of magnitude larger than the number of trained programmers who write professional software we studied a corpus of 3691 spreadsheets and we found that their formulas are riddled with the same smells that plague professional software hardcoded constants duplicated expressions unnecessary complexity and unsanitized input these make spreadsheets difficult to read and expensive to maintain like automated refactoring in the object oriented domain spreadsheet refactoring can be transformative in this paper we present seven refactorings for spreadsheet formulas implemented in refbook a plugin for microsoft excel to evaluate the usefulness of refbook we employed three kinds of empirical methods first we conducted a user survey with 28 excel users to find out whether they preferred the refactored formulas second we conducted a controlled experiment with the same 28 participants to measure their productivity when doing manual refactorings third we performed a retrospective case study on the euses spreadsheet corpus with 3691 spreadsheets to determine how often we could apply the refactorings supported by refbook the results show i users prefer the improved quality of refactored formulas ii refbook is faster and more reliable than manual refactoring and iii the refactorings are widely applicable on average refbook is able to apply the refactorings in less than half the time that users performed the refactorings manually 92 54 of users introduced errors or new smells into the spreadsheet or were unable to complete the task 2012 ieee applying game theory to restructure pl sql code success of any organization is based on the quality of the information system which undergoes many alterations during its life cycle hence it can be quoted as an example for a live entity database is a core component in any information system and it gets affected due to change in business logic a popularly used data model in any organization is the relational model changes that are made in relational schema also modify the queries that access the relations it is really difficult to identify the set of queries that access the same relation in the case of large information system similarity measures concept is one of the techniques that are applied in object oriented programming for refactoring is used in this proposed system for restructuring procedures into packages by taking pl sql code as input the proposed system groups those queries or procedures that access the same relations into a single package the objective of this research is to determine whether the proposed methodology can be used as a mechanism to improve the maintainability of pl sql code this process of packaging is done by applying game theoiy so as to increase understandability and maintainability of the system medwell journals 2012 game theoiy nash equilibrium packaging pay off matrix pl sql refactoring restructuring structural similarity move code refactoring with dynamic analysis in order to reduce coupling and increase cohesion we refactor program source code previous research efforts for suggesting candidates of such refactorings are based on static analysis which obtains relations among classes or methods from source code however these approaches cannot obtain runtime information such as repetition count of loop dynamic dispatch and actual execution path therefore previous approaches might miss some refactoring opportunities to tackle this problem we propose a technique to find refactoring candidates by analyzing method traces we have implemented a prototype tool based on the proposed technique and evaluated the technique on two software systems as a result we confirmed that the proposed technique could detect some refactoring candidates which increase code quality 2012 ieee dynamic analysis move method refactoring refactoring software maintenance research on detecting and validating design pattern instances from source code identifying design patterns from source code is one of the most promising methods for improving software maintainability reusing experience and facilitating software refactoring in this paper an approach that combines static and dynamic analysis on detecting design patterns from java source code is presented static structure analysis of identifying pattern instances is illustrated especially to improve the detecting precision multiplicity analysis of object creation is executed to validate creational pattern candidates and dynamic analysis which is the process of monitoring sequence of method calls in pattern candidates and judging if it is consistent to the expected pattern behavior is executed to validate behavior pattern candidates after the validation of behavior candidates those instances belong to patterns which have similar structure but different behavior are distinguished successfully finally a tool of extracting design pattern from java source code is implemented and the feasibility of this approach is verified through the results of applying it on an open source software 2012 ieee design pattern dynamic analysis multiplicity analysis reverse engineering how often do unintended inconsistencies happen deriving modification patterns and detecting overlooked code fragments it is difficult to keep consistent source code unintended inconsistencies occur unless we recognize all the code fragments that need to modify in a given bug fix or functional addition before modifying source code keyword based search tools like grep or code clone detection tools can be used to prevent code fragments from being overlooked however once inconsistencies occur in the source code such tools cannot help us adequately in this paper we propose a new method to identify unintended inconsistencies in source code automatically the proposed method analyzes source code modifications in a repository to derive modification patterns a modification pattern indicates what kind of code and how it was modified the derived modification patterns are queries to identify unintended inconsistencies from the latest version of source files we implemented the proposed method and applied it to freebsd and apache httpd as a result we identified many overlooked code fragments for bug fixes functional enhancements and refactorings the precisions were 73 4 and 88 9 for the two systems respectively 2012 ieee inconsistency detection modification patterns static analysis selecting refactorings an option based approach refactoring aims to improve the design of existing code to cope with foreseen software architecture evolution the selection of the optimum refactoring strategy can be a daunting task involving the identification of refactoring candidates the determination of which refactorings to apply and the assessment of the refactoring impact on software product quality characteristics as such the benefits from refactorings are measured from the quality advancements achieved through the application of state of the art structural quality assessments on refactored code perceiving refactoring trough the lens of value creation the optimum strategy should be the one that maximizes the endurance of the architecture in future imposed changes we argue that an alternative measurement and examination of the refactoring success is possible one that focuses on the balance between effort spent and anticipated cost minimization in this arena traditional quality evaluation methods fall short in examining the financial implications of uncertainties imposed by the frequent updates modifications and by the dynamics of the xp programming in this paper we apply simple real options analysis techniques and we perceive the selection of the optimum refactoring strategy as an option capable of generating value cost minimization upon adoption doing so we link the endurance of the refactored architecture to its true monetary value to get an estimation of the expected cost that is needed to apply the considered refactorings and to the effect of applying them in the cost of future adoptions we conducted a case study the results of the case study suggest that every refactoring can be associated with different benefit levels during system extension 2012 ieee architecture edurance real options refactorings increasing clone maintenance support by unifying clone detection and refactoring activities context clone detection tools provide an automated mechanism to discover clones in source code on the other side refactoring capabilities within integrated development environments provide the necessary functionality to assist programmers in refactoring however we have observed a gap between the processes of clone detection and refactoring objective in this paper we describe our work on unifying the code clone maintenance process by bridging the gap between clone detection and refactoring method through an eclipse plug in called cedar clone detection analysis and refactoring we forward clone detection results to the refactoring engine in eclipse in this case the refactoring engine is supplied with information about the detected clones to which it can then determine those clones that can be refactored we describe the extensions to eclipse s refactoring engine to allow clones with additional similarity properties to be refactored results our evaluation of open source artifacts shows that this process yields considerable increases in the instances of clone groups that may be suggested to the programmer for refactoring within eclipse conclusion by unifying the processes of clone detection and refactoring in addition to providing extensions to the refactoring engine of an ide the strengths of both processes i e more significant detection capabilities and an established framework for refactoring can be garnered 2012 elsevier b v all rights reserved code clones maintenance refactoring when does a refactoring induce bugs an empirical study refactorings are as defined by fowler behavior preserving source code transformations their main purpose is to improve maintainability or comprehensibility or also reduce the code footprint if needed in principle refactorings are defined as simple operations so that are unlikely to go wrong and introduce faults in practice refactoring activities could have their risks as other changes this paper reports an empirical study carried out on three java software systems namely apache ant xerces and ar go uml aimed at investigating to what extent refactoring activities induce faults specifically we automatically detect and then manually validate 15 008 refactoring operations of 52 different kinds using an existing tool ref finder then we use the szz algorithm to determine whether it is likely that refactorings induced a fault results indicate that while some kinds of refactorings are unlikely to be harmful others such as refactorings involving hierarchies e g pull up method tend to induce faults very frequently this suggests more accurate code inspection or testing activities when such specific refactorings are performed 2012 ieee empirical studies fault inducing changes mining software repositories refactoring an empirical investigation into the impact of refactoring on regression testing it is widely believed that refactoring improves software quality and developer s productivity by making it easier to maintain and understand software systems on the other hand some believe that refactoring has the risk of functionality regression and increased testing cost this paper investigates the impact of refactoring edits on regression tests using the version history of java open source projects 1 are there adequate regression tests for refactoring in practice 2 how many of existing regression tests are relevant to refactoring edits and thus need to be re run for the new version 3 what proportion of failure inducing changes are relevant to refactorings by using a refactoring reconstruction analysis and a change impact analysis in tandem we investigate the relationship between the types and locations of refactoring edits identified by reffinder and the affecting changes and affected tests identified by the faulttracer change impact analysis the results on three open source projects jmeter xmlsecurity and ant show that only 22 of refactored methods and fields are tested by existing regression tests while refactorings only constitutes 8 of atomic changes 38 of affected tests are relevant to refactorings furthermore refactorings are involved in almost half of the failed test cases these results call for new automated regression test augmentation and selection techniques for validating refactoring edits 2012 ieee empirical study refactoring regression testing software evolution empirically examining the parallelizability of open source software system an empirical study is presented that examines the potential to automatically parallelism using refactoring tools and or compilers 11 open source software static analysis methods are applied to each system to determine the number of for loops and free loops i e loops that can be parallized for each non free loop the various inhibitors to parallelization are determined and counted the results show that function calls within for loops represent the vast majority of inhibitors and thus pose the greatest roadblock to adapt and re engineer systems to better utilize parallelization this is somewhat contradictory to the literature which is focused primarily on the removal of data dependencies within loops additionally the historical data of inhibitor counts for the set of systems is presented over a ten year period the data shows few of the systems examined are increasing the potential to parallelizable loops over time 2012 ieee data dependency emprical study function calls parallelization inhibitors reegnineering high dimensional full inverse characterization of fractal volumes the present paper describes a methodology for the inverse identification of the complete set of parameters associated with the weirstrass mandelbrot w m function that can describe any fractal scalar field distribution of measured data defined within a volume our effort is motivated by the need to be able to describe a scalar field quantity distribution in a volume in order to be able to represent analytically various non homogeneous material properties distributions for engineering and science applications our method involves utilizing a refactoring of the w m function that permits defining the characterization problem as a high dimensional singular value decomposition problem for the determination of the so called phases of the function coupled with this process is a second level exhaustive search that enables the determination of the density of the frequencies involved in defining the trigonometric functions involved in the definition of the w m function numerical applications of the proposed method on both synthetic and actual volume data validate the efficiency and the accuracy of the proposed approach this approach constitutes a radical departure from the traditional fractal dimension characterization studies and opens the road for a very large number of applications and generalizes the approach developed by the authors for fractal surfaces to that of fractal volumes copyright 2012 by asme search based detection of high level model changes software models are iteratively refined restructured and evolved the detection and analysis of changes applied between two versions of a model are one of the most important tasks during evolution and maintenance activities in this paper we propose an approach to detect high level model changes in terms of refactorings our approach takes as input an exhaustive list of possible refactorings the initial model and revised model and generates as output a list of detected changes representing a sequence of refactorings a solution is defined as a combination of refactorings that should maximize as much as possible the similarity between the expected revised model and the generated model after applying the refactoring sequence on the initial model due to the huge number of possible refactoring combinations a heuristic method is used to explore the space of possible solutions to this end we used and adapted genetic algorithm as global heuristic search the validation results on various versions of real world models taken from an open source project confirm the effectiveness of our approach 2012 ieee model evolution refactoring detection search based model driven software engineering entropy based bug prediction using support vector regression predicting software defects is one of the key areas of research in software engineering researchers have devised and implemented a plethora of defect bug prediction approaches namely code churn past bugs refactoring number of authors file size and age etc by measuring the performance in terms of accuracy and complexity different mathematical models have also been developed in the literature to monitor the bug occurrence and fixing process these existing mathematical models named software reliability growth models are either calendar time or testing effort dependent the occurrence of bugs in the software is mainly due to the continuous changes in the software code the continuous changes in the software code make the code complex the complexity of the code changes have already been quantified in terms of entropy as follows in hassan 9 in the available literature few authors have proposed entropy based bug prediction using conventional simple linear regression slr method in this paper we have proposed an entropy based bug prediction approach using support vector regression svr we have compared the results of proposed models with the existing one in the literature and have found that the proposed models are good bug predictor as they have shown the significant improvement in their performance 2012 ieee bug prediction complexity of code change entropy support vector regression bad smells and refactoring methods for gui test scripts testing the gui graphical user interface of a software application is typically accomplished by developing a gui test script composed of sequences of events and assertions a gui test script is in a sense similar to the source code of a program since events and assertions are like source code statements which are executed line by line therefore like source code a gui test script may have bad smells and refactoring is an effective technique that can eradicate bad smells making the script better and easier to maintain this paper studies the bad smells a gui test script may have and the refactoring methods that can be applied to remove the bad smells a total of 11 bad smells are identified and 16 refactoring methods are proposed the refactoring methods have been implemented in a gui testing tool called gtt to support the automatic refactoring of gui test scripts 2012 ieee gui testing refactoring smell test script automated refactoring to the strategy design pattern context the automated identification of code fragments characterized by common design flaws or code smells that can be handled through refactoring fosters refactoring activities especially in large code bases where multiple developers are engaged without a detailed view on the whole system automated refactoring to design patterns enables significant contributions to design quality even from developers with little experience on the use of the required patterns objective this work targets the automated identification of refactoring opportunities to the strategy design pattern and the elimination through polymorphism of respective code smells that are related to extensive use of complex conditional statements method an algorithm is introduced for the automated identification of refactoring opportunities to the strategy design pattern suggested refactorings comprise conditional statements that are characterized by analogies to the strategy design pattern in terms of the purpose and selection mode of strategies moreover this work specifies the procedure for refactoring to strategy the identified conditional statements for special cases of these statements a technique is proposed for total replacement of conditional logic with method calls of appropriate concrete strategy instances the identification algorithm and the refactoring procedure are implemented and integrated in the jdeodorant eclipse plug in the method is evaluated on a set of java projects in terms of quality of the suggested refactorings and run time efficiency the relevance of the identified refactoring opportunities is verified by expert software engineers results the identification algorithm recalled from the projects used during evaluation many of the refactoring candidates that were identified by the expert software engineers its execution time on projects of varying size confirmed the run time efficiency of this method conclusion the proposed method for automated refactoring to strategy contributes to simplification of conditional statements moreover it enhances system extensibility through the strategy design pattern 2012 elsevier b v all rights reserved design patterns polymorphism refactoring strategy pattern total replacement of conditional logic identifying improvement potential in evolving product line infrastructures 3 case studies successful software products evolve continuously to meet the changing stakeholder requirements for software product lines an additional challenge is that variabilities characteristics that vary among products change as well over time that challenge must be carefully tackled during the evolution of the product line infrastructure this is a significant problem for many software development organizations as practical guidelines on how to evolve core assets and especially source code are missing this paper investigates how to achieve good enough variability management during the evolution of variation in software design and implementation assets as a first contribution we present a customizable goal based approach which helps to identify improvement potential in existing core assets to ease evolution to find concrete ways to improve the product line infrastructure we list the typical symptoms of variability code smells and show how to refine them to root causes questions and finally to metrics that can be extracted from large code bases as a second main contribution we show how this method was applied to evaluate the reuse quality of three industrial embedded systems these systems are implemented in c or c and use conditional compilation as the main variability mechanism we also introduce the analysis and refactoring tool set that was used in the case studies and discuss the lessons learnt copyright 2012 acm goal based product line measurement industrial case study product line code evolution pulse e variability code smells identification and application of extract class refactorings in object oriented systems refactoring is recognized as an essential practice in the context of evolutionary and agile software development recognizing the importance of the practice modern ides provide some support for low level refactorings a notable exception in the list of supported refactorings is the extract class refactoring which is conceived to simplify large complex unwieldy and less cohesive classes in this work we describe a method and a tool implemented as an eclipse plugin designed to fulfill exactly this need our method involves three steps a recognition of extract class opportunities b ranking of the identified opportunities in terms of the improvement each one is anticipated to bring about to the system design and c fully automated application of the refactoring chosen by the developer the first step relies on an agglomerative clustering algorithm which identifies cohesive sets of class members within the system classes the second step relies on the entity placement metric as a measure of design quality through a set of experiments we have shown that the tool is able to identify and extract new classes that developers recognize as coherent concepts and improve the design quality of the underlying system 2011 elsevier inc all rights reserved clustering object oriented programming refactoring software reengineering constructing models for predicting extract subclass refactoring opportunities using object oriented quality metrics context refactoring is a maintenance task that refers to the process of restructuring software source code to enhance its quality without affecting its external behavior inspecting and analyzing the source code of the system under consideration to identify the classes in need of extract subclass refactoring esr is a time consuming and costly process objective this paper explores the abilities of several quality metrics considered individually and in combination to predict the classes in need of esr method for a given a class this paper empirically investigates using univariate logistic regression analysis the abilities of 25 existing size cohesion and coupling metrics to predict whether the class is in need of restructuring by extracting a subclass from it in addition models of combined metrics based on multivariate logistic regression analysis were constructed and validated to predict the classes in need of esr and the best model is justifiably recommended we explored the statistical relations between the values of the selected metrics and the decisions of the developers of six open source java systems with respect to whether the classes require esr results the results indicate that there was a strong statistical relation between some of the quality metrics and the decision of whether esr activity was required from a statistical point of view the recommended model of metrics has practical thresholds that lead to an outstanding classification of the classes into those that require esr and those that do not conclusion the proposed model can be applied to automatically predict the classes in need of esr and present them as suggestions to developers working to enhance the system during the maintenance phase in addition the model is capable of ranking the classes of the system under consideration according to their degree of need of esr 2012 elsevier b v all rights reserved class cohesion class coupling class quality extract subclass refactoring logistic regression analysis object oriented design improving software maintenance size metrics a case study automated report generation system for particle monitoring in hard disk drive industry a software maintenance size can be used to predict maintenance effort or maintenance time however the traditional maintenance size metric only relies on line of source code loc which hardly is suitable for object oriented software this research proposed four new maintenance size metrics based on number of classes number of methods average number of methods per class and weighted methods per class an automated report generation system in hdd industry args pms was used as a case study to measure the performance of each proposed metric we found that for enhanced software maintenance tasks maintenance size based on an average number of methods per class ms mc gave the best performance in predicting maintenance time for a refactoring maintenance task maintenance size based on line of code ms loc weighted methods per class ms wmc and average methods per class ms mc were the best better and good estimators for predicting maintenance time respectively on average the maintenance size based on weighted methods per class gave the best performance 2012 ieee estimated time to maintenance maintenance size object oriented software maintenance metric proceedings c conference on computer science and software engineering c3s2e 12 the proceedings contain 19 papers the topics discussed include comparing and combining genetic and clustering algorithms for software component identification from object oriented code an adaptive computational model for emotion regulation strategies based on gross theory an effective ensemble method for hierarchical clustering evolving dungeon crawler levels with relative placement unifying and refactoring dmf to support concurrent jini and jms dms in gipsy using poetry as a teaching tool for the humanities to learn computer science concepts a complexity analysis of a jacobi method for lattice basis reduction quick mlcs a new algorithm for the multiple longest common subsequence problem a survey on formal methods in self adaptive systems incorporating shape into spatially aware adaptive object segmentation algorithm knowledge representation for self adaptive behavior and fleshing out gestures augmenting 3d interaction crat a refactoring support tool for form template method refactoring is important for efficient software maintenance however manual operations for refactoring are complicated and human related errors easily occur tool support can help users to apply such a complicated refactoring this paper proposes a refactoring support tool with form template method pattern the developed tool automatically identifies method pairs that can be refactored with form template method and suggests information that is required for form template method application it also has a function that metrics based filtering for detected method pairs the function helps users to select method pairs that should be refactored 2012 ieee form template method program dependence graph refactoring software maintenance proceedings of the 5th workshop on refactoring tools wrt 12 the proceedings contain 12 papers the topics discussed include what kind of and how clones are refactored a case study of three oss projects integration of smells and refactorings within the eclipse modeling framework an approach and tool for synchronous refactoring of uml diagrams and models using model to model transformations computation of refactoring plans from refactoring strategies using htn planning let s make refactoring tools user extensible scripting a refactoring with rascal and eclipse identifying extract method refactoring candidates automatically a language independent parallel refactoring framework refactoring tools for dynamic languages custom declarative refactoring in netbeans and refactoring development simplified proceedings of the 5th workshop on refactoring tools wrt 12 the proceedings contain 12 papers the topics discussed include what kind of and how clones are refactored a case study of three oss projects integration of smells and refactorings within the eclipse modeling framework an approach and tool for synchronous refactoring of uml diagrams and models using model to model transformations computation of refactoring plans from refactoring strategies using htn planning let s make refactoring tools user extensible scripting a refactoring with rascal and eclipse identifying extract method refactoring candidates automatically a language independent parallel refactoring framework refactoring tools for dynamic languages custom declarative refactoring in netbeans and refactoring development simplified identifying extract method refactoring candidates automatically refactoring becomes an essential activity in software development process especially for large and long life projects extract method is one of the most frequently used refactorings to address code smells such as long and incohesive methods and duplicated code automated means of identifying opportunities for refactoring can make the software development process faster and more efficient in this paper an abstraction for methods viz data and structure dependency dsd graph and an algorithm viz longest edge removal algorithm to find extract method refactoring candidates is proposed 2012 acm automatic refactoring candidate identification data and structure dependency graph extract method refactoring longest edge removal algorithm refactoring what kind of and how clones are refactored a case study of three oss projects although code clone i e a code fragment that has similar or identical fragments is regarded as one of the most typical bad smells tools for identification of clone refactoring i e merge code clones into a single method are not commonly used to promote the development of more widely used tools for clone refactoring we present an investigation of actual clone refactorings performed in the developments of three open source software oss projects from the results we confirmed that clone refactorings are mostly archived by two refactoring patterns and token sequences of refactored code clones are suggested to have a difference of 50 2012 acm code clone levenshtein distance refactoring fifth workshop on refactoring tools wrt 2012 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of specific transformations that need to be performed tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial program analysis and applying the transformations may affect many locations throughout a program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in modern day ides this workshop is a continuation of a series of previous workshops ecoop 2007 oopsla 2008 and 2009 icse 2011 see http refactoring info wrt where researchers and developers of refactoring tools can meet and discuss recent ideas and work and view tool demonstrations copyright 2012 acm program analysis program manipulation refactoring transformation mining object oriented design models for detecting identical design structures the object oriented design is the most popular design methodology of the last twenty five years several design patterns and principles are defined to improve the design quality of object oriented software systems in addition designers can use unique design motifs which are particular for the specific application domain another common habit is cloning and modifying some parts of the software while creating new modules therefore object oriented programs can include many identical design structures this work proposes a sub graph mining based approach to detect identical design structures in object oriented systems by identifying and analyzing these structures we can obtain useful information about the design such as commonly used design patterns most frequent design defects domain specific patterns and design clones which may help developers to improve their knowledge about the software architecture furthermore problematic parts of frequent identical design structures are the appropriate refactoring opportunities because they affect multiple areas of the architecture experiments with several open source projects show that we can successfully find many identical design structures in each project we observe that usually most of the identical structures are an implementation of common design patterns however we also detect various anti patterns domain specific patterns and design level clones 2012 ieee clones graph mining identical design structures pattern extraction software design models software motifs 2012 6th international workshop on software clones iwsc 2012 proceedings the proceedings contain 24 papers the topics discussed include an accurate estimation of the levenshtein distance using metric trees and manhattan distance a novel approach based on formal methods for clone detection claims and beliefs about code clones do we agree as a community a survey clone detection using rolling hashing suffix trees and dagification a case study dispersion of changes in cloned and non cloned code java bytecode clone detection via relaxation on code fingerprint and semantic web reasoning mining object oriented design models for detecting identical design structures safe clone based refactoring through stereotype identification and iso generation a case study on applying clone technology to an industrial application framework industrial application of clone change management system a common conceptual model for clone detection results and filtering clones for individual user based on machine learning analysis using dynamic analysis to discover polynomial and array invariants dynamic invariant analysis identifies likely properties over variables from observed program traces these properties can aid programmers in refactoring documenting and debugging tasks by making dynamic patterns visible statically two useful forms of invariants involve relations among polynomials over program variables and relations among array variables current dynamic analysis methods support such invariants in only very limited forms we combine mathematical techniques that have not previously been applied to this problem namely equation solving polyhedra construction and smt solving to bring new capabilities to dynamic invariant detection using these methods we show how to find equalities and inequalities among nonlinear polynomials over program variables and linear relations among array variables of multiple dimensions preliminary experiments on 24 mathematical algorithms and an implementation of aes encryption provide evidence that the approach is effective at finding these invariants 2012 ieee array invariants dynamic analysis invariant generation nonlinear invariants program analysis safe clone based refactoring through stereotype identification and iso generation most advanced existing tools for clone based refactoring propose a limited number of predefined clone removal transformations that can be applied automatically typically under user control this fixed set of refactorings usually guarantee that semantics is preserved but is inherently limited to generally applicable transformations extract method pull up method etc this tool design rules out many potential domain specific or application specific clone removals such cases are ordinarily recognized by humans as stereotypes derived from a higher level concept and manually replaced with an appropriate abstraction thus in current tools generality is sacrificed for the safety of the transformation this paper proposes an alternative approach in which the spectrum of refactoring techniques is open including manual interventions while keeping strong safety guarantees based on the notion of iso generation our method can operate on multiple languages and has been prototyped on a subset of a real world legacy asset containing c and cobol programs with promising results 2012 ieee clones maintainability refactoring safety use disuse and misuse of automated refactorings though refactoring tools have been available for more than a decade research has shown that programmers underutilize such tools however little is known about why programmers do not take advantage of these tools we have conducted a field study on programmers in their natural settings working on their code as a result we collected a set of interaction data from about 1268 hours of programming using our minimally intrusive data collectors our quantitative data show that programmers prefer lightweight methods of invoking refactorings usually perform small changes using the refactoring tool proceed with an automated refactoring even when it may change the behavior of the program and rarely preview the automated refactorings we also interviewed nine of our participants to provide deeper insight about the patterns that we observed in the behavioral data we found that programmers use predictable automated refactorings even if they have rare bugs or change the behavior of the program this paper reports some of the factors that affect the use of automated refactorings such as invocation method awareness naming trust and predictability and the major mismatches between programmers expectations and automated refactorings the results of this work contribute to producing more effective tools for refactoring complex software 2012 ieee human computer interaction human factors programming environments software engineering software maintenance user interfaces using structural and semantic information to support software refactoring in the software life cycle the internal structure of the system undergoes continuous modifications these changes push away the source code from its original design often reducing its quality in such cases refactoring techniques can be applied to improve the design quality of the system approaches existing in literature mainly exploit structural relationships present in the source code e g method calls to support the software engineer in identifying refactoring solutions however also semantic information is embedded in the source code by the developers e g the terms used in the comments this research investigates about the usefulness of combining structural and semantic information to support software refactoring 2012 ieee refactoring semantic information testing cardinality estimation models in sql server reliable query optimization greatly depends on accurate cardinality estimation ce which is inherently inexact as it relies on statistical information in commercial database systems cardinality estimation models are sophisticated components that over years of development can become very complex the code that implements cardinality estimation models like most complex software systems that handle a large space of possible inputs and conditions can deviate from its original architecture and design points over time hence it is often necessary to refactor and redesign the entire system to accommodate new inputs and conditions and also to reflect existing ones in a more intentional way in this paper we describe such an exercise the replacement and validation of a new cardinality estimation model in microsoft sql server we describe the motivation behind this change and provide a high level sketch of the empirical methods used to ensure that the new cardinality estimation model satisfies its goals while minimizing the potential risk of plan regressions for existing customers copyright 2012 acm cardinality estimation experimental methodology query optimization software quality systematic abstraction of abstract machines we describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well established abstract machines for higher order and imperative programming languages to demonstrate the technique and support our claim we transform the cek machine of felleisen and friedman proc of the 14th acm sigact sigplan symp prin program langs 1987 pp 314 325 a lazy variant of krivine s machine higher order symb comput vol 20 2007 pp 199 207 and the stack inspecting cm machine of clements and felleisen acm trans program lang syst vol 26 2004 pp 1029 1052 into abstract interpretations of themselves the resulting analyses bound temporal ordering of program events predict return flow and stack inspection behavior and approximate the flow and evaluation of by need parameters for all of these machines we find that a series of well known concrete machine refactorings plus a technique of store allocated continuations leads to machines that abstract into static analyses simply by bounding their stores these machines are parameterized by allocation functions that tune performance and precision and substantially expand the space of analyses that this framework can represent we demonstrate that the technique scales up uniformly to allow static analysis of realistic language features including tail calls conditionals mutation exceptions first class continuations and even garbage collection in order to close the gap between formalism and implementation we provide translations of the mathematics as running haskell code for the initial development of our method copyright cambridge university press 2012 reducing the class coupling of legacy code by a metrics based relocation of class members with the rapid growth of the complexity of software systems the problem of integrating and maintaining legacy software is more relevant than ever to overcome this problem many methods for refactoring legacy code have already been proposed such as renaming classes or extracting interfaces to perform a real modularization methods have to be moved between classes however moving a single method is often not possible due to code dependencies in this article we present an approach to modularize legacy software by moving multiple related class members it is shown how to identify groups of class members with similar concerns we present two different code patterns that the related members and their dependent classes must match to allow a relocation of the related members we also demonstrate how our pattern based approach for automated modularization of legacy software can be applied to two open source projects 2012 springer verlag class decoupling code metrics legacy software pattern based code refactoring aspect mining using model based clustering legacy systems contain critical and complex business code that has been in use for a long time this code is difficult to understand maintain and evolve in large part due to crosscutting concerns software system features such as persistence logging and error handling whose implementation is spread across multiple modules aspect oriented techniques separate crosscutting concerns from the base code using separate modules called aspects and thus simplify the legacy code aspect mining techniques identify aspect candidates so that the legacy code can then be refactored into aspects this study shows that model based clustering using a carefully selected vector space of features can be more effective than extant aspect mining methods based on heuristic methods as such hierarchical or partitional clustering three model based algorithms were experimentally compared against existing heuristic methods such as k means clustering and agglomerative hierarchical clustering using six different vector space models model based algorithms performed better in not spreading the methods of the concerns across the multiple clusters and were significantly better at partitioning the data such that given an ordered list of clusters fewer clusters and methods were needed to be analyzed to find all the concerns in addition model based algorithms automatically determined the optimal number of clusters a great advantage over the heuristic based algorithms lastly the newly defined vector space models performed better relative to aspect mining than the previously defined vector space models 2012 ieee aspect mining aspect oriented programming crosscutting concerns fan in metric heuristic based clustering model based clustering software metrics refactoring access control policies for performance improvement in order to facilitate managing authorization access control architectures are designed to separate the business logic from an access control policy to determine whether a user can access which resources a request is formulated from a component called a policy enforcement point pep located in application code given a request a policy decision point pdp evaluates the request against an access control policy and returns its access decision i e permit or deny to the pep with the growth of sensitive information for protection in an application an access control policy consists of a larger number of rules which often cause a performance bottleneck to address this issue we propose to refactor access control policies for performance improvement by splitting a policy handled by a single pdp into its corresponding multiple policies with a smaller number of rules handled by multiple pdps we define seven attribute set based splitting criteria to facilitate splitting a policy we have conducted an evaluation on three subjects of reallife java systems each of which interacts with access control policies our evaluation results show that 1 our approach preserves the initial architectural model in terms of interaction between the business logic and its corresponding rules in a policy and 2 our approach enables to substantially reduce request evaluation time for most splitting criteria copyright 2012 acm access control extensible access control markup language performance policy decision point policy enforcement point refactoring identifying tailoring and suggesting form template method refactoring opportunities with program dependence graph many research efforts have been performed on removing code clones especially it is highly expected that clone removal techniques by applying form template method have high applicability because they can be applied to code clones that have some gaps consequently some researchers have proposed techniques to support refactoring with form template method however previous research efforts still have some issues in this paper we propose a new technique with program dependence graph to resolve these issues by using program dependence graph we can handle trivial differences that are unrelated to behavior of a program consequently the proposed method can suggest more appropriate removal candidates than previously proposed techniques 2012 ieee code clones form template method program dependence graph refactoring software maintenance automated refactoring using design differencing software systems that undergo repeated addition of functionality commonly suffer a loss of quality in their underlying designs termed design erosion this leads to the maintenance of a system becoming increasingly difficult and time consuming during its lifetime refactoring can reduce the effects of design erosion but this process requires significant effort on the part of the maintenance programmer research into automated refactoring has had some success in reducing the effort involved however source code refactoring uses refactoring steps that are too small to effect major design changes design level refactoring is also possible but these approaches operate on design models and do little to help in the subsequent refactoring of the source code in this paper we present a novel refactoring approach that refactors a program based both on its desired design and on its source code the maintenance programmer first creates a desired design a uml class model for the software based on the current software design and their understanding of how it may be required to evolve then the source code is refactored using the desired design as a target this resulting source code has the same behavior as the original but its design more closely correlates to the desired design we conducted an investigation using several open source java applications to determine how precisely it is possible to refactor program source code to a desired design our findings were that the original program could be refactored to the desired design with an accuracy of over 90 hence demonstrating the viability of automated refactoring using design differencing 2012 ieee automated design improvement design differencing refactoring tool search based refactoring proceedings 2012 16th european conference on software maintenance and reengineering csmr 2012 the proceedings contain 69 papers the topics discussed include a multi objective technique to prioritize test cases based on latent semantic indexing identifying tailoring and suggesting form template method refactoring opportunities with program dependence graph understanding structural complexity evolution a quantitative analysis anomalies in rule adapted workflows a taxonomy and solutions for vbpmn on the comparison of user space and kernel space traces in identification of software anomalies a market based bug allocation mechanism using predictive bug lifetimes industrial comparability of student artifacts in traceability recovery research an exploratory survey a gpu based architecture for parallel image aware version control uncovering causal relationships between software metrics and bugs archimetrix improved software architecture recovery in the presence of design deficiencies and on the relevance of code anomalies for identifying architecture degradation symptoms semantic technologies and e learning towards an entity centric approach for learning management systems in the past the application of semantic technologies to educational settings attracted a lot of attention in particular regarding those approaches and software tools able to enrich categorize and retrieve learning objects in this paper we present a different perspective specifically the evolution of a traditionally engineered learning platform into a semantic enabled application the semantic enrichment addresses two issues a the unique identification of entities inside the contents and b adding new features to the platform without refactoring it through the usage of semantic representation of information we believe that these two modifications are missing elements for semantic learning and in order to apply these changes we integrated our virtual communities platform with the entity centric tools developed in the okkam eu funded project okkam tools provide a solution to uniquely identifying entities inside data and contents specifically using the entity name system ens which supplies a persistent identifier called okkamid to any entity included in the dataset and advanced entity matching methods for detecting the occurrence of the same entity in different contexts this allows a deeper connection between entities information available inside content inside the platform and outside the platform once the entity in the lms has been profiled it is possible to connect any content where the different occurrences of the same entity have been used and also to connect any other content outside the learning platform where that entity has been identified for example web pages or social networks furthermore we extended a domain ontology sioc for the conceptual representation needs of the application and created an rdf graph mapped onto the database in order to add new functionalities to our virtual community platform taking advantage of the inference processes available through a reasoner and substituting some parts of the business logic of the application metrics and antipatterns for software quality evaluation in the context of software evolution many activities are involved and are very useful like being able to evaluate the design quality of an evolving system both to locate the parts that need particular refactoring or reengineering efforts and to evaluate parts that are well designed this paper aims to give support hints for the evaluation of the code and design quality of a system and in particular we suggest to use metrics computation and antipatterns detection together we propose metrics computation based on particular kinds of micro structures and the detection of structural and object oriented antipatterns with the aim of identifying areas of design improvements we can evaluate the quality of a system according to different issues for example by understanding its global complexity analyzing the cohesion and coupling of system modules and locating the most critical and complex components that need particular refactoring or maintenance 2011 ieee antipatterns detection maintainability metrics computation software quality assurance a new design defects classification marrying detection and correction previous work classify design defects based on symptoms long methods large classes long parameter lists etc and treat separately detection and correction steps this paper introduces a new classification of defects using correction possibilities thus correcting different code fragments appending to specific defect category need approximately the same refactoring operations to apply to this end we use genetic programming to generate new form of classification rules combining detection and correction steps we report the results of our validation using different open source systems our proposal achieved high precision and recall correction scores 2012 springer verlag berlin heidelberg design defects genetic programming refactoring search based software engineering software maintenance tracing your maintenance work a cross project validation of an automated classification dictionary for commit messages a commit message is a description of a change in a version control system vcs besides the actual description of the change it can also serve as an indicator for the purpose of the change e g a change to refactor code might be accompanied by a commit message in the form of refactored class xy to improve readability we would label the change in our example a perfective change according to maintenance literature this simplified example shows how it is possible to classify a change by its commit message however commit messages are unstructured textual data and efforts to automatically label changes into categories like perfective have only been applied to a small set of projects within the same company or the same community in this work we present a cross project evaluated and valid mapping of changes to the code base and their purpose that is usable without any customization on any open source project we provide further the eclipse plug in subcat which allows for a comfortable analysis of projects from within eclipse by using subcat we are able to automatically assess if a commit to the code was e g a bug fix or a refactoring this information is very useful for e g developer profiling or locating bad smells in modules 2012 springer verlag berlin heidelberg a data centric approach to synchronization concurrency related errors such as data races are frustratingly difficult to track down and eliminate in large object oriented programs traditional approaches to preventing data races rely on protecting instruction sequences with synchronization operations such control centric approaches are inherently brittle as the burden is on the programmer to ensure that all concurrently accessed memory locations are consistently protected data centric synchronization is an alternative approach that offloads some of the work on the language implementation data centric synchronization groups fields of objects into atomic sets to indicate that these fields must always be updated atomically each atomic set has associated units of work that is code fragments that preserve the consistency of that atomic set synchronization operations are added automatically by the compiler we present an extension to the java programming language that integrates annotations for data centric concurrency control the resulting language called aj relies on a type system that enables separate compilation and supports atomic sets that span multiple objects and that also supports full encapsulation for more efficient code generation we evaluate our proposal by refactoring classes from standard libraries as well as a number ofmultithreaded benchmarks to use atomic sets our results suggest that data centric synchronization is easy to use and enjoys low annotation overhead while successfully preventing data races moreover experiments on the specjbb benchmark suggest that acceptable performance can be achieved with a modest amount of tuning 2012 acm concurrent object oriented programming data races programming model serializability a methodology to assess the impact of design patterns on software quality context software quality is considered to be one of the most important concerns of software production teams additionally design patterns are documented solutions to common design problems that are expected to enhance software quality until now the results on the effect of design patterns on software quality are controversial aims this study aims to propose a methodology for comparing design patterns to alternative designs with an analytical method additionally the study illustrates the methodology by comparing three design patterns with two alternative solutions with respect to several quality attributes method the paper introduces a theoretical analytical methodology to compare sets of canonical solutions to design problems the study is theoretical in the sense that the solutions are disconnected from real systems even though they stem from concrete problems the study is analytical in the sense that the solutions are compared based on their possible numbers of classes and on equations representing the values of the various structural quality attributes in function of these numbers of classes the exploratory designs have been produced by studying the literature by investigating open source projects and by using design patterns in addition to that we have created a tool that helps practitioners in choosing the optimal design solution according to their special needs results the results of our research suggest that the decision of applying a design pattern is usually a trade off because patterns are not universally good or bad patterns typically improve certain aspects of software quality while they might weaken some other conclusions concluding the proposed methodology is applicable for comparing patterns and alternative designs and highlights existing threshold that when surpassed the design pattern is getting more or less beneficial than the alternative design more specifically the identification of such thresholds can become very useful for decision making during system design and refactoring 2011 elsevier b v all rights reserved design patterns object oriented metrics quality structural quality attributed graph transformation with inheritance efficient conflict detection and local confluence analysis using abstract critical pairs inheritance is an important and widely spread concept enabling the elegant expression of hierarchy in object oriented software programs or models it has been defined for graphs and graph transformations enhancing the applicability of this formal technique up to now for the analysis of transformations with inheritance a flattening construction has been used which yields all the well known results for graph transformation but results in a large number of graphs and rules that have to be analyzed in this paper we introduce a new category of typed attributed graphs with inheritance for the detection of conflicts between graph transformations on these graphs the notion of abstract critical pairs is defined this allows us to perform the analysis on polymorphic rules and transformations without the need for flattening which significantly increases the efficiency of the analysis and eases the interpretation of the analysis results the new main result is the local confluence theorem for typed attributed graph transformation with inheritance using abstract critical pairs all constructions and results are demonstrated on an example for the analysis of refactorings 2011 elsevier b v all rights reserved critical pair analysis inheritance m adhesive category with nacs typed attributed graph transformation using software quality attributes to classify refactoring to patterns refactoring to patterns allows software designers to safely move their designs towards specific design patterns by applying multiple low level refactorings there are many different refactoring to pattern techniques each with a particular purpose and a varying effect on software quality attributes thus far software designers do not have a clear means to choose refactoring to pattern techniques to improve certain quality attributes this paper takes the first step towards a classification of refactoring to pattern techniques based on their measurable effect on software quality attributes this classification helps software designers in selecting the appropriate refactoring to pattern techniques that will improve the quality of their design based on their design objectives it also enables them to predict the quality drift caused by using specific refactoring to pattern techniques 2012 academy publisher refactoring to patterns software metrics software quality a precise method method interaction based cohesion metric for object oriented classes the building of highly cohesive classes is an important objective in object oriented design class cohesion refers to the relatedness of the class members and it indicates one important aspect of the class design quality a meaningful class cohesion metric helps object oriented software developers detect class design weaknesses and refactor classes accordingly several class cohesion metrics have been proposed in the literature most of these metrics are applicable based on low level design information such as attribute references in methods some of these metrics capture class cohesion by counting the number of method pairs that share common attributes a few metrics measure cohesion more precisely by considering the degree of interaction through attribute references between each pair of methods however the formulas applied by these metrics to measure the degree of interaction cause the metrics to violate important mathematical properties thus undermining their construct validity and leading to misleading cohesion measurement in this paper we propose a formula that precisely measures the degree of interaction between each pair of methods and we use it as a basis to introduce a low level design class cohesion metric lscc we verify that the proposed formula does not cause the metric to violate important mathematical properties in addition we provide a mechanism to use this metric as a useful indicator for refactoring weakly cohesive classes thus showing its usefulness in improving class cohesion finally we empirically validate lscc using four open source software systems and eleven cohesion metrics we investigate the relationship between lscc other cohesion metrics and fault occurrences in classes our results show that lscc is one of three metrics that explains more accurately the presence of faults in classes lscc is the only one among the three metrics to comply with important mathematical properties and statistical analysis shows it captures a measurement dimension of its own this suggests that lscc is a better alternative when taking into account both theoretical and empirical results as a measure to guide the refactoring of classes from a more general standpoint the results suggest that class quality as measured in terms of fault occurrences can be more accurately explained by cohesion metrics that account for the degree of interaction between each pair of methods 2012 acm attribute class cohesion low level design method method method interaction object oriented software quality refactoring unsupervised restructuring of object oriented software systems using self organizing feature maps this paper addresses the problem of software restructuring a method often used during software maintenance in order to improve the structure and therefore the maintainability of a software system improper software structure is the main factor that negatively in uences the maintainability of the software system and thus improving it becomes a major requirement maintenance activities such as adding new functionalities or correcting previously undetected errors within the software system imply continuous restructuring of the code we aim at automatically identifying using an unsupervised approach the refactorings that would improve the internal structure of a software system for this purpose a self organizing feature map will be used we evaluate our approach on the open source case study jhotdraw and on a real software system providing a comparison with similar existing approaches and emphasizing this way the potential of our proposal 2012 issn 1349 4198 clustering refactoring self organizing map software engineering unsupervised learning refactoring techniques for aggressive object inlining in java applications object inlining oi is a known optimization in object oriented programming in which referenced objects of class b are inlined into their referencing objects of class a by making all fields and methods of class b part of class a the optimization saves all the new operations of b type objects from class a and at the same time replaces all indirect accesses from a to fields of b by direct accesses to the best of our knowledge in spite of the significant performance potential of the oi optimization reported performance measurements were relatively moderate this is because an aggressive oi optimization requires complex analysis and code transformations to overcome problems like multiple references to the inlinable object object references that escape their object scope etc to extract the full potential of oi we propose a two stage process the first stage includes automatic analysis of the source code that informs the user via comments in the ide about code transformations that are needed in order to enable or to maximize the potential of the oi optimization in the second stage the oi optimization is applied automatically on the source code as a code refactoring operation or preferably as part of the compilation process prior to javac run we show that this half automated technique helps to extract the full potential of oi the proposed oi refactoring process also determines the order of applying the inlinings of the objects and enables us to apply inlinings of objects created inside a method thus enabling us to reach better performance gain in this work we also include an evaluation of the oi optimization effects on multithreaded applications running on multicore machines the comments and the oi transformation were implemented in the eclipse jdt java development tools plugin the system was then applied on the specjbb2000 source code along with profiling data collected by the eclipse tptp plugin the proposed system achieved 46 improvement in performance 2011 springer science business media llc eclipse inlining java refactoring building an expert system to assist system refactorization the separation of concerns is an important issue in the building of maintenable systems aspect oriented programming aop is a software paradigm that allows the encapsulation of those concerns that crosscut a system and can not be modularized using current paradigms such as object oriented programming in this way aop increases the software modularization and reduces the impact when changes are made in the system in order to take advantage of the benefits of aop the legacy oo systems should be migrated to migrate object oriented systems to aspect oriented ones specific refactorings for aspects should be used this is a complex and tedious task for the developer because he she needs to know how the refactorings should be applied and under what context therefore it is desirable to have tools that help him her through the process in this article we present an expert software agent named refactoringrecommender that assists the developer during a refactorization of a system the agent uses a markovian algorithm with the goal of predicting the needed restructurings 2011 elsevier ltd all rights reserved aspect refactoring aspect oriented software development expert systems interface agents the impact of accounting for special methods in the measurement of object oriented class cohesion on refactoring and fault prediction activities class cohesion is a key attribute that is used to assess the design quality of a class and it refers to the extent to which the attributes and methods of the class are related typically classes contain special types of methods such as constructors destructors and access methods each of these special methods has its own characteristics which can artificially affect the class cohesion measurement several metrics have been proposed in the literature to indicate class cohesion during high or low level design phases the impact of accounting for special methods in cohesion measurement has not been addressed for most of these metrics this paper empirically explores the impact of including or excluding special methods on cohesion measurements that were performed using 20 existing class cohesion metrics the empirical study applies the metrics that were considered to five open source systems under four different scenarios including 1 considering all special methods 2 ignoring only constructors 3 ignoring only access methods and 4 ignoring all special methods this study empirically explores the impact of including special methods in cohesion measurement for two applications of interest to software practitioners including refactoring and predicting faulty classes the results of the empirical studies show that the cohesion values for most of the metrics considered differ significantly across the four scenarios and that this difference significantly affects the refactoring decisions but does not significantly affect the abilities of the metrics to predict faulty classes 2011 elsevier inc all rights reserved class cohesion class quality cohesion metric fault prediction object oriented design refactoring special methods evaluating the extended refactoring guidelines refactoring is a process that improves the internal structure of a program without changing its externally observable behavior on the contrary in many cases refactoring support for java outputs semantically non equivalent code after refactoring also the research on refactoring has mostly focused on restructuring a class its parent and child classes only however refactoring will not be complete without updating other components in the program that may be impacted because of this change in particular clients and test classes associated with the restructured classes may be affected by this change and hence must be updated accordingly in this work we have identified the exact nature of changes required in these effected components and the elements contained in them using this information we have developed extended refactoring guidelines that address semantic violations of program behavior during refactoring we also report our findings from an experiment performed to judge the usability and effectiveness of the extended guidelines for move method refactoring 2012 ieee maintenance postconditions preconditions refactoring unit testing an empirical study of refactoring in the context of fanin and fanout coupling the aim of refactoring is to reduce software complexity and hence simplify the maintenance process in this paper we explore the impact of refactorings on fanin and fanout coupling metrics through extraction of refactoring data from multiple releases of five java open source systems we first considered how a single refactoring modified these metric values what happened when refactorings had been applied to a single class in unison and finally what influence a set of refactorings had on the shape of fan in and fan out distributions results indicated that on average refactored classes tended to have larger fanin and fan out values when compared with non refactored classes where evidence of multiple different refactorings applied to the same class was found the net effect in terms of fanin and fan out coupling values was negligible 2011 ieee coupling refactoring software metric distribution proceedings of the 27th ieee international conference on software maintenance icsm 2011 the proceedings contain 75 papers the topics discussed include fault interaction and its repercussions a novel approach to regression test selection for j2ee applications automated change impact analysis for agent systems impactscale quantifying change impact to predict faults in large software systems identifying performance deviations in thread pools mining java class naming conventions generating natural language summaries for crosscutting source code concerns expanding identifiers to normalize source code vocabulary using tactic traceability information models to reduce the risk of architectural degradation during system maintenance on integrating orthogonal information retrieval methods to improve traceability link recovery method engineering based legacy to soa migration method identifying overly strong conditions in refactoring implementations and crossing the boundaries while analyzing heterogeneous component based software systems visualizing the refactoring of classes via clustering when developing object oriented classes it is difficult to determine how to best reallocate the members of large complex classes to create smaller more cohesive ones clustering techniques can provide guidance on how to solve this allocation problem however inappropriate use of clustering can result in a class structure that is less maintainable than the original the extc visualizer helps the programmer understand the class structure by visually emphasizing important features of the class s members and their interrelationships more importantly it helps users see how various clustering algorithms group the class s members these insights help a programmer choose appropriate techniques for refactoring large classes copyright 2011 australian computer society inc clustering graph maintainability refactoring software visualization refactoring of a beef cattle farm simulator software systems are continuing changing because of new functionality has to be incorporated or the exiting one has to be changed systems have to be well evolved otherwise the will not be easily changed aspect orientation provides mechanisms to evolve and maintain systems by encapsulating systems crosscutting concerns in aspects we have developed an object oriented grazedbased beef cattle simulator which has maintenance and evolution problems for this reason in order to take advantages of the aspect orientation we present in this work the migration of the simulator to the aspect orientation the crosscutting concerns identified in the object oriented system are presented and how these crosscutting concerns are transformed into aspect in the target aspect oriented system 2005 ieee aspect mining aspect oriented development aspect refactoring system evolution truerefactor an automated refactoring tool to improve legacy system and application comprehensibility manual refactoring is a complicated process requiring intimate knowledge of the software design and underlying intended behavior of a system this knowledge is not always available fully automated refactoring using a meta heuristic based search that is dependent on software quality metrics and code smells as a guide eliminates the need for the developer to be intimately connected to the software under modification computer applications in industry and engineering benefit significantly from new approaches to self correcting refactoring software truerefactor is an automated refactoring tool that significantly improves the comprehensibility of legacy systems the goal of truerefactor is to modify legacy object oriented systems in order to increase the understandability maintainability and reusability aspects of legacy software and to simultaneously generate new uml documentation in order to help developers understand the changes being made this paper presents the research behind the design as well as a technical overview of the implementation of truerefactor we summarize the research goals that truerefactor addresses and identify opportunities where it can be actively utilized computer science 2011 proceedings of the 34th australasian computer science conference acsc 2011 the proceedings contain 18 papers the topics discussed include building instance knowledge network for word sense disambiguation human action recognition using silhouette histogram performance improvement of vertical handoff algorithms for qos support over heterogeneous wireless networks resource provisioning based on leases preemption in intergrid jointly compatible pair linking for visual tracking with probabilistic priors web based visualizations supporting rehabilitation of heart failure patients by promoting behavioral change visualizing the refactoring of classes via clustering optimistic and efficient concurrency control for asynchronous collaborative systems a dynamic archive based niching particle swarm optimizer using a small population size optimized relative lempel ziv compression of genomes enhancing the believability of embodied conversational agents through environment self and interaction awareness and dynamic visualization of software state proceedings of the isca 26th international conference on computers and their applications cata 2011 the proceedings contain 25 papers the topics discussed include scheduling energy usage in a residential energy management system using the branch and bound technique learning the meaning of words as associations between invariant forms measuring component specification implementation concordance with semantic mutation testing a distributed cooperative search algorithm using multiple contexts and pruning knowledge discovery in us census data using attribute oriented induction with fuzzy concept hierarchy software engineering online and hybrid learning models at psu twitter reporter breaking news detection and visualization through the geo tagged twitter network virtual city a gaming tool for training and education active learning mashups for tablet classrooms discrete time model for pwm converters in discontinuous capacitor voltage mode and gui tools and generated code refactoring to reveal intent seke 2011 proceedings of the 23rd international conference on software engineering and knowledge engineering the proceedings contain 146 papers the topics discussed include visual specification of component based slow intelligence systems design of component based slow intelligence systems and application to social influence analysis slow intelligence system and network management a case study extending software quality models a sample in the domain of semantic technologies a technology of profiling inter procedural paths a software engineering approach to user driven control of the microgrid a comparative study of different strategies for predicting software quality criteria of human software evaluation feature selection approach a dual clustering approach to the extract class refactoring an empirical study of software metrics selection using support vector machine software defect prediction for high dimensional and class imbalanced data and specification and runtime verification of api constraints on interacting objects optimal refactoring policy for agile information systems maintenance a control theoretic approach many information systems development companies are facing the question on how to apply agile methods in information systems maintenance ism performing correction of software defects in ism inevitably degenerates program structure on the other hand agile methods provide refactoring to improve program structure without changing its behavior this paper builds an optimal control model to balance the tradeoff between defect correction and refactoring we answer three questions first is that optimal to perform parallel defect correction and refactoring second how to determine the iteration length for agile ism if team wants to include refactoring in the iteration third how long the iteration should be if team wants to improve program s structure to a certain level at the end of the iteration to our knowledge this paper is the pioneer in understanding agile ism policy analytically managerial implications of the results are also discussed in the paper 2011 by the ais icis administrative office all rights reserved agile maintenance defect correction optimal control refactoring identifying refactoring through formal model based on data flow graph identifying refactoring is an important step of bad smell removal process many developers have problem identifying refactoring e g novice developers are not sure which refactorings should be applied even skilled developers may need to spend a lot of time doing this manually identifying refactoring techniques can alleviate these problems for developers in our previous work we proposed refactoring filtering conditions rfc that identify candidate refactorings for removing long method bad smell these conditions analyze internal structure inside a method with data flow analysis our research improves these rfc based on more refined data flow analysis and presents its formal description this research also demonstrates an approach of using the improved rfc of three refactorings moreover we conducted an experiment to compare the efficiency of the results of our approach with that of our previous work and that of developer suggestion 2011 ieee bad smell maintainability refactoring software maintenance complete high dimensional inverse characterization of fractal surfaces the present paper describes a methodology for the inverse identification of the complete set of parameters associated with the weirstrass mandelbrot w m function that can describe any rough surface known by its profilometric or topographic data our effort is motivated by the need to determine the mechanical electrical and thermal properties of contact surfaces between deformable materials that conduct electricity and heat and require an analytical representation of the surfaces involved our method involves utilizing a refactoring of the w m function that permits defining the characterization problem as a high dimensional singular value decomposition problem for the determination of the so called phases of the function coupled with this process is a second level exhaustive search that enables the determination of the density of the frequencies involved in defining the trigonometric functions involved in the definition of the w m function our approach proves that this is the only additional parameter that needs to be determined for full characterization of the w m function as the rest can be selected arbitrarily numerical applications of the proposed method on both synthetic and actual elevation data validate the efficiency and the accuracy of the proposed approach this approach constitutes a radical departure from the traditional fractal dimension characterization studies and opens the road for a very large number of applications 2011 by asme automatic handling of global variables for multi threaded mpi programs conventional implementations of the mpi standard tend to associate one mpi process per processor which limits their support for modern multi core platforms an increasingly popular approach is to combine mpi with threads where mpi processes are light weight threads global variables in legacy mpi applications however present a challenge because they may be accessed by multiple mpi threads simultaneously thus transforming legacy mpi applications to become thread safe in such mpi execution environments requires proper handling of global variables in this paper we present three approaches to automatically eliminate global variables to ensure thread safety for an mpi program these approaches include a a compilerbased refactoring technique using a photran based tool as an example which automates the source to source transformation for programs written in fortran b a technique based on a global offset table got and c a technique based on thread local storage tls the second and third methods automatically detect global variables and privatize them for each thread at runtime we discuss the advantages and disadvantages of these approaches and compare their performance using both synthetic benchmarks such as the nas benchmarks and a real scientific application the flash code 2011 ieee common agile practices in software processes objective to investigate studies about software processes looking for practices which can be used to obtain agility in software processes method a systematic review including seven search engines was executed in feb 2010 to apply the defined criteria to select papers and extract information regarding working practices bringing agility to software processes results from 6696 retrieved papers 441 were selected to support the identification of 236 occurrences of 51 distinct practices associated with the concept of agility their descriptions were deeply analyzed and consolidated after discarding those which appeared in the technical literature in a small amount of papers 17 agile practices were identified conclusion although further studies are necessary to evaluate the efficacy of these 17 agile practices 12 of them have been more commonly approached in the software projects and could be primarily considered test driven development continuous integration pair programming planning game onsite customer collective code ownership small releases metaphor refactoring sustainable pace simple design and coding standards 2011 ieee agile methods agile practices agile software processes evidence based software engineering systematic review e quality a graph based object oriented software quality visualization tool recently with increasing maintenance costs studies on software quality are becoming increasingly important and widespread because high quality software means more easily maintainable software measurement plays a key role in quality improvement activities and metrics are the quantitative measurement of software design quality in this paper we introduce a graph based object oriented software quality visualization tool called e quality e quality automatically extracts quality metrics and class relations from java source code and visualizes them on a graph based interactive visual environment this visual environment effectively simplifies comprehension and refactoring of complex software systems our approach assists developers in understanding of software quality attributes by level categorization and intuitive visualization techniques experimental results show that the tool can be used to detect software design flaws and refactoring opportunities 2011 ieee design flaw detection design patterns eclipse object oriented metrics refactoring software maintenance software quality software visualization bridging light cone and nrqcd approaches asymptotic behavior of b inf c inf electromagnetic form factor this work aims at illustrating that for a class of leading twist hard exclusive reactions involving two heavy quarkonia the light cone approach when equipped with the strategy of refactorization of the light cone distribution amplitude of quarkonium can be employed to elegantly reproduce the corresponding predictions made in the nonrelativistic qcd nrqcd factorization approach order by order in perturbative expansion taking the electromagnetic form factor of the b c meson at large momentum transfer q 2 as a concrete example we compare the results obtained from both nrqcd based and light cone based calculations through the next to leading order nlo in α s while at the leading order lo in both velocity and 1 q 2 expansion and explicitly confirm their mutual agreement as a byproduct we apply our nlo result to explore certain features about the asymptotic behavior of the heavy light meson form factor we also address the major theoretical obstacles that prevent us from establishing an analogous equivalence between these two approaches for the double charmonium production process of phenomenological interest e e → j φ η c sissa 2011 asymptotic freedom nlo computations qcd design smell detection with similarity scoring and fingerprinting preliminary study design smells in software models reduce the software quality smells identification supports the refactoring which is a way to improve the quality of models and subsequently increasing software readability maintainability and extensibility we propose a preliminary study of using similarity scoring algorithm and fingerprinting algorithm for design smells detection in the future we plan to do extensive verification on several large projects integrate these methods to the smells detection framework and compare effectiveness with other approaches 2011 ieee algorithms anti patterns design smells fingerprinting refactoring similarity scoring a classification of refactoring methods based on software quality attributes refactoring is the process of improving the design of existing code by changing its internal structure without affecting its external behavior refactoring tends to improve software quality by improving design improving readability and reducing bugs there are many different refactoring methods each having a particular purpose and effect consequently the effect of refactoring methods on software quality attributes may vary moreover it is often unclear to software designers how to use refactoring methods to improve specific quality attributes in this paper we propose a classification of refactoring methods based on their measurable effect on software quality attributes this in turn helps software designers choose appropriate refactoring methods that will improve the quality of their designs based on the design objectives it also enables them to predict the quality drift caused by using particular refactoring methods 2011 king fahd university of petroleum and minerals refactoring classification software metrics software quality attributes software refactoring software refactoring at the class level using clustering techniques software becomes more and more complex as it adapts new requirements is enhanced or is modified thus the quality of the software decreases therefore there is a need to reduce the software s complexity and improve its quality refactoring reduces software complexity and improves quality by restructuring the code into a more readable form that improves its internal structure without changing its external functionality however it is a challenging task and requires effort from the software designer in this paper we propose a method for identifying ill structured software at the class level that provides heuristic refactoring advice to software designers in order to create balance between coupling and cohesion using pattern recognition techniques to identify the ill structured code we use three clustering techniques namely the single linkage algorithm slink the complete linkage algorithm clink and the weighted pair group method using arithmetic averages wpgma in addition to these clustering techniques we also use the adaptive k nearest neighbour a knn algorithm and compare its performance with the other clustering techniques the results show that software structuring at the class level using a knn is superior to slink clink and wpgma in terms of performance and computational complexity copyright 2011 australian computer society inc clustering code restructuring cohesion coupling software refactoring supporting design model refactoring for improving class responsibility assignment although a responsibility driven approach in object oriented analysis and design methodologies is promising the assignment of the identified responsibilities to classes simply class responsibility assignment cra is a crucial issue to achieve design of higher quality the grasp by larman is a guideline for cra and is being put into practice however since it is described in an informal way using a natural language its successful usage greatly relies on designers skills this paper proposes a technique to represent grasp formally and to automate appropriate cra based on them our computerized tool automatically detects inappropriate cra and suggests alternatives of appropriate cras to designers so that they can improve a cra based on the suggested alternatives we made preliminary experiments to show the usefulness of our tool 2011 springer verlag class responsibility assignment grasp object oriented design identification of extract method refactoring opportunities for the decomposition of methods the extraction of a code fragment into a separate method is one of the most widely performed refactoring activities since it allows the decomposition of large and complex methods and can be used in combination with other code transformations for fixing a variety of design problems despite the significance of extract method refactoring towards code quality improvement there is limited support for the identification of code fragments with distinct functionality that could be extracted into new methods the goal of our approach is to automatically identify extract method refactoring opportunities which are related with the complete computation of a given variable complete computation slice and the statements affecting the state of a given object object state slice moreover a set of rules regarding the preservation of existing dependences is proposed that exclude refactoring opportunities corresponding to slices whose extraction could possibly cause a change in program behavior the proposed approach has been evaluated regarding its ability to capture slices of code implementing a distinct functionality its ability to resolve existing design flaws its impact on the cohesion of the decomposed and extracted methods and its ability to preserve program behavior moreover precision and recall have been computed employing the refactoring opportunities found by independent evaluators in software that they developed as a golden set 2011 elsevier inc extract method refactoring module decomposition program slicing a pattern based refactoring approach for multi core system design until recently the most software development tools and techniques were concentrated on views from the sequential model of program execution software developers who only familiarize with the sequential model will face unusual challenges of software projects that require multi core or parallel programming in this paper we addresses the challenges that developers face as their projects requiring multi core or parallel programming by applying design patterns in general design patterns are usually regarded as the role of quality improver for improving software quality but they could be the role of design facilitator for facilitating design activities to address this issue we propose an approach for specifying the applicable contexts and refactoring steps of patterns systematically as well as automating the refactoring process for lightening the burden of developers we also extract a multi core pattern parallelwhile which is derived from the template class parallel_while of intel tbb library to introduce our approach furthermore we demonstrate our approach by a real world multi core embedded system pve parallel video encoder where command pipeline pattern is designed for the design enhancement and platform migration it aids developers identifying operations which could be parallel processing and revising a sequential design as an intel tbb parallel structure in addition our approach can promote the extensibility of parallel operations design pattern model transformation multi core embedded system pattern application towards a classification of logical dependencies origins a case study logical dependencies are implicit relationships established between software artifacts that have evolved together software engineering researchers have investigated this kind of dependency to assess fault proneness detect design issues infer code decay and predict likely changes in code despite the acknowledged relation between logical dependencies and software quality the nature of the logical dependencies is unknown in the literature most authors hypothesize about their origins but no empirical study has been conducted to investigate the real nature of these dependencies in this paper we investigated the origins of logical dependencies by means of a case study involving a java floss project we mined the project repository filtered out irrelevant data based on statistical analyses and performed a manual inspection of the logical dependencies to identify their origins using information from the revision comments code diffs and informal interviews held with the developers of the analyzed project preliminary results showed that logical dependencies involved files that changed together for a series of different reasons which ranged from changing software license to refactoring classes that belonged to the same semantic class 2011 acm case study change coupling empirical software engineering logical coupling logical dependencies mining software repositories software evolution software engineering techniques third ifip tc 2 central and east european conference cee set 2008 revised selected papers the proceedings contain 21 papers the topics discussed include automated generation of implementation from textual system requirements mining design patterns from existing projects using static and run time analysis transformational design of business processes for soa sma the smyle modeling approach open work of two hemisphere model transformation definition into uml class diagram in the context of mda htcpns based tool for web server clusters development refactoring the documentation of software product lines advanced data organization for java powered mobile devices developing applications with aspect oriented change realization exploratory comparison of expert and novice pair programmers state of the practice in software effort estimation a survey and literature review a framework for defect prediction in specific software project contexts and meeting organisational needs and quality assurance through balancing agile and formal usability testing results search based software engineering third international symposium ssbse 2011 proceedings the proceedings contain 20 papers the topics discussed include exploiting decomposability using recombination in genetic algorithms an exploratory discussion conducting and analyzing empirical studies in search based software engineering ten years of search based software engineering a bibliometric analysis on parameter tuning in search based software engineering a fuzzy approach to requirements prioritization multi level automated refactoring using design exploration comparing metaheuristic algorithms for error detection in java programs applications of model reuse when using estimation of distribution algorithms to test concurrent software cooperative co evolutionary optimization of software project staff assignments and job scheduling an ant colony optimization approach to the software release planning with dependent requirements and integration test of classes and aspects with a multi evolutionary and coupling based approach clone detection in repositories of business process models over time process model repositories tend to accumulate duplicate fragments also called clones as new process models are created or extended by copying and merging fragments from other models this phenomenon calls for methods to detect clones in process models so that these clones can be refactored as separate subprocesses in order to improve maintainability this paper presents an indexing structure to support the fast detection of clones in large process model repositories the proposed index is based on a novel combination of a method for process model decomposition specifically the refined process structure tree with established graph canonization and string matching techniques experiments show that the algorithm scales to repositories with hundreds of models the experimental results also show that a significant number of non trivial clones can be found in process model repositories taken from industrial practice 2011 springer verlag rank based refactoring decision support two studies refactoring can result in code with improved maintainability and is considered a preventive maintenance activity managers of large projects need ways to decide where to apply scarce resources when performing refactoring there is a lack of tools for supporting such decisions we introduce a rank based software measure driven refactoring decision support approach to assist managers the approach uses various static measures to develop a weighted rank ranking classes or packages that need refactoring we undertook two case studies to examine the effectiveness of the approach specifically we wanted to see if the decision support tool yielded results similar to those of human analysts managers and in less time so that it can be used to augment human decision making in the first study we found that our approach identified classes as needing refactoring that were also identified by humans in the second study a hierarchical approach was used to identify packages that had actually been refactored in 15 releases of the open source project tomcat we examined the overlap between the tool s findings and the actual refactoring activities the tool reached 100 86 7 recall on the package class level though these studies were limited in size and scope it appears that this approach is worthy of further examination 2011 springer verlag london limited decision support maintainability refactoring software engineering identifying refactoring opportunities in process model repositories context in order to ensure high quality of a process model repository refactoring operations can be applied to correct anti patterns such as overlap of process models inconsistent labeling of activities and overly complex models however if a process model collection is created and maintained by different people over a longer period of time manual detection of such refactoring opportunities becomes difficult simply due to the number of processes in the repository consequently there is a need for techniques to detect refactoring opportunities automatically objective this paper proposes a technique for automatically detecting refactoring opportunities method we developed the technique based on metrics that can be used to measure the consistency of activity labels as well as the extent to which processes overlap and the type of overlap that they have we evaluated it by applying it to two large process model repositories results the evaluation shows that the technique can be used to pinpoint the approximate location of three types of refactoring opportunities with high precision and recall and of one type of refactoring opportunity with high recall but low precision conclusion we conclude that the technique presented in this paper can be used in practice to automatically detect a number of anti patterns that can be corrected by refactoring 2011 elsevier b v all rights reserved business process model refactoring repository abstracting abstract machines a systematic approach to higher order program analysis predictive models are fundamental to engineering reliable software systems however designing conservative computable approximations for the behavior of programs static analyses remains a difficult and error prone process for modern high level programming languages what analysis designers need is a principled method for navigating the gap between semantics and analytic models analysis designers need a method that tames the interaction of complex languages features such as higher order functions recursion exceptions continuations objects and dynamic allocation we contribute a systematic approach to program analysis that yields novel and transparently sound static analyses our approach relies on existing derivational techniques to transform high level language semantics into low level deterministic state transition systems with potentially infinite state spaces we then perform a series of simple machine refactorings to obtain a sound computable approximation which takes the form of a non deterministic state transition systems with finite state spaces the approach scales up uniformly to enable program analysis of realistic language features including higher order functions tail calls conditionals side effects exceptions firstclass continuations and even garbage collection 2011 acm looking for patterns in code bad smells relations code smells are the named design anomalies that indicate to a need for refactoring due to their diverse and ambiguous nature their identification in code requires complex methods in the paper we formulate a hypothesis that some smells make associations that are repeatable and can be treated as patterns we present also early results of investigation of two large class related patterns 2011 ieee code smells patterns refactoring using software metrics to select refactoring for long method bad smell refactoring is a technique for improving software structure without changing its behavior which can be used to remove bad smells and increases software maintainability but only few approaches have been proposed to address the identification of appropriate refactorings specifically our research proposes a method to select refactoring based on software metrics which are defined in terms of data flow and control flow graphs the method consist of 4 steps 1 calculate metrics 2 find candidate refactoring by using refactoring filtering condition rfc 3 apply a suite of candidate refactorings and compute maintainability and 4 identify the refactoring that gives the highest maintainability we demonstrate out approach by giving an example of removing a long method bad smell in a customer class in a movie rental system our approach proves to be able to suggest an appropriate set of refactoring techniques such as extract method replace temp with query and decompose condition to solve the long method bad smell 2011 ieee bad smell long method refactoring identification software maintainability software metrics ecoop 2011 object oriented programming 25th european conference proceedings the proceedings contain 26 papers the topics discussed include a co relational model of data for large shared data banks an empirical study of object protocols in the wild the beauty and the beast separating design from algorithm using structure based recommendations to facilitate discoverability in apis mining evolution of object usage improving the tokenization of identifier names revisiting information hiding reflections on classical and nonclassical modularity worlds controlling the scope of side effects can we avoid high coupling expressiveness simplicity and users a refactoring constraint language and its application to eiffel types regions and effects for safe programming with object oriented parallel frameworks tunable static inference for generic universe types verifying multi object invariants with relationships and frequency estimation of virtual call targets for object oriented programs prioritizing design debt investment opportunities technical debt is the technical work developers owe a system typically caused by speeding up development e g before a software release approaches such as code smell detection have been developed to identify particular kinds of debt e g design debt up until now code smell detection has been used to help point to components that need to be freed from debt by refactoring to date a number of methods have been described for finding code smells in a system however typical debt properties such as the value of the debt and interest rate to be paid have not been well established this position paper proposes an approach to using cost benefit analysis to prioritize technical debt reduction work by ranking the value and interest of design debt caused by god classes the method is based on metric analysis and software repository mining and is demonstrated on a commercial software application at a mid size development company the results are promising the method helps to identify which refactoring activities should be performed first because they are likely to be cheap to make yet have significant effect and which refactorings should be postponed due to high cost and low payoff 2011 acm code smells design debt god class maintainability refactoring technical debt analyzing and forecasting near miss clones in evolving software an empirical study effort for development and maintenance of complex large software is believed to have dependency on the amount of duplicated code fragments code clones present in code bases for example clones need to be carefully and consistently maintained and or refactored for preventing accidental error propagation thus it is important to understand the proportion and evolution of clones in evolving software systems for cost estimation or the like this paper presents a study on the evolution of near miss clones at release level in medium to large open source software systems of different types operating systems database systems editors etc written in three different programming languages namely c c and java using a hybrid clone detector nicad we detected both exact and near miss clones at different levels of similarity applying statistical methods we investigated from different dimensions the evolution of both exact and near miss clones and also forecasted the amount of clones in future releases of the software systems our study offers significant insights into the existence and evolution of code clones and their relationships with programming language or paradigm and program size 2011 ieee grading code quality of programming assignments based on bad smells programming assignments pas are very important to many computer science courses traditionally the grading of a programming assignment is based mainly on the correctness of the code however from the view point of software engineering education such a grading does not encourage students to develop code that is easy to read and maintain thus the authors created a grading policy that considers not only the correctness but also the quality of the code expecting students to follow the most important discipline the source code should be written in a way that is readable and maintainable instead of using pure subjective code quality ratings bad smells are used to assess the code quality of pas when a pa is graded by the teaching assistant a list of bad smells is identified and given to the student so that the student can use refactoring methods to improve the code 2011 ieee jdeodorant identification and application of extract class refactorings evolutionary changes in object oriented systems can result in large complex classes known as god classes in this paper we present a tool developed as part of the jdeodorant eclipse plugin that can recognize opportunities for extracting cohesive classes from god classes and automatically apply the refactoring chosen by the developer 2011 authors clustering object oriented programming refactoring software reengineering identifying method friendships to remove the feature envy bad smell nier track we propose a novel approach to identify move method refactoring opportunities and remove the feature envy bad smell from source code the proposed approach analyzes both structural and conceptual relationships between methods and uses relational topic models to identify sets of methods that share several responsabilities i e friend methods the analysis of method friendships of a given method can be used to pinpoint the target class envied class where the method should be moved in the results of a preliminary empirical evaluation indicate that the proposed approach provides meaningful refactoring opportunities 2011 acm refactoring relational topic model source code quality fourth workshop on refactoring tools wrt 2011 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of transformations that need to be performed tool support for refactoring is essential because checking the preconditions of refactoring often requires nontrivial program analysis and applying transformations may affect many locations throughout a program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in today s ides this workshop is a continuation of a series of previous workshops ecoop 2007 oopsla 2008 and 2009 see http refactoring info wrt where researchers and developers of refactoring tools can meet and discuss recent ideas and work and view tool demonstrations 2011 acm program analysis program manipulation refactoring transformation non essential changes in version histories numerous techniques involve mining change data captured in software archives to assist engineering efforts for example to identify components that tend to evolve together we observed that important changes to software artifacts are sometimes accompanied by numerous non essential modifications such as local variable refactorings or textual differences induced as part of a rename refactoring we developed a tool supported technique for detecting non essential code differences in the revision histories of software systems we used our technique to investigate code changes in over 24 000 change sets gathered from the change histories of seven long lived open source systems we found that up to 15 5 of a system s method updates were due solely to non essential differences we also report on numerous observations on the distribution of non essential differences in change history and their potential impact on change based analyses 2011 acm differencing algorithms mining software repositories software change analysis a visualization method of program dependency graph for identifying extract method opportunity refactoring is important for efficient software maintenance however tools supports are highly required for refactoring because manual operations of refactoring are troublesome and error prone this paper proposes a technique that suggests extract method candidates automatically extract method refactoring is to create a new method from a code fragment in an existing method previous research efforts showed that the extract method refactoring is often performed prior to other refactorings so that it is important to support extract method refactoring previous studies have proposed methods that suggest extract method candidates based on linage or complexity however it is originally desirable to divide methods based on their functionalities this paper uses the strength of data connection between sentences in the source code we deem that strongly connected data expresses a single function this paper proposes a technique that suggests extract method candidates based on strongly connected data 2011 acm program dependency graph refactoring visualization a bottom up approach to understand functional programs one affective way to carry out a program comprehension process is by refactoring the source code in this paper we explore this approach in the functional programming paradigm on haskell programs specifically as result we have identified many correlations between the traditional procedural and object oriented program comprehension process and the so called understanding oriented refactorings in the functional programming context besides we have identified a catalog of refactorings used to improve program efficiency which applied in reverse order are valuable for program understanding purposes coupled to these refactorings there is a calculational process by means of which we obtain a full formal description of program functionality all together a bottom up program comprehension strategy in the functional setting is described 2011 acm formal methods program comprehension refactorings 4th workshop on refactoring tools wrt 2011 co located with icse 2011 proceedings the proceedings contain 8 papers the topics discussed include code motion for api migration fixing sql injection vulnerabilities in java a visualization method of program dependency graph for identifying extract method opportunity automated acceptance test refactoring a security aware refactoring tool for java programs a refactoring tool to extract gpu kernels understanding the longevity of code smells preliminary results of an explanatory survey impact of refactoring on quality code evaluation and code imp a tool for automated search based refactoring a security aware refactoring tool for java programs refactoring is a useful practice in developing and maintaining software since it improves the design of existing code without changing its external behavior therefore contemporary integrated development environments tend to include refactoring tools that support automatic transformations of source code unfortunately some of the popular refactoring transformations make existing code vulnerable although they improve its maintainability the existence of vulnerable code is still a serious issue for many software systems this paper describes a tool with support for a new class of refactoring concerning software security which is built as an eclipse plug in it helps programmers to easily know the adverse impact of code changes on security vulnerabilities in the application of refactoring and provides them with a chance to determine if they could accept or should cancel the applied refactoring consequently they feel safe to improve the maintainability of existing code without missing security vulnerabilities newly inserted into the code to evaluate the capability of this tool we made an experiment with it the experimental results show the usefulness of the tool and also reveal several remaining issues to be tackled 2011 acm access control information flow refactoring software restructuring extracting code clones for refactoring using combinations of clone metrics code clone detection tools may report a large number of code clones while software developers are interested in only a subset of code clones that are relevant to software development tasks such as refactoring our research group has supported many software developers with the code clone detection tool ccfinder and its gui front end gemini gemini shows clone sets i e a set of code clones identical or similar to each other with several clone metrics including their length and the number of code clones however it is not clear how to use those metrics to extract interesting code clones for developers in this paper we propose a method combining clone metrics to extract code clones for refactoring activity we have conducted an empirical study on a web application developed by a japanese software company the result indicates that combinations of simple clone metric is more effective to extract refactoring candidates in detected code clones than individual clone metric 2011 acm code clone industrial case study refactoring a visualization method of program dependency graph for identifying extract method opportunity copyright 2011 acm refactoring is important for efficient software maintenance however tools supports are highly required for refactoring because manual operations of refactoring are troublesome and error prone this paper proposes a technique that suggests extract method candidates automatically extract method refactoring is to create a new method from a code fragment in an existing method previous research efforts showed that the extract method refactoring is often performed prior to other refactorings so that it is important to support extract method refactoring previous studies have proposed methods that suggest extract method candidates based on linage or complexity however it is originally desirable to divide methods based on their functionalities this paper uses the strength of data connection between sentences in the source code we deem that strongly connected data expresses a single function this paper proposes a technique that suggests extract method candidates based on strongly connected data program dependency graph refactoring visualization wrt 2011 proceedings of the 4th workshop on refactoring tools co located with icse 2011 the proceedings contain 8 papers the topics discussed include code motion for api migration fixing sql injection vulnerabilities in java a visualization method of program dependency graph for identifying extract method opportunity automated acceptance test refactoring a security aware refactoring tool for java programs a refactoring tool to extract gpu kernels understanding the longevity of code smells preliminary results of an explanatory survey impact of refactoring on quality code evaluation and code imp a tool for automated search based refactoring a security aware refactoring tool for java programs copyright 2011 acm refactoring is a useful practice in developing and maintaining software since it improves the design of existing code without changing its external behavior therefore contemporary integrated development environments tend to include refactoring tools that support automatic transformations of source code unfortunately some of the popular refactoring transformations make existing code vulnerable although they improve its maintainability the existence of vulnerable code is still a serious issue for many software systems this paper describes a tool with support for a new class of refactoring concerning software security which is built as an eclipse plug in it helps programmers to easily know the adverse impact of code changes on security vulnerabilities in the application of refactoring and provides them with a chance to determine if they could accept or should cancel the applied refactoring consequently they feel safe to improve the maintainability of existing code without missing security vulnerabilities newly inserted into the code to evaluate the capability of this tool we made an experiment with it the experimental results show the usefulness of the tool and also reveal several remaining issues to be tackled access control information flow refactoring software restructuring software refactoring at the package level using clustering techniques enhancing modifying or adapting the software to new requirements increases the internal software complexity software with high level of internal complexity is difficult to maintain software refactoring reduces software complexity and hence decreases the maintenance effort however software refactoring becomes quite challenging task as the software evolves the authors use clustering as a pattern recognition technique to assist in software refactoring activities at the package level the approach presents a computer aided support for identifying ill structured packages and provides suggestions for software designer to balance between intra package cohesion and inter package coupling a comparative study is conducted applying three different clustering techniques on different software systems in addition the application of refactoring at the package level using an adaptive k nearest neighbour a knn algorithm is introduced the authors compared a knn technique with the other clustering techniques viz single linkage algorithm complete linkage algorithm and weighted pair group method using arithmetic averages the new technique shows competitive performance with lower computational complexity 2011 the institution of engineering and technology exploring implicit parallelism in class diagrams abstract as multicore processors are becoming more wide spread leveraging of parallelism is once again becoming an important concern during the software development process substantial refactoring is required to parallelize legacy sequential software in order to exploit the advantages offered by parallel processing in this study guidelines are offered to aid in parallelizing object oriented programs by analyzing their designs as represented in uml class diagrams we define often occurring patterns of class dependencies and demonstrate their characteristics in class diagrams by investigating their properties we present example instances exhibiting the usage of these patterns in class diagrams through analyzing the runtime aspects of these instances we have identified how they impact the parallelization of object oriented software taking these lessons into account when refactoring existing object oriented software can significantly reduce time and effort required we have evaluated our method by applying it to three popular design patterns and a real world case study 2011 elsevier inc all rights reserved class diagram analysis object oriented software refactoring parallel software design two dimensional fast response flood modeling desktop parallel computing and domain tracking emergency flood management is enhanced by using models that can estimate the timing and location of flooding typically flood routing and inundation prediction is accomplished by using one dimensional 1d models these have been the models of choice because they are computationally simple and quick however these models do not adequately represent the complex physical processes present for shallow flows located in the floodplain or in urban areas two dimensional 2d models developed on the basis of the full hydrodynamic equations can be used to represent the complex flow phenomena that exist in the floodplain and are therefore recommended by the national research council for increased use in flood analysis studies the major limitation of these models is the increased computational cost two dimensional flood models are prime candidates for parallel computing but traditional methods equipment e g message passing paradigm are more complex in terms of code refactoring and hardware setup in addition these hardware systems may not be available or accessible to modelers conducting flood analyses this paper presents a 2d flood model that implements multithreading for use on now prevalent multicore computers this desktop parallel computing architecture has been shown to decrease computation time by 14 times on a 16 processor computer and when coupled with a wet cell tracking algorithm has been shown to decrease computation by as much as 310 times these accomplishments make high fidelity flood modeling more feasible for flood inundation studies using readily available desktop computers 2011 american society of civil engineers domain tracking flood modeling java multithreading multicore multiprocessor computing parallel computing shallow water equations ranking refactoring suggestions based on historical volatility the widespread acceptance of refactorings as a simple yet effective approach to improve the design of object oriented systems has stimulated an effort to develop semi automatic tools for detecting design flaws with simultaneous suggestions for their removal however even in medium sized projects the number of detected occurrences can be so large that the refactoring process becomes intractable for the designer it is reasonable to expect that some of the suggested refactorings will have a significant effect on the improvement of maintainability while others might be less important this implies that the suggested solutions can be ranked according to one or more criteria in this paper we propose the exploitation of past source code versions in order to rank refactoring suggestions according to the number proximity and extent of changes related with the corresponding code smells the underlying philosophy is that code fragments which have been subject to maintenance tasks in the past are more likely to undergo changes in a future version and thus refactorings involving the corresponding code should have a higher priority to this end historical volatility models drawn from the field of forecasting risk in financial markets are investigated as measures expressing the urgency to resolve a given design problem the approach has been integrated into an existing smell detection eclipse plug in while the evaluation results focus on the forecast accuracy of the examined models 2011 ieee code smell forecasting models historical volatility refactoring software history software repositories an empirical study of the impact of two antipatterns blob and spaghetti code on program comprehension antipatterns are poor solutions to recurring design problems which are conjectured in the literature to make object oriented systems harder to maintain however little quantitative evidence exists to support this conjecture we performed an empirical study to investigate whether the occurrence of antipatterns does indeed affect the under standability of systems by developers during comprehension and maintenance tasks we designed and conducted three experiments with 24 subjects each to collect data on the performance of developers on basic tasks related to program comprehension and assessed the impact of two antipatterns and of their combinations blob and spaghetti code we measured the developers performance with 1 the nasa task load index for their effort 2 the time that they spent performing their tasks and 3 their percentages of correct answers collected data show that the occurrence of one antipattern does not significantly decrease developers performance while the combination of two antipatterns impedes significantly developers we conclude that developers can cope with one antipattern but that combinations of antipatterns should be avoided possibly through detection and refactorings 2011 ieee antipatterns blob empirical software engineering program comprehension program maintenance spaghetti code architectural refactoring of a mission critical integration application a case study architecture refactoring can be thought of as a process of changing the architecture of an existing application without altering the functional behavior it is to improve the operational and developmental quality attributes such as performance stability complexity and maintainability due to changing business expectations as well as runtime environments architecture refactoring may need to be done incrementally over multiple software release cycles in this industry experience report we present an architectural refactoring of a mission critical integration application after it was originally implemented we discuss the drivers behind the refactoring and the approach initial results from the refactoring show significant improvement of stability and throughput of the system we also present recommendations on architectural refactoring and discuss the importance of key performance indicators that drive architecture refactoring architecture refactoring software maintenance incremental clone detection and elimination for erlang programs a well known bad code smell in refactoring and software maintenance is the existence of code clones which are code fragments that are identical or similar to one another this paper describes an approach to incrementally detecting similar code based on the notion of least general common abstraction or anti unification as well as a framework for user controlled incremental elimination of code clones within the context of erlang programs the clone detection algorithm proposed in this paper achieves 100 precision high recall rate and is user customisable regarding the granularity of the clone classes reported by detecting and eliminating clones in an incremental way we make it possible for the tool to be used in an interactive way even with large codebases both the clone detection and elimination functionalities are integrated with wrangler a tool for interactive refactoring of erlang programs we evaluate the approach with various case studies 2011 springer verlag code clone detection erlang program analysis program transformation refactoring software maintenance wrangler an empirical study of long lived code clones previous research has shown that refactoring code clones as soon as they are formed or discovered is not always feasible or worthwhile to perform since some clones never change during evolution and some disappear in a short amount of time while some undergo repetitive similar edits over their long lifetime toward a long term goal of developing a recommendation system that selectively identifies clones to refactor as a first step we conducted an empirical investigation into the characteristics of long lived clones our study of 13558 clone genealogies from 7 large open source projects over the history of 33 25 years in total found surprising results the size of a clone the number of clones in the same group and the method level distribution of clones are not strongly correlated with the survival time of clones however the number of developers who modified clones and the time since the last addition or removal of a clone to its group are highly correlated with the survival time of clones this result indicates that the evolutionary characteristics of clones may be a better indicator for refactoring needs than static or spatial characteristics such as loc the number of clones in the same group or the dispersion of clones in a system 2011 springer verlag code clones empirical study refactoring software evolution code bad smells a review of current knowledge fowler et al identified 22 code bad smells to direct the effective refactoring of code these are increasingly being taken up by software engineers however the empirical basis of using code bad smells to direct refactoring and to address trouble in code is not clear i e we do not know whether using code bad smells to target code improvement is effective this paper aims to identify what is currently known about code bad smells we have performed a systematic literature review of 319 papers published since fowler et al identified code bad smells 2000 to june 2009 we analysed in detail 39 of the most relevant papers our findings indicate that duplicated code receives most research attention whereas some code bad smells e g message chains receive little this suggests that our knowledge of some code bad smells remains insufficient our findings also show that very few studies report on the impact of using code bad smells with most studies instead focused on developing tools and methods to automatically detect code bad smells this indicates an important gap in the current knowledge of code bad smells overall this review suggests that there is little evidence currently available to justify using code bad smells copyright 2010 john wiley sons ltd code bad smells empirical software engi neering refactoring systematic literature review correlation between object oriented metrics and refactoring repeated code modification lowers code quality and impacts object oriented system design object oriented metrics have proven as indicators of problems in system design they have been grouped in minimal sets known as quality models to assess object oriented system quality improvement can be gained by establishing relationships between quality characteristics and metrics computed from object oriented diagrams quality models include metrics that can produce better code in object oriented systems code quality can also be gained with refactoring refactoring is used to reduce complexity and eliminate redundant code it is important to identify when and where to use refactoring there are many different approaches this work presents early stage analysis and focuses on exploring whether object oriented metrics can be used as indicators where in the code refactoring can be used through multiple itera tions of successive measurement and refactoring relation between metric values and need of refactoring can be concluded 2011 springer verlag automated metric collection metric based refactoring object oriented metrics object oriented quality models refactor ing identifying extract class refactoring opportunities using structural and semantic cohesion measures approaches for improving class cohesion identify refactoring opportunities using metrics that capture structural relationships between the methods of a class e g attribute references semantic metrics e g c3 metric have also been proposed to measure class cohesion as they seem to complement structural metrics however until now semantic relationships between methods have not been used to identify refactoring opportunities in this paper we propose an extract class refactoring method based on graph theory that exploits structural and semantic relationships between methods the empirical evaluation of the proposed approach highlighted the benefits provided by the combination of semantic and structural measures and the potential usefulness of the proposed method as a feature for software development environments 2010 elsevier inc all rights reserved cohesion coupling empirical studies extract class refactoring graph theory maxflow mincut object oriented inheritance metrics in the context of cognitive complexity it is important to identify modules that are fault prone or exhibit evidence of high cognitive complexity as these modules require corrective actions such as increased source code inspection refactoring or performing more exhaustive testing this can lead to a better quality software system it has been found that inheritance has an impact on the cognitive complexity of a software system in this paper two inheritance metrics based on cognitive complexity one at class level cci class complexity due to inheritance and another at program level aci average complexity of a program due to inheritance have been proposed for object oriented software systems additionally one more metric mc method complexity has been proposed to calculate the complexity of a method these proposed metrics are compared with some well known object oriented inheritance metrics by calculating their values for three random c programs it has been observed that cci and aci are better to represent cognitive complexity due to inheritance than other well known class level and program level inheritance metrics cognitive complexity object oriented systems software metrics search based refactoring based on unfolding of graph transformation systems international conference on graph transformation 2010 doctoral symposium 2010 to improve scalability and understandability of search based refactoring in this paper we propose a formulation based on graph transformation which allows us to make use of partial order semantics and an associated analysis technique the approximated unfolding of graph transformation systems we use graphs to represent object oriented software architectures at the class level and graph transformations to describe their refactoring operations in the unfolding we can identify dependencies and conflicts between refactoring steps leading to an implicit and therefore more scalable representation of the search space an optimisation algorithm based on the ant colony paradigm is used to explore this search space aiming to find a sequence of refactoring steps that leads to the best design at a minimal costs ant colony optimisation meta heuristic search based refactoring unfolding of graph transformation systems detecting wsdl bad practices in code first web services service oriented computing soc allows developers to structure applications as a set of reusable services web services expose their functionality by using web service description language wsdl we found that there is a high correlation between well known object oriented metrics taken in the code implementing services and the occurrences of anti patterns in their wsdls we show that some simple refactorings performed early when developing web services can greatly improve the quality of wsdl documents then the contribution of this work is a practical approach to guide practitioners in obtaining better wsdl designs that aligns with the technologies and techniques commonly used in the industry for building services 2011 inderscience enterprises ltd code first early detection object oriented metrics service oriented computing soc web service discovery web services wsdl anti patterns wsdl specification 3rd ifip tc 2 central and east european conference on software engineering techniques cee set 2008 the proceedings contain 21 papers the special focus in this conference is on requirements specification design modeling and software product lines the topics include towards a compiler for business it systems a vision statement complemented with a research agenda automated generation of implementation from textual system requirements mining design patterns from existing projects using static and run time analysis transformational design of business processes for soa service based realization of business processes driven by control flow patterns open work of two hemisphere model transformation definition into uml class diagram in the context of mda refactoring the documentation of software product lines code generation for a bi dimensional composition mechanism advanced data organization for java powered mobile devices developing applications with aspect oriented change realization assessing the quality of quality gate reference processes exploratory comparison of expert and novice pair programmers state of the practice in software effort estimation a framework for defect prediction in specific software project contexts and meeting organisational needs and quality assurance through balancing agile and formal usability testing results run time security traceability for evolving systems security critical systems are challenging to design and implement correctly and securely a lot of vulnerabilities have been found in current software systems both at the specification and the implementation levels this paper presents a comprehensive approach for model based security assurance initially it allows one to formally verify the design models against high level security requirements such as secrecy and authentication on the specification level and helps to ensure that their implementation adheres to these properties if they express a system s run time behaviour as such it provides a traceability link from the design model to its implementation by which the actual system can then be verified against the model while it executes this part of our approach relies on a technique also known as run time verification the extra effort for it is small as most of the computation is automated however additional resources at run time may be required if during run time verification a security weakness is uncovered it can be removed using aspect oriented security hardening transformations therefore this approach also supports the evolution of software since the traceability mapping is updated when refactoring operations are regressively performed using our tool supported refactoring technique the proposed method has been applied to the java based implementation jessie of the internet security protocol ssl in which a security weakness was detected and fixed using our approach we also explain how the traceability link can be transformed to the official implementation of the java secure sockets extension that was recently made open source by sun the author 2009 published by oxford university press on behalf of the british computer society all rights reserved cryptographic protocols formal verification it security monitoring requirements traceability run time verification security analysis software evolution recovering traceability links between unit tests and classes under test an improved method unit tests are valuable as a source of up to date documentation as developers continuously changes them to reflect changes in the production code to keep an effective regression suite maintaining traceability links between unit tests and classes under test can help developers to comprehend parts of a system in particular unit tests show how parts of a system are executed and as such how they are supposed to be used moreover the dependencies between unit tests and classes can be exploited to maintain the consistency during refactoring generally such dependences are not explicitly maintained and they have to be recovered during software development some guidelines and naming conventions have been defined to describe the testing environment in order to easily identify related tests for a programming task however very often these guidelines are not followed making the identification of links between unit tests and classes a time consuming task thus automatic approaches to recover such links are needed in this paper a traceability recovery approach based on data flow analysis dfa is presented in particular the approach retrieves as tested classes all the classes that affect the result of the last assert statement in each method of the unit test class the accuracy of the proposed method has been empirically evaluated on two systems an open source system and an industrial system as a benchmark we compare the accuracy of the dfa based approach with the accuracy of the previously used traceability recovery approaches namely naming convention nc and last call before assert lcba that seem to provide the most accurate results the results show that the proposed approach is the most accurate method demonstrating the effectiveness of dfa however the case study also highlights the limitations of the experimented traceability recovery approaches showing that detecting the class under test cannot be fully automated and some issues are still under study 2010 ieee empirical studies traceability unit testing playing with refactoring identifying extract class opportunities through game theory in software engineering developers must often find solutions to problems balancing competing goals e g quality versus cost time to market versus resources or cohesion versus coupling finding a suitable balance between contrasting goals is often complex and recommendation systems are useful to support developers and managers in performing such a complex task we believe that contrasting goals can be often dealt with game theory techniques indeed game theory is successfully used in other fields especially in economics to mathematically propose solutions to strategic situation in which an individual s success in making choices depends on the choices of others to demonstrate the applicability of game theory to software engineering and to understand its pros and cons we propose an approach based on game theory that recommend extract class refactoring opportunities a preliminary evaluation inspired by mutation testing demonstrates the applicability and the benefits of the proposed approach 2010 ieee game theory quality metrics refactoring do metrics help to identify refactoring many iterative software development methodologies such as for example extreme programming state that refactoring is one of the key activities to be undertaken in order to keep the code base of a project well structured and consistent in such a context poorly structured code may become a significant obstacle in adding new or in enhancing existing functionality however there is some anecdotal evidence that in many software projects the underlying code base is not necessarily refactored post release often due to time constraints or the misconception that refactoring does not add any apparent value in order to get further insights into this problem area we propose to investigate the usage frequency of refactorings in the context of open source object oriented software systems in this work we will outline our approach to detecting refactoring and present results obtained from an initial pilot study 2010 acm evolution metrics open source software refactoring a two step technique for extract class refactoring we propose a novel approach supporting the extract class refactoring the proposed approach analyzes the structural and semantic similarity of the methods in a class in order to identify chains of strongly related methods the identified method chains are used to define new classes with higher cohesion than the original class a preliminary evaluation reveals that the approach is able to identify meaningful refactoring operations 2010 acm design experimentation investigating the evolution of bad smells in object oriented code software design problems are known and perceived under many different terms such as bad smells flaws non compliance to design principles violation of heuristics excessive metric values and antipatterns signifying the importance of handling them in the construction and maintenance of software once a design problem is identified it can be removed by applying an appropriate refactoring improving in most cases several aspects of quality such as maintainability comprehensibility and reusability this paper taking advantage of recent advances and tools in the identification of non trivial bad smells explores the presence and evolution of such problems by analyzing past versions of code several interesting questions can be investigated such as whether the number of problems increases with the passage of software generations whether problems vanish by time or only by targeted human intervention whether bad smells occur in the course of evolution of a module or exist right from the beginning and whether refactorings targeting at smell removal are frequent in contrast to previous studies that investigate the application of refactorings in the history of a software project we attempt to study the subject from the point of view of the problems themselves distinguishing deliberate maintenance activities from the removal of design problems as a side effect of software evolution results are discussed for two open source systems and three bad smells 2010 ieee bad smell evolution refactoring software history software repositories reducing subjectivity in code smells detection experimenting with the long method guidelines for refactoring are meant to improve software systems internal quality and are widely acknowledged as among software s best practices however such guidelines remain mostly qualitative in nature as a result judgments on how to conduct refactoring processes remain mostly subjective and therefore non automatable prone to errors and unrepeatable the detection of the long method code smell is an example to address this problem this paper proposes a technique to detect long method objectively and automatically using a binary logistic regression model calibrated by expert s knowledge the results of an experiment illustrating the use of this technique are reported 2010 ieee binary logistic regression code smells long method refactoring process linguistic driven refactoring of source code identifiers identifiers are an important source of information during program understanding and maintenance programmers often use identifiers to build their mental models of the software artifacts we have performed a preliminary study to examine the relation between the terms in identifiers their spread in entities and fault proneness we introduced term entropy and context coverage to measure how scattered terms are across program entities and how unrelated are the methods and attributes containing these terms our results showed that methods and attributes containing terms with high entropy and context coverage are more fault prone we plan to build on this study by extracting linguistic information form methods and classes using this information we plan to establish traceability link from domain concepts to source code and to propose linguistic based refactoring 2010 ieee an integrated process for aspect mining and refactoring aspect oriented software development aosd aims at solving the problem of encapsulating crosscutting concerns which orthogonally crosscut the components of a system in units called aspects this encapsulation improves the modularization of a system and in consequence its maintenance and evolution in this work the authors propose a systematic process for the migration of object oriented systems to aspect oriented ones this migration is achieved in two main phases crosscutting concern identification aspect mining and code transformation aspect refactoring the aspect mining phase is based on dynamic analysis and association rules to identify potential crosscutting concerns the aspect refactoring phase on the other hand uses inference rules to identify the refactoring that can be applied the whole process is described and its application on a real system is assessed 2010 igi global ref finder a refactoring reconstruction tool based on logic query templates knowing which parts of a system underwent which types of refactoring between two program versions can help programmers better understand code changes though there are a number of techniques that automatically find refactorings from two input program versions these techniques are inadequate in terms of coverage by handling only a subset of refactoring types mostly simple rename and move refactorings at the level of classes methods and fields this paper presents a ref finder eclipse plug in that automatically identifies both atomic and composite refactorings using a template based refactoring reconstruction approach it expresses each refactoring type in terms of template logic queries and uses a logic programming engine to infer concrete refactoring instances ref finder currently supports sixty three types in the fowler s catalog showing the most comprehensive coverage among existing techniques logic based program representation program differencing refactoring software evolution p3jw 2010 proceedings of the work in progress session at the 8th international conference on the principles and practice of programming in java pppj 2010 the proceedings contain 8 papers the topics discussed include rulam project speculative parallelization for java using software transactional memory a java framework for developing intelligent tutoring systems implementing dynamic mixins for the java virtual machine semantic subtyping for objects and classes specification execution and detection of refactorings for software models bytecode analysis for checking java access modifiers scala java mod jvm on the performance characteristics of scala programs on the java virtual machine and extending java s communication mechanisms for multicore processors visual indicator component software to show component design quality and characteristic good design is one of the prerequisites of high quality product to measure the quality of software design software metrics are used unfortunately in software development practice there are a lot of software developers who are not concerned with the component s quality and characteristic software metrics does not interest them because to understand the measurement of the metrics a deep understanding about degree dimension and capacity of some attribute of the software product is needed this event triggers them to build software s whose quality is below the standard what is more dangerous is that these developers are not aware of quality and do not care with their work product of course these occurrences is concerning and a solution needed to be found through this paper the researcher is trying to formulate an indicator of component software that shows component design quality and characteristic visually this indicator can help software developers to make design decision and refactoring decision detect the design problem more quickly able to decide which area to apply refactoring and enable us to do early or final detection of design defects 2010 ieee detection of design defects indicator component software refactoring software component characteristic software component design quality lightweight executability analysis of graph transformation rules domain specific visual languages dsvls play a cornerstone role in model driven engineering mde where domain specific models are used to automate the production of the final application graph transformation is a formal visual rule based technique which is increasingly used in mde to express in place model transformations like refactorings animations and simulations however there is currently a lack of methods able to perform static analysis of rules taking into account the dsvl meta model integrity constraints in this paper we propose a lightweight efficient technique that performs static analysis of the weak executability of rules the method determines if there is some scenario in which the rule can be safely applied without breaking the meta model constraints if no such scenario exists the method returns meaningful feedback that helps repairing the detected inconsistencies 2010 ieee application of identical degree of set pair analysis on software refactoring set pair analysis possesses many virtues including specific concept convenience calculation and it covers comprehensive information as well in course of software refactoring traditional code locating method mostly relies on developer s observations and subjective perceptions which brings with much inconvenience therefore a new software refactoring scheme optimization model was built up based on identical degree of set pair analysis in virtue of correlation indicators of software metrics which offered a resolution to code locating in software refactoring this paper applied variation coefficient method to calculate the weight of indicators which improves the reliability of scheme evaluation an experimental case argues that the set pair analysis model can locate the iffy code correctly and furthermore it can offer specific refactoring order of each scheme 2010 ieee identical degree scheme optimization set pair analysis software refactoring abstracting abstract machines we describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well established abstract machines to demonstrate the technique and support our claim we transform the cek machine of felleisen and friedman a lazy variant of krivine s machine and the stack inspecting cm machine of clements and felleisen into abstract interpretations of themselves the resulting analyses bound temporal ordering of program events predict return flow and stack inspection behavior and approximate the flow and evaluation of by need parameters for all of these machines we find that a series of well known concrete machine refactorings plus a technique we call store allocated continuations leads to machines that abstract into static analyses simply by bounding their stores we demonstrate that the technique scales up uniformly to allow static analysis of realistic language features including tail calls conditionals side effects exceptions first class continuations and even garbage collection 2010 acm abstract interpretation abstract machines detecting missing thrown exceptions in enterprise systems an empirical study commonly enterprise systems are implemented using the object oriented and relational paradigms among which the communication is performed using various library methods for manipulating the persistent data most of the times the involved library methods throw different exceptions an improper handling mechanism for these exceptions in the source code may bring different problems at runtime and hamper its maintenance in this work we introduce an approach that automatically detects the methods from the source code which reveal an improper mechanism for handling exceptions involving database operations the detected methods should be refactored in order to increase the reliability of the application as well as its maintenance 2010 acm software quality assessment static analysis building empirical support for automated code smell detection identifying refactoring opportunities in software systems is an important activity in today s agile development environments the concept of code smells has been proposed to characterize different types of design shortcomings in code additionally metric based detection algorithms claim to identify the smelly components automatically this paper presents results for an empirical study performed in a commercial environment the study investigates the way professional software developers detect god class code smells then compares these results to automatic classification the results show that even though the subjects perceive detecting god classes as an easy task the agreement for the classification is low misplaced methods are a strong driver for letting subjects identify god classes as such earlier proposed metric based detection approaches performed well compared to the human classification these results lead to the conclusion that an automated metric based pre selection decreases the effort spent on manual code inspections automatic detection accompanied by a manual review increases the overall confidence in the results of metric based classifiers 2010 acm code inspection code smells empirical study god class maintainability abstract interpreters for free in small step abstract interpretations the concrete and abstract semantics bear an uncanny resemblance in this work we present an analysis design methodology that both explains and exploits that resemblance specifically we present a two step method to convert a small step concrete semantics into a family of sound computable abstract interpretations the first step re factors the concrete state space to eliminate recursive structure this refactoring of the state space simultaneously determines a store passing style transformation on the underlying concrete semantics the second step uses inference rules to generate an abstract state space and a galois connection simultaneously the galois connection allows the calculation of the optimal abstract interpretation the two step process is unambiguous but nondeterministic at each step analysis designers face choices some of these choices ultimately influence properties such as flow field and context sensitivity thus under the method we can give the emergence of these properties a graph theoretic characterization to illustrate the method we systematically abstract the continuation passing style lambda calculus to arrive at two distinct families of analyses the first is the well known k cfa family of analyses the second consists of novel environment centric abstract interpretations none of which appear in the literature on static analysis of higher order programs 2010 springer verlag a logic based approach to locate composite refactoring opportunities in object oriented code in today s software engineering more and more emphasis is put on the quality of object oriented software design it is commonly accepted that building a software system with maintainability and reusability issues in mind is far more important than just getting all the requirements fulfilled in one way or another design patterns are powerful means to obtain this goal tools have been built that automatically detect design patterns in object oriented code and help in understanding the code other tools help in refactoring object oriented code towards introducing design patterns but human intelligence is needed to detect where these design patterns should be inserted this paper proposes a logic approach to the automatic detection of places within object oriented code where the composite design pattern could have been used suspects identified by such a tool could very well be served as input data for other tools that automatically refactor the code as to introduce the missing design pattern tositumomab and 131i therapy in non hodgkin s lymphoma tositumomab and 131 i tositumomab constitute a relatively new radioimmunotherapeutic regimen for patients with cd20 follicular non hodgkin s lymphoma nhl currently it is approved for use in patients whose disease has relapsed after chemotherapy and is refactory to rituximab including patients whose tumors have transformed to a higher histologic grade this review outlines the current and evolving status of this therapeutic regimen at nonmyeloablative doses methods clinical data from multiple published studies and preliminary communications encompassing more than 1 000 patients were reviewed to describe the current status of tositumomab and 131 i tositumomab therapy the therapy is delivered in 2 parts a dosimetric dose and a therapeutic dose the therapeutic radioactivity millicurie dose is calculated on a patient individualized tailored basis a series of 3 total body γ camera scans are used to determine the patient specific pharmacokinetics total body residence time of the radiolabeled antibody conjugate required to deliver the desired total body radiation dose typically 75 cgy results in clinical trials objective response rates in patients who had been extensively pretreated with chemotherapy ranged from 47 to 68 tositumomab and 131 i tositumomab therapy also was effective in patients who had failed to respond to or who had relapsed after rituximab therapy with a 68 overall response rate thirty percent of such patients achieved complete responses that were generally of several years duration single center trials using tositumomab and 131 i tositumomab therapy alone or after chemotherapy in previously untreated patients have shown response rates in excess of 90 with most responses complete retreatment with tositumomab and 131 i tositumomab and use of lower total body radiation doses of tositumomab and 131 i tositumomab to treat patients who have relapsed after stem cell transplantation have been shown feasible in limited clinical studies toxicity is predominately hematologic however human antimouse antibodies hypothyroidism and myelodysplastic syndrome have been reported in a small fraction of patients conclusion tositumomab and 131 i tositumomab therapy at patient specific nonmyeloablative doses is safe and effective in treatment of relapsed and refractory follicular nhl toxicity is mainly hematologic and reversible tositumomab and 131 i tositumomab therapy is assuming a growing role in this common malignancy non hodgkin s lymphoma radioimmunotherapy tositumomab and i tositumomab therapy 131 using reengineering and aspect based techniques to retrieve knowledge embedded in object oriented legacy system this paper presents an approach to retrieve the knowledge embedded in object oriented legacy system this approach aids in the migration from object oriented code written in java to a combination of objects and aspects using aspectj the approach uses aspect mining in order to identify possible crosscutting concerns from the object oriented source code and extracts them through refactorings into new aspect oriented code next the aspect oriented design is retrieved through software transformations and may be imported in a case tool becoming available in higher abstraction levels the retrieved information constitutes important knowledge that may be reused in future projects or in reengineering 2004 ieee oopsla 04 conference companion 19th annual acm conference on object oriented programming systems languages and applications the proceedings contain 105 papers the topics discussed include jmock supporting responsibility based design with mock objects advanced refactorings in eclipse jquery finding your way through tangled code modeling event driven applications with a specification language medasl design snippets partial design representations extracted from source code meta programming for the real world jra offline analysis of runtime behavior modeling and building software product lines with eclipse prism is research in aspect mining smell detection for eclipse program transformations for re engineering c components oopsla gpce c saw and genaweave a two level aspect weaving toolsuite the concern manipulation environment oopsla gpce object oriented structural software configuration management implementing dsl in metaocaml modeling dynamics of agile software development interactive visualization of object oriented programs and generic ownership practical ownership in programming languages an automatic approach to identify class evolution discontinuities when a software system evolves features are added removed and changed moreover refactoring activities are periodically performed to improve the software internal structure a class may be replaced by another two classes can be merged or a class may be split in two others as a consequence it may not be possible to trace software features between a release and another when studying software evolution we should be able to trace a class lifetime even when it disappears because it is replaced by a similar one split or merged such a capability is also essential to perform impact analysis this paper proposes an automatic approach inspired on vector space information retrieval to identify class evolution discontinuities and therefore cases of possible refactoring the approach has been applied to identify refactorings performed over 40 releases of a java open source domain name server almost all the refactorings found were actually performed in the analyzed system thus indicating the helpfulness of the approach and of the developed tool refactoring releases software evolution traceability refactoring class hierarchies with kaba kaba is an innovative system for refactoring java class hierarchies it uses the snelting tip algorithm in order to determine a behavior preserving refactoring which is optimal with respect to a given set of client programs kaba can be based on dynamic as well as static program analysis the static variant will preserve program behavior for all possible input values the dynamic version guarantees preservation of behavior for all runs in a given test suite kaba offers automatic refactoring as well as manual refactoring using a dedicated editor in this contribution we recapitulate the snelting tip algorithm present the new dynamic version and explain new extensions which allow to handle full java we then present five case studies which discuss the kaba refactoring proposals for programs such as javac and antlr kaba proved that javac does not need refactoring but generated semantics based refactoring proposals for antlr categories and subject descriptors d 2 7 software engineering distribution maintenance and enhancement restructuring reverse engineering and reengineering d 3 3 programming languages language constructs and features classes and objects inheritance f 3 2 logics and meanings of programms semantics of programming languages program analysis refactoring refactoring methods for knowledge bases the manual development of large knowledge systems is a difficult and error prone task in order to facilitate extensions to an existing knowledge base the structural design of the implemented knowledge needs to be improved from time to time however experts are often deterred even from important design improvements since some restructurings are too complex to handle in this paper we introduce a framework that allows for automated refactorings refactoring methods are well defined and are executed in a semi automated way in this manner the developer is supported during the process of restructuring of even large knowledge bases refactoring methods are usually applied to improve the design of the knowledge base in this paper we sketch some design anomalies that identify poor design of the knowledge base springer verlag berlin heidelberg 2004 refactoring improving coupling and cohesion of existing code refactorings are widely recognised as ways to improve the internal structure of object oriented software while maintaining its external behaviour unfortunately refactorings concentrate on the treatment of symptoms the so called code smells thus improvements depend a lot on the skills of the maintainer coupling and cohesion on the other hand are quality attributes which are generally recognized as being among the most likely quantifiable indicators for software maintainability therefore this paper analyzes how refactorings manipulate coupling cohesion characteristics and how to identify refactoring opportunities that improve these characteristics as such we provide practical guidelines for the optimal usage of refactoring in a software maintenance process 2004 ieee prism is research in aspect mining it s a pleasure to welcome you to oopsla 2004 the 19th annual conference on object oriented programming systems languages and applications oopsla is the premier forum for practitioners researchers and students in diverse disciplines whose common thread is object technology from its inception oopsla has served as an incubator for advanced technologies and practices dynamic compilation and optimization patterns refactoring aspect oriented programming and agile methods to name a few all have oopsla roots oopsla 2004 continues that tradition researchers and practitioners from around the world have come to showcase their latest work presentations from invited speakers dovetail with technical papers practitioner reports expert panels demonstrations formal and informal educational symposia workshops and diverse tutorials from world class lecturers the popular onward track presents out of the box thinking at the forefront of computing you can discuss late breaking results with the researchers themselves at poster sessions which culminate in the third annual sigplan student research competition designfest provides hands on design experience in an expert mentored environment and again this year we re privileged to host the acm turing lecture alan kay turing laureate for 2003 received the prestigious award for pioneering many of the ideas at the root of contemporary object oriented programming languages leading the team that developed smalltalk and for fundamental contributions to personal computing it s especially fitting that dr kay deliver the turing lecture at oopsla aspect mining aspect oriented programming concern identification granule oriented programming extended abstract it s a pleasure to welcome you to oopsla 2004 the 19th annual conference on object oriented programming systems languages and applications oopsla is the premier forum for practitioners researchers and students in diverse disciplines whose common thread is object technology from its inception oopsla has served as an incubator for advanced technologies and practices dynamic compilation and optimization patterns refactoring aspect oriented programming and agile methods to name a few all have oopsla roots oopsla 2004 continues that tradition researchers and practitioners from around the world have come to showcase their latest work presentations from invited speakers dovetail with technical papers practitioner reports expert panels demonstrations formal and informal educational symposia workshops and diverse tutorials from world class lecturers the popular onward track presents out of the box thinking at the forefront of computing you can discuss late breaking results with the researchers themselves at poster sessions which culminate in the third annual sigplan student research competition designfest provides hands on design experience in an expert mentored environment and again this year we re privileged to host the acm turing lecture alan kay turing laureate for 2003 received the prestigious award for pioneering many of the ideas at the root of contemporary object oriented programming languages leading the team that developed smalltalk and for fundamental contributions to personal computing it s especially fitting that dr kay deliver the turing lecture at oopsla code granulation space granule oriented programming object oriented programming program grinding reflection enhancing distributed object middleware qualities it s a pleasure to welcome you to oopsla 2004 the 19th annual conference on object oriented programming systems languages and applications oopsla is the premier forum for practitioners researchers and students in diverse disciplines whose common thread is object technology from its inception oopsla has served as an incubator for advanced technologies and practices dynamic compilation and optimization patterns refactoring aspect oriented programming and agile methods to name a few all have oopsla roots oopsla 2004 continues that tradition researchers and practitioners from around the world have come to showcase their latest work presentations from invited speakers dovetail with technical papers practitioner reports expert panels demonstrations formal and informal educational symposia workshops and diverse tutorials from world class lecturers the popular onward track presents out of the box thinking at the forefront of computing you can discuss late breaking results with the researchers themselves at poster sessions which culminate in the third annual sigplan student research competition designfest provides hands on design experience in an expert mentored environment and again this year we re privileged to host the acm turing lecture alan kay turing laureate for 2003 received the prestigious award for pioneering many of the ideas at the root of contemporary object oriented programming languages leading the team that developed smalltalk and for fundamental contributions to personal computing it s especially fitting that dr kay deliver the turing lecture at oopsla design experimentation performance standardization implementing dsls in metaocaml it s a pleasure to welcome you to oopsla 2004 the 19th annual conference on object oriented programming systems languages and applications oopsla is the premier forum for practitioners researchers and students in diverse disciplines whose common thread is object technology from its inception oopsla has served as an incubator for advanced technologies and practices dynamic compilation and optimization patterns refactoring aspect oriented programming and agile methods to name a few all have oopsla roots oopsla 2004 continues that tradition researchers and practitioners from around the world have come to showcase their latest work presentations from invited speakers dovetail with technical papers practitioner reports expert panels demonstrations formal and informal educational symposia workshops and diverse tutorials from world class lecturers the popular onward track presents out of the box thinking at the forefront of computing you can discuss late breaking results with the researchers themselves at poster sessions which culminate in the third annual sigplan student research competition designfest provides hands on design experience in an expert mentored environment and again this year we re privileged to host the acm turing lecture alan kay turing laureate for 2003 received the prestigious award for pioneering many of the ideas at the root of contemporary object oriented programming languages leading the team that developed smalltalk and for fundamental contributions to personal computing it s especially fitting that dr kay deliver the turing lecture at oopsla multi stage programming program generation staged interpreters modeling and building software product lines with eclipse it s a pleasure to welcome you to oopsla 2004 the 19th annual conference on object oriented programming systems languages and applications oopsla is the premier forum for practitioners researchers and students in diverse disciplines whose common thread is object technology from its inception oopsla has served as an incubator for advanced technologies and practices dynamic compilation and optimization patterns refactoring aspect oriented programming and agile methods to name a few all have oopsla roots oopsla 2004 continues that tradition researchers and practitioners from around the world have come to showcase their latest work presentations from invited speakers dovetail with technical papers practitioner reports expert panels demonstrations formal and informal educational symposia workshops and diverse tutorials from world class lecturers the popular onward track presents out of the box thinking at the forefront of computing you can discuss late breaking results with the researchers themselves at poster sessions which culminate in the third annual sigplan student research competition designfest provides hands on design experience in an expert mentored environment and again this year we re privileged to host the acm turing lecture alan kay turing laureate for 2003 received the prestigious award for pioneering many of the ideas at the root of contemporary object oriented programming languages leading the team that developed smalltalk and for fundamental contributions to personal computing it s especially fitting that dr kay deliver the turing lecture at oopsla embedded systems model driven software development software product lines variant management evaluating clone detection techniques from a refactoring perspective in the last decade several researchers have investigated techniques to automatically detect duplicated code in programs exceeding hundreds of thousands lines of code all of these techniques have known merits and deficiencies but as of today little is known on how these techniques fit into the refactoring process of object oriented systems this paper compares three representative detection techniques simple line matching parameterized matching and metric fingerprints by means of five small to medium sized cases and analyses the differences between the reported matches based on this comparison we conclude that 1 simple line matching is best suited for a partial yet advanced restructuring with little effort 2 metric fingerprints work best for refactoring a system with minimal effort 3 parameterized matching demands more effort yet allows a more profound less obvious restructuring of the code 2004 ieee straightening spaghetti code with refactoring changes to software systems often entail a loss of quality especially if they have to be accomplished under pressure of time long term software projects must counter this phenomenon one way or the other to preserve long term maintainability this paper presents the results of a case study trying to improve an extensive low quality code base by object oriented and tool supported refactoring to obtain practically relevant experiences this case study was conducted within an on going commercial software project the existing code base was first assessed using metrics as well as subjective judgment and later on refactored according to the findings of the assessment by this we evaluated the practical applicability of several metrics and refactoring tools the results of this experiment indicate that tool support is immature and the impact of refactoring is limited if the code base has gone astray for a longer period of time refactoring software maintenance software metrics migrating interface implementations to aspects separation of concerns and modularization are the cornerstones of software engineering however when a system is decomposed into units functionalities often emerge which cannot be assigned to a single element of the decomposition the implementation of interfaces 1 represents a typical instance of this problem in fact the code that defines the interface methods is often scattered across several classes in the system and tangled with the original code aspect oriented programming provides mechanisms for the dynamic and static composition of transversal functionalities that can be used to factor out the implementation of interfaces in this paper we describe a technique for the identification of those interface implementations that are most likely to represent crosscutting concerns moreover the code transformation refactoring to migrate such interfaces to aspects is also presented experimental results validate the approach 2004 ieee software design improvement through anti patterns identification in this paper a software design improvement approach through anti pattern identification by case based reasoning is proposed to improve software quality and maintainability first of all xml based design template at micro architecture level is presented to formally define patterns and anti patterns secondly according to 4r model of cbr the retrieve revision reuse and retaining of design improving cases are illustrated especially similarity measurement methods of class diagrams sequence diagrams oo quality metric facts and semantic constraints are proposed to identify problematic inflexible anti patterns and replace them with high quality design finally the architecture of refactoring environment developed to support this approach is introduced 2004 ieee using clustering technique to restructure programs program restructuring or refactoring is often required when a function becomes too large or is involved in multiple activities and therefore exhibits low cohesion a critical factor in restructuring is to increase cohesion and decrease coupling there are many existing methods which measure cohesion and coupling but do not provide much information as to how to restructure the program while some other methods exist which only deals with restructuring the functions the paper presents a simple but effective approach to function restructuring based on the experimental research on cohesion and coupling measure for software cohesion could be the first step of reengineering a software system to identify the functions with low cohesion the next step is to restructure the identified functions a clustering technique is presented in this paper which can assess the cohesiveness of a function and also gives indicaiton as to how to decompose a function to multiple high cohesive functions several examples are presented to demonstrate the concept aries rrfactoring support environment based on code clone analysis code clone has been regarded as one of factors that make software maintenance more difficult a code clone is a code fragment in a source code that is identical or similar to another for example if we modify a code fragment which has code clones it is necessary to consider whether we have to modify each of its code clones hence removal of code clones makes maintainability and comprehensibility of source code more improved we have proposed a method that detects refactoring oriented code clone in this paper in order to improve the usefulness and applicability of the method in the actual software maintenance we have extended our refactoring support method concretely we have developed a characterization of code clones by some metrics which suggest how to remove them then we have developed refactoring support tool aries we expect aries can support software maintenance more effectively code clone metrics object oriented refactoring software maintenance tool asaam aspectual software architecture analysis method software architecture analysis methods aim to predict the quality of a system before it has been developed in general the quality of the architecture is validated by analyzing the impact of predefined scenarios on architectural components hereby it is implicitly assumed that an appropriate refactoring of the architecture design can help in coping with critical scenarios and mending the architecture this paper shows that there are also concerns at the architecture design level which inherently crosscut multiple architectural components which cannot be localized in one architectural component and which as such can not be easily managed by using conventional abstraction mechanisms we propose the aspectual software architecture analysis method asaam to explicitly identify and specify these architectural aspects and make them transparent early in the software development life cycle asaam introduces a set of heuristic rules that help to derive architectural aspects and the corresponding tangled architectural components from scenarios the approach is ilustrated for architectural aspect identification in the architecture design of a window management system aspect oriented software architecture design scenario based architectural evaluation scenario based aspect identification refactoring class hierarchies with kaba kaba is an innovative system for refactoring java class hierarchies it uses the snelting tip algorithm 13 in order to determine a behavior preserving refactoring which is optimal with respect to a given set of client programs kaba can be based on dynamic as well as static program analysis the static variant will preserve program behavior for all possible input values the dynamic version guarantees preservation of behavior for all runs in a given test suite kaba offers automatic refactoring as well as manual refactoring using a dedicated editor in this contribution we recapitulate the snelting tip algorithm present the new dynamic version and explain new extensions which allow to handle full java we then present five case studies which discuss the kaba refactoring proposals for programs such as javac and antlr kaba proved that javac does not need refactoring but generated semantics based refactoring proposals for antlr refactoring automated design flaw correction in object oriented systems software inevitably changes as a consequence we observe the phenomenon referred to as software entropy or software decay the software design continually degrades making maintenance and functional extensions overly costly if not impossible there exist a number of approaches to identify design flaws problem detection and to remedy them refactoring there is however a conceptual gap between these two stages there is no appropriate support for the automated mapping of design flaws to possible solutions in this paper we propose an integrated quality driven and tool supported methodology to support object oriented software evolution our approach is based on the novel concept of correction strategies correction strategies serve as reference descriptions that enable a human assisted tool to plan and perform all necessary steps for the safe removal of detected design flaws with special concern towards the targeted quality goals of the restructuring process we briefly sketch our tool chain and illustrate our approach with the help of a medium sized real world case study supporting architectural restructuring by analyzing feature models in order to lower the risk reengineering projects aim at high reuse rates therefore tasks like architectural restructuring have to be performed in a way that developed new system architectures allow reuse of all valuable legacy systems parts with minimal changes during architectural restructuring there are two major types of modification detection of architecture disproportions and their refactoring and detection of redundancies and their fusion in this paper we introduce a method for applying domain knowledge for supporting these restructuring steps the method operates on feature models words and terms of features and of architectural documents are analyzed by cluster analysis information retrieval and metrics techniques in this way the method joins the approaches of feature analysis and of enhancing reengineering with domain knowledge by applying feature models for structuring the domain knowledge the method results in clues and hints for the development of a new architecture it provides an effective addition to the conventional software architecture design methods the method was developed and applied in an industrial reengineering project within image processing domain it has been proved to be applicable to large and complex systems even in case of heavy monolithic parts we use examples from this project to illustrate the method evolution of rule based programs the term rule based program is meant to include definite clause programs sos specifications attribute grammars and conditional rewrite systems these setups are widely used for the executable specification or implementation of language based tools e g interpreters translators type checkers program analysers and program transformations we provide a pragmatic transformation based approach for expressing and tracking changes in rule based programs in the course of program evolution to this end we design an operator suite for the transformation of rule based programs the operators facilitate steps for clean up refactoring and enhancement we use sos based interpreter examples to illustrate evolution of rule based programs we use logic programming to execute the examples while the relevant evolution operators are made available as logic meta programs 2004 elsevier inc all rights reserved attribute grammars constructive algebraic specification extensibility logic programming meta programming natural semantics program transformation refactoring reuse rule based programming software evolution structural operational semantics 4th conference on extreme programming and agile methods xp agile universe 2004 the proceedings contain 54 papers the special focus in this conference is on testing integration and managing requirements and usability the topics include combining formal specifications with test driven development long build trouble shooting guide the role of process measurement in test driven development acceptance test driven planning an agile customer centered method suitability of fit user acceptance tests for specifying functional requirements using storyotypes to split bloated xp stories distributed pair programming support for distributed pair programming in the transparent video facetop toward a conceptual framework of agile methods security engineering and extreme programming an agile cmm adapting extreme programming to research development and production environments outsourcing and offshoring with agility user story methodology adaptations for projects non traditional in scope and customer gui contributions research close to the action getting leaders on board third international workshop on empirical evaluation of agile methods ui design as part of an agile process agile development for embedded software refactoring our writings agile tests as documentation agile project management agile methods for safety critical software development tailoring the functional requirements specification process to improve agility advanced fit lab effective user stories outsourcing and offshoring with agility coaching agile software teams a practical approach for testers and the customer team first encounter with agile methods working effectively with legacy code the art of acceptance testing agile planning tracking and project management boot camp agile project management and scripting web tests 5th international conference on product focused software process improvement profes 2004 the proceedings contain 41 papers the special focus in this conference is on software process improvement and software quality the topics include a model for the implementation of software process improvement does use of development model affect estimation accuracy and bias managing software process improvement spi through statistical process control spc towards hypotheses on creativity in software development using software inspection as a catalyst for spi in a small company comparing global multi site spi program activities to spi program models a fast approach for an organization to realize the benefits of spi evaluating the calmness of ubiquitous applications quality attributes in mobile web application development introducing quality system in small and medium enterprises definition and empirical validation of metrics for software process models multiview framework for goal oriented measurement plan design eliminating over confidence in software development effort estimates measuring the object oriented properties in small sized c programs an empirical investigation on the impact of training by examples on inspection performance refactoring support based on code clone analysis introducing the next generation of software inspection tools intelligent support for software release planning an empirical evaluation of predicting runaway software projects using bayesian classification effort estimation based on collaborative filtering effective software project management education through simulation models software engineering research strategy automatic measurement at nokia mobile phones using a reference application with design patterns to produce industrial software and using rup for process oriented organisations cbr and micro architecture antipatterns based software design improvement this paper presents a case based reasoning cbr approach to identifying micro architecture anti patterns and replacing them with good patterns in order to improve the design of software system the resulting system design benefits from better flexibility for adapting to future requirement change and expansion in this approach both problematic inflexible structures and their corresponding refactoring designs are formally defined and organized in a case base the identification of anti patterns is carried out through similarity measurement on class diagrams sequence diagrams oo quality metric and semantic constraints a supporting system cbdit was developed to aid this approach 2004 springer science business media inc anti pattern case based reasoning design pattern program evolution refactoring 7th international conference on fundamental approaches to software engineering fase 2004 held as part of the joint european conferences on theory and practice of software etaps 2004 the proceedings contain 28 papers the special focus in this conference is on fundamental approaches to software engineering the topics include distributed information management with xml and web services a formal treatment of context awareness consistent adaptation and evolution of class diagrams during refinement measuring aspect cohesion refactoring object z specifications checking absence of illicit applet interactions a tool assisted framework for certified bytecode verification reasoning about card tears and transactions in java card predictable dynamic plugin systems a correlation framework for the corba component model an integrated development environment for analysis synthesis and verification of component based systems actor centric modeling of user rights modeling role based access control using parameterized uml models compositional nested long running transactions a tool for automatic translation from daml s to high level petri nets integrating meta modelling aspects with graph transformation for efficient visual language definition and model manipulation an operational semantics for stateflow improving use case based requirements using formally grounded specifications an integrated development environment for process control requirements and design automated debugging using path based weakest preconditions filtering tobias combinatorial test suites systematic testing of software architectures in the c2 style optimising communication structure for model checking translating software designs for model checking enhancing remote method invocation through type based static analysis and specification and analysis of real time systems using real time maude 5th international conference on extreme programming and agile processes in software engineering xp 2004 the proceedings contain 60 papers the special focus in this conference is on acceptance testing scalability issues new insights refactoring and social issues the topics include putting a motor on the canoo webtest acceptance testing framework generative acceptance testing for difficult to test software distributed product development using extreme programming efficient markets efficient projects and predicting the future agile principles and open source software development agile specification driven development towards a proper integration of large refactorings in agile software development the oregon software development process empirical analysis on the satisfaction of it employees comparing xp practices with other software development methodologies agile processes enhancing user participation for small providers of off the shelf software self adaptability of agile software processes enterprise continuous integration using binary dependencies automated generation of unit tests for refactoring test driven development and software process improvement in china a comparison of software development process experiences literate programming to enhance agile methods application of lean and agile principles to workflow management assistance for supporting xp test practices in a distributed cscw environment combining ad hoc and regression testing complete test generation for extreme programming conditional test for javabeans components agile methods in software engineering education extreme programming in a university project a selection framework for agile methodologies designing the ultimate acceptance testing framework and xp and organizational change the role of constructors in the context of refactoring object oriented systems constructors play an essential role in object oriented oo languages as a means of object creation yet very little empirical evidence exists on constructors trends in their composition and how they impact comprehension and encapsulation of oo classes in this paper we empirically investigate the opportunities benefits and problems of refactoring class constructors across a sample of classes from five java systems the refactoring used namely replacing multiple constructors with creation methods was applied to each of a set of classes containing three or more constructors empirical results showed benefits in terms of removed duplicated lines of code across the majority of systems they also showed the potential for improved class comprehension by the creation of non constructor methods as a replacement for constructors and improved encapsulation of class elements through use of a private catch all constructor we also provide evidence from five c systems which suggests similar trends in constructors to those found for java in terms of problems encountered frequent and inconsistent use of the super construct made refactoring prohibitively difficult in some cases the existence of java interfaces also means a lack of scope for constructor refactoring the results indicate clear and tangible benefits to be gained from investigation and implementation of refactoring techniques in java but with caution being exercised in certain cases refactoring in practice is not as straightforward as the theory suggests 2003 ieee an information based view of representational coupling in object oriented systems in this paper we investigate a special type of coupling in object oriented systems when a method of a class c invokes a method of a class d the method of c becomes dependent on the representational details of d the more low level the service provided by d is the higher the dependency of c on d this dependency is known as representational coupling coupling in general and representational coupling in particular are important because they influence the extensibility of a system that is the ease with which software can be adapted to changing requirements the higher the coupling the harder it is to make changes since any changes local to one module are likely to affect many other modules we propose a qualitative measure of representational coupling as opposed to quantitative measures provided by metrics that is based on partial orders over equivalence relations on the state space we also introduce the notion of intrinsic representational coupling that expresses the amount of representational coupling that is inherent to the system finally we show that despite its non quantitative nature our measure can be useful in identifying candidate methods for refactoring we demonstrate this by applying our measure to several examples in the literature showing in each case how an implementation with non minimal representational coupling can be transformed using a few simple refactorings into a solution with minimal representational coupling equal to the intrinsic representational coupling springer verlag berlin heidelberg 2003 coupling extensibility metrics object oriented refactoring predicting faulty classes using design metrics with discriminant analysis nowadays risk assessment is one of software engineering processes that plays important role in software development life cycle applying risk assessment to software the earlier is the better developers should detect defects of software early at design phase so the improvement action such as refactoring can be taken constructing fault prediction model using design metrics is one approach that can help developers to identify the faulty classes at early phase this paper collects object oriented design metrics and introduces some new metrics that tend to affect the existing of faults in classes then construct the fault prediction model with discriminant analysis technique the prediction model was trained by data collected from sale system and was validated using data from cd selection system the result indicates that 12 of 14 design metrics are associated with fault proneness and the model can be used to classify faulty level of new classes design metrics discriminant analysis prediction model reliability traits composable units of behaviour despite the undisputed prominence of inheritance as the fundamental reuse mechanism in object oriented programming languages the main variants single inheritance multiple inheritance and mixin inheritance all suffer from conceptual and practical problems in the first part of this paper we identify and illustrate these problems we then present traits a simple compositional model for structuring object oriented programs a trait is essentially a group of pure methods that serves as a building block for classes and is a primitive unit of code reuse in this model classes are composed from a set of traits by specifying glue code that connects the traits together and accesses the necessary state we demonstrate how traits overcome the problems arising from the different variants of inheritance we discuss how traits can be implemented effectively and we summarize our experience applying traits to refactor an existing class hierarchy springer verlag berlin heidelberg 2003 inheritance mixins multiple inheritance reuse smalltalk traits proceedings 7th european conference on software maintenance and reengineering csmr 2003 the proceedings contain 42 papers the topics discussed include software services and software maintenance software documentation how much is enough revitalizing modifiability of legacy assets towards automatical migration of transformation rules after grammar extension automated cobol to java recycling light weight product lines for evolution and maintenance of web sites web applications design and maintenance using symbolic model checking enabling legacy system accessibility by web heterogeneous clients towards a benchmark for web site extractors a call for community participation identifying refactoring opportunities using logic meta programming refactoring browser with preprocessor the role of constructors in the context of refactoring object oriented systems supporting evolution in component based development using component libraries and reengineering legacy application to e business with modified rational unified process building conceptual schemas by refining general ontologies in practice most conceptual schemas of information systems and databases are developed essentially from scratch this paper deals with a new approach to that development consisting on the refinement of a general ontology we identify and characterize the three activities required to develop a conceptual schema from a general ontology that we call refinement pruning and refactoring the focus of the paper is on the differences of the new approach with respect to the traditional one the pruning activity may be automated we formalize it and present a method for its realization besides we identify a particular problem that appears during the refactoring activity determining whether two types are redundant and provide two sufficient conditions for it we illustrate the approach with the development of a conceptual schema by refinement of the cyc ontology however our results apply to any general ontology the conceptual modeling language we have used is the uml but we believe that our results could be applied to any similar language springer verlag berlin heidelberg 2003 global analysis and transformations in preprocessed languages tool support for refactoring code written in mainstream languages such as c and c is currently lacking due to the complexity introduced by the mandatory preprocessing phase that forms part of the c c compilation cycle the defintion and use of macros complicates the notions of scope and of identifier boundaries the concept of token equivalence classes can be used to bridge the gap between the language proper semantic analysis and the nonpreprocessed source code the cscout toolchest uses the developed theory to analyze large interdependent program families a web based interactive front end allows the precise realization of rename and remove refactorings on the original c source code in addition cscout can convert programs into a portable obfuscated format or store a complete and accurate representation of the code and its identifiers in a relational database c c preprocessor program families refactoring renaming reverse engineering refactoring middleware with aspects middleware platforms such as web services j2ee corba and dcom have become increasingly popular during the last decade they have been very successful in solving distributed computing problems for a large family of application domains the architecture of middleware systems have gone through many significant cycles of evolution both in terms of the completeness of functionality and the range of adoptions for different types of platforms however at the same time it is getting increasingly difficult to achieve and to maintain a high level of adaptability and configurability because the structure of the middleware architecture is becoming overly complicated and rigid we attribute that problem to the limitations of traditional software decomposition methods aspect oriented programming on the contrary has introduced new design perspectives that permit the superimpositions of different abstraction models on top of one another this is a very powerful technique for separating and simplifying design concerns in our effort of applying principles of aspect orientation to the middleware architecture we first pragmatically analyze the use of aspects in the middleware architecture we then show that aspects are the correct remedy for the above outlined middleware problems by quantifying crosscutting concerns in the legacy implementations of several prominent middleware systems our aspect analysis results strongly indicate that modularity of middleware architecture is greatly hindered by the wide existence of tangled logic to go one step further we factor out a number of crosscutting concerns identified in the mining process reimplement them as aspects and superimpose them back into the refactored architecture this allows us to use a set of software engineering metrics to quantify the refactorization in terms of changes in the structural complexity modularity and performance of the resulting system this aspect oriented refactoring proves that aspect orientation is capable of composing orthogonal design requirements the final woven system is able to correctly provide both the fundamental functionality and the aspectized functionality with negligible overhead and an overall leaner architecture furthermore the aspectized feature can be configured in and out during compile time which greatly enhances the configurability of the architecture aspect analysis aspect oriented programming aspects middleware refactoring refactoring for generalization using type constraints refactoring is the process of applying behavior preserving transformations called refactorings in order to improve a program s design associated with a refactoring is a set of preconditions that must be satisfied to guarantee that program behavior is preserved and a set of source code modifications an important category of refactorings is concerned with generalization e g extract interface for re routing the access to a class via a newly created interface and pull up members for moving members into a superclass for these refactorings both the preconditions and the set of allowable source code modifications depend on interprocedural relationships between types of variables we present an approach in which type constraints are used to verify the preconditions and to determine the allowable source code modifications for a number of generalization related refactorings this work is implemented in the standard distribution of eclipse see www eclipse org class hierarchy program analysis refactoring subtyping type constraints initial experience with miniature axial flow ventricular assist devices for postcardiotomy heart failure objective the recently introduced impella recover microaxial flow left and right ventricular assist devices l rvad were evaluated as to provide circulatory support in the setting of postcardiotomy heart failure or posttransplant graft failure methods the impella recover 100 lvad is a small 6 4 mm in diameter intracardiac pump which is implanted via a prosthetic graft attached to the ascending aorta and is then advanced into the lv trespassing the aortic valve the recover lvad delivers a continuous blood flow by direct drainage of the lv cavity and ejection of the blood into the ascending aorta the new recover 600 rvad is a small paracardiac pump delivering a continuous blood flow by drainage of the right atrium and blood return to the pulmonary artery by combined use of the two devices biventricular support bvad can be provided between 5 2 and 10 02 the recover lvad has been implanted in six patients 66 ± 11 years of age n 3 70 years with left heart failure following coronary artery bypass procedures in all cases the indication for lvad insertion was heart failure refactory to optimized catecholamine and iabp support preoperative lv function was compromised in all patients lvef 28 ± 12 before the operation one patient presented with chronic lv dysfunction three patients were in cardiogenic shock as a consequence of acute myocardial infarction the world s clinical first use of the recover rvad together with the recover lvad was performed in one male patient with intraoperative graft failure following cardiac transplantation results the recover lvad delivered blood flows up to 5 l min four patients were successfully weaned from the lvad after 169 ± 34 hours in two patients lv function did not recover the latter patients and two of the patients in whom the lvad could be removed died later from multiorgan failure secondary to septicemia the patient with posttransplant graft failure was weaned from the recover bvad after 143 h full recovery of graft function occurred within this time frame the patient however died later as a consequence of intracranial hemorrhage conclusions our initial experience with the impella recover lvad and rvad was favourable in terms of ease of implantation and device removal and simplicity of device control the abundance of additional systemic heparinization and the availability of a zero net flow drive mode during the weaning phase are further distinct advantages of the new support systems cardiogenic shock graft failure heart failure heart transplantation left ventricular assist device myocardial infarction postcardiotomy cardiogenic shock ventricular assist device software systems as complex networks structure function and evolvability of software collaboration graphs software systems emerge from mere keystrokes to form intricate functional networks connecting many collaborating modules objects classes methods and subroutines building on recent advances in the study of complex networks i have examined software collaboration graphs contained within several open source software systems and have found them to reveal scale free small world networks similar to those identified in other technological sociological and biological systems i present several measures of these network topologies and discuss their relationship to software engineering practices i also present a simple model of software system evolution based on refactoring processes which captures some of the salient features of the observed systems some implications of object oriented design for questions about network robustness evolvability degeneracy and organization are discussed in the wake of these findings 2003 the american physical society elemental design patterns a formal semantics for composition of oo software architecture 2003 ieee design patterns are an important concept in the field of software engineering providing a language and application independent method for expressing and conveying lessons learned by experienced designers there is a large gap however between the aesthetic and elegance of the patterns as intended and the reality of working with an ultimately mathematically expressible system such as code we describe a step towards meaningful formal analysis of code within the language of patterns and discuss potential uses the major contributions include a compendium of elemental design patterns edps a layer of seemingly simplistic relationships between objects that on closer inspection provide a critical link between the world of formal analysis and the realm of pattern design and implementation without reducing the patterns to merely syntactic constructs an extension to the σ calculus termed ρ calculus a formal notation for expressing relationships between the elements of object oriented languages and its use in expressing the edps directly we discuss their use in composition and decomposition of existing patterns identification of pattern use in existing code to aid comprehension and future research directions such as support for refactoring of designs interaction with traditional code analysis systems and the education of students of software architecture international workshop on principles of software evolution iwpse the proceedings contain 24 papers the topics discussed include program slicing tool for effective software evolution using aspect oriented technique a model for conformance analysis of software documents beyond the refactoring browser advanced tool support for software refactoring dynamic behavior and protocol models for incremental changes among a set of collaborative objects class refinement for software evolution lightweight prevention of architectural erosion process oriented metrics for software architecture evolvability the chaos of software development stability and volatility in the linux kernel software evolution a distant perspective using coordination contracts for flexible adaptation to changing business rules business rule evolution and measures of business rule evolution and reconstruction of successful software evolution using clone detection architectural refactoring in framework evolution a case study springer verlag berlin heidelberg 2002 the know it all project is investigating methodologies for the development application and evolution of frameworks a concrete framework for database management systems is being developed as a case study for the methodology research the methodology revolves around a set of models for the domain the functionality the architecture the design and the code these models reflect the common and variable features of the domain refactoring of source code has been studied as a preliminary step in the evolution of object oriented software in cascaded refactoring we view framework evolution as a two step process refactoring and extension the refactoring step is a set of refactorings one for each model the refactorings chosen for a model determine the rationale or constraints for the choice of refactorings of the next model there are several issues with respect to architecture that we have encountered and are exploring these include 1 the choice of models for the architecture 2 the design of the architecture and its evaluation 3 the evolution of the architecture by extending the concept of refactoring from source code to architecture and 4 the modeling of variation in architectures across the product line here we focus on the refactoring of the architecture an automated refactoring approach to design pattern based program transformations in java programs 2002 ieee software often needs to be modified to accommodate requirements changes during the software lifecycle to deal with several accidental requirements changes related to software maintenance a systematic and safe approach to modifying software is needed design patterns provide a high degree of design flexibility for such accidental requirements changes in this paper we propose an automated approach to refactoring based on design patterns in java programs in our approach for a particular design pattern we define an inference rule to automatically identify a set of candidate spots and a refactoring strategy to transform a candidate spot into the desired design pattern structure a candidate spot may be a class or a set of classes to which design patterns can be applied we believe that our approach would be helpful to maintainers in the sense that much manual analysis of source code can be reduced and the method of automated program transformation preserves behavior of the original program by means of the refactoring technique java software engineering 1st acm sigplan sigsoft international conference on generative programming and component engineering gpce 2002 the proceedings contain 20 papers the special focus in this conference is on generative programming and component engineering the topics include program generation termination and binding time analysis generative programming for embedded systems a specification and scripting language for binary data memoization in type directed partial evaluation a protocol stack development tool using generative programming building composable aspect specific languages with logic metaprogramming architectural refactoring in framework evolution towards a modular program derivation via fusion and tupling generative programming for embedded software a framework for the detection and resolution of aspect interactions bridging the gap between implementation and design program termination analysis in polynomial time generators for synthesis of qos adaptation in distributed real time embedded systems optimizing content management system pipelines component based programming for higher order attribute grammars altering java semantics via bytecode manipulation meta programming with concrete object syntax and managing dynamic changes in multi stage program generation systems producing reusable object oriented components a domain and organization specific perspective developing reusable object oriented software requires a designer to determine how to structure a software system so as to achieve the necessary functionality while at the same time increasing the reuse potential of the software we introduce a set of reusability metrics intended to be iteratively applied during the design and implementation parts of the software life cycle to help guide the production and identification of reusable components component identification centers on the application s domain with reuse focusing specifically on an organization s future systems our approach requires the developer to subjectively categorize classes identify component boundaries and specify where components are related our metrics provide reuse valuations on the couplings between components based upon the results of applying our metrics we provide refactoring guidelines to increase the separation between components in a manner that improves component reusability we include an application of our metrics to a commercial object oriented framework component based engineerin quantification and metrics reuse process automated method extraction refactoring by using block based slicing refactoring improves the design of existing code but is not complex to do by hand this paper proposes a mechanism that automatically refactors methods of object oriented programs by using program slicing to restructure a method without changing its observable behavior the mechanism uses block based slicing that does not extract the fragments of code from the whole program but from the region consisting of some consecutive basic blocks of the program a refactoring tool implementing the mechanism constructs a new method that contains the extracted code and re forms the source method that contains the remaining code and statements indispensable for executing it with this tool a programmer indicates only a variable of interest in the code that he she wants to refactor and then selects a suitable method from among the candidates created by the tool the programmer does not have to test the refactored code since the mechanism is based on data and control flow analysis thus the tool enables programmers to avoid manual refactoring whose process is error prone and time consuming metrics for applying gof design patterns in refactoring processes this paper presents a kind of software design measures that help us to determine the application of gang of four design patterns to refactoring processes refactoring using design patterns is one of the promising approaches to improve the designs during development activities and a crucial issue is to identify when where and which patterns could be applied we analyzed several actual object oriented designs of low quality needed to be refactored and focus on the characteristics of conditional statements of methods and inheritance structures which seemed to cause the low quality we provide 20 measures to objectively detect these characteristics in object oriented designs these measures express the complexity of branching execution in conditional statements and the strength of the dependency among the sub classes in the inheritance trees designers can be guided to recognize when where and which design patterns should be used in order to refactor their designs of low quality by calculating these measures we apply our approach to the low quality design of the drawing editor that was produced by a novice designer and assess the effectiveness of our measures design pattern meta model refactoring software metrics evolving object oriented designs with refactorings refactorings are behavior preserving program transformations that automate design evolution in object oriented application three kinds of design evolution are schema transformation design pattern microarchitectures and the hot spot driven approach this research shows that all three are automatable with refactorings a comprehensive list of refactorings for design evolution is provided and an analysis of supported scheme transformations design patterns and hot spot meta patterns is presented further we evaluate whether refactoring technology can be transferred to the mainstream by restructuring non trivial c applications the applications that we examine were evolved manually by software engineers we show that an equivalent evolution could be reproduced significantly faster and cheaper by applying a handful of general purpose refactorings in one application over 14k lines of code were transformed automatically that otherwise would have been coded by hand our experiments identify benefits limitations and topics of further research related to the transfer of refactoring technology to a production environment using transformation systems for software maintenance and reengineering software maintenance costs dominate software engineering costs partly because most such engineering is done manually program transformation tools leverage an engineer provided base of transforms a kind of generative reuse of programming knowledge to automate analysis modification and generation of software enhancing productivity and quality over conventional methods this tutorial provides a complete overview of program transformation from theory to implementation to application several real transformation systems will be examined with application examples including automated detection and removal of duplicate code from large systems and the potential for semi automated refactoring of large object frameworks the tutorial progresses from introductory to intermediate but all the necessary background will be provided so attendees need only basic software engineering knowledge and motivating experience modifying software refactoring tool challenges in a strongly typed language this poster examines the challenges of developing a refactoring tool for a weakly typed language such as smalltalk as opposed to a strongly typed language such as java to explore this we will compare the push up field refactoring in each language this refactoring was selected because it is relatively simple conceptually but difficult to implement for java in a weakly typed language such as smalltalk push up field is simple the user simply determines that the parent class needs the variable the refactoring tool moves the field to the parent class then the tool searches all the subclasses of the parent class if the classes have a variable with the same name the refactoring tool removes the variable from the subclass the task is complete for java a description of classes and types is necessary let s start with a base class a a has a number of child classes b c d e f and g each of b g has a single instance variable named var the only difference between the classes is the type of var b and c both have a variable named var with type x d has a variable named var with a type y e has a variable named var with type w f has a variable named var with a type of z and g has a variable named var with the type int w x y and z are classes w is the base class x is a subclass of w and y is a subclass of x z is unrelated to all of the other classes since all subclasses of a have a variable named var a programmer might suspect that they could reduce the amount of code by moving the variable into the parent class a let s move the field named var from class b into class a like in smalltalk the java refactoring tool can remove the variable var from b and c since the var variable in both classes have the same type the source file for a would get the declaration of type x named var the source file for a might also gain an import for the type x let s postpone the discussion of the scope of the variable var the refactoring tool can remove var from d since the storage in a is sufficient however the impact on the source code depends on whether there is a difference between the interface of x and y if there are methods or fields added in y that are not in x then by removing the variable var from d the refactoring tool must be sure to cast var back to a y in code that refers to var in a way that accesses the differences for instance if x and y have a method m then in d the invocation var m remains unchanged if y has a method n and no similar method is present in x or a parent class of x then d must change the code that looks like var n to y var n the refactoring tool cannot remove var from e since a variable of type w can not be stored in a class x a refactoring tool might change the type of the object in class a to w the effect of casting var to an x or a y type would be more widespread to remove var from f the refactoring tool would need to change the variable var s type to object since object is the base class for all classes thus would be a common storage type for ws and zs everywhere that var is used in any source files it must be cast to the appropriate type eliminating the benefit of compile time type checking removing var from g is even more difficult since a primitive type such as int does not derive from object the refactoring tool must find a way to store var for g java provides a series of immutable types that store the primitive types i e java lang integer to access the variable s value var would be replaced with var intvalue to set var the tool would create a new instance of the integer class and assign it to var since multithreaded programming is encouraged any operation that replaces an atomic action with a series of steps must be considered very carefully in this instance the assignment of a value to var is atomic but now includes the creation of an integer object followed by an assignment object instantiation is not atomic therefore if might be necessary to wrap the assignment of var in an appropriate synchronized block synchronized blocks are computationally very expensive and should not be used indiscriminately therefore an automated tool should not remove the variable var from g as a result of pushing var from b to a instead a refactoring tool might recommend renaming the variable var in g 2000 acm finding refactorings via change metrics reverse engineering is the process of uncovering the design and the design rationale from a functioning software system reverse engineering is an integral part of any successful software system because changing requirements lead to implementations that drift from their original design in contrast to traditional reverse engineering techniques which analyse a single snapshot of a system we focus the reverse engineering effort by determining where the implementation has changed since changes of object oriented software are often phrased in terms of refactorings we propose a set of heuristics for detecting refactorings by applying lightweight object oriented metrics to successive versions of a software system we validate our approach with three separate case studies of mature object oriented software systems for which multiple versions are available the case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system metrics object oriented frameworks refactoring reverse engineering software evolution finding refactorings via change metrics reverse engineering is the process of uncovering the design and the design rationale from a functioning software system reverse engineering is an integral part of any successful software system because changing requirements lead to implementations that drift from their original design in contrast to traditional reverse engineering techniques which analyse a single snapshot of a system we focus the reverse engineering effort by determining where the implementation has changed since changes of object oriented software are often phrased in terms of refactorings we propose a set of heuristics for detecting refactorings by applying lightweight object oriented metrics to successive versions of a software system we validate our approach with three separate case studies of mature object oriented software systems for which multiple versions are available the case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system 2000 acm metrics object oriented frameworks refactoring reverse engineering software evolution stage value predictors and efficient newton iterations in implicit runge kutta methods the prediction of stage values in implicit runge kutta methods is important both for overall efficiency as well as for the design of suitable control strategies for the method the purpose of this paper is to construct good stage value predictors for implicit methods and to verify their behavior in practical computations we show that for stiffly accurate methods of low stage order it is necessary to use several predictors in other words a continuous extension for the method will not yield the best results we also investigate how to gain additional efficiency in the newton iterations used to correct the prediction error this leads to new control strategies with respect to refactorization of jacobians that seek to globally minimize total work per unit time of integration 1998 society for industrial and applied mathematics control strategies convergence implicit runge kutta newton iteration predictors the potential role of glycine 160 of human o sup 6 sup alkylguanine dna alkyltransferase in reaction with o sup 6 sup benzylguanine as determined by site directed mutagenesis and molecular modelling comparisons o 6 alkylguanine dna alkyltransferase atase repairs toxic mutagenic and carcinogenic o 6 alkylguanine o 6 alkg lesions in dna by a highly conserved reaction involving the stoichiometric transfer of the alkyl group to the active centre cysteine residue of the atase protein in the escherichia coli ada atase which is effectively refactory to inhibition by o 6 benzylguanine o 6 bzg the residue corresponding to glycine 160 g160 for the mammalian proteins of this class is replaced by a tryptophan w therefore to investigate the potential role of the g160 of the human atase hat protein in determining sensitivity to o 6 bzg site directed mutagenesis was used to produce a mutant protein hatg160w substituted at position 160 with a w residue the hatg160w mutant was found to be stably expressed and was 3 and 5 fold more sensitive than hat to inactivation by o 6 bzg in the absence and presence of additional calf thymus dna respectively a similar dna dependent increased sensitivity of the hatg160w mutant relative to wild type was also found for o 6 methylguanine mediated inactivation the potential role of the w160 residue in stabilising the binding of the o 6 alkg to the protein is discussed in terms of a homology model of the structure of hat the region occupied by g w 160 forms the site of a putative hinge that could be important in the conformational change that is likely to occur on dna binding three sequence motifs have been identified in this region which may influence o 6 bzg access to the active site ysgg or ysggg in mammals yagg in e coli ogt yags in dat from bacillus subtilis yrwg in e coli ada and salmonella typhimurium but ykws in saccharomyces cerevisina or yrggf in adab from b subtilis finally conformational and stereoelectronic analysis of the putative transition states for the alkyl transfer from a series of inactivators of hat including o 6 bzg was undertaken to rationalise the unexpected weak inhibition shown by the α π unsaturated electrophiles atase dna receptor o alkylguanine 6 o benzylguanine 6 o methylguanine 6 tool support for object oriented patterns springer verlag berhn heidelberg 1997 a software design pattern describes a general solution for a recurring design problem the solution is mostly described in terms of an abstract design structure expressed in design elements such as classes methods and relationships inheritance associations this paper describes a prototype tool that supports working with design patterns when developing or maintaining object oriented programs the tool provides three integrated views on a program the code classes methods etc a design view abstraction of the code plus additional information not in the code and occurrences of design patterns in the program the tool assists developers using patterns in three ways ● generating program elements e g classes hierarchies for a new instance of a pattern taken from an extensible collection of template patterns ● integrating pattern occurrences with the rest of the program by binding program elements to a role in a pattern e g indicating that an existing class plays a particular role in a pattern instance ●checking whether occurrences of patterns still meet the invariants governing the patterns and repairing the program in case of problems through the use of an existing refactoring package the tool supports the use of patterns both in forward engineering and in backwards engineering i e documenting occurrences of patterns in existing programs and modifying the program to better reflect the pattern s structure the tool is implemented in smalltalk and has been applied to identify pattern occurrences in several non trivial smalltalk applications and to reorganize these subsequently proceedings of the 11th acm sigplan conference on object oriented programming systems languages and applications oopsla 1996 the proceedings contain 26 papers the topics discussed include perspectives on reuse the basic object system supporting a spectrum from prototypes to hardened code a situated evaluation of the object management group s omg object management architecture oma lessons learned from implementing the corba persistent object service slicing class hierarchies in c creating host compliance in a portable framework a study in the reuse of design patterns an equational object oriented data model and its data parallel query language a monotonic superclass linearization for dylan vortex an optimizing compiler for object oriented languages a flexible operation execution model for shared distributed objects split objects a disciplined use of delegation within objects code reuse in an optimizing compiler a functional layer for description logics knowledge representation meets object oriented programming automatic inheritance hierarchy restructuring and method refactoring the direct cost of virtual function calls in c soft issues and hard problems in software development oo anthropology crossing the chasm simple and effective analysis of statically typed object oriented programs reuse contracts managing the evolution of reusable assets on automatic class insertion with overloading and change cases use cases that identify future requirements quasi real time dynamic simulation for dispatcher training simulator dts of east china power system this paper proposes the simulation models and algorithm of quasi real time dynamic simulation for dispatcher training simulator dts of east china power system to increase the simulation speed without sacrificing the simulation accuracy the dynamic behavior of the system is divided into transient and mid long term modes while artificial damping term is introduced to realize the smooth transition from one mode to the other adaptive reference frames and variable step sizes are employed for further increasing the simulation speed in addition fast topology algorithm based on width priority that can keep track with random switching operations and fast refactorization method based on sparse techniques used in this software package are also presented case studies of east china power system verify the validity of the above mentioned measures clinical implications of pleomorphic ventricular tachycardias on oral sotalol therapy in 90 consecutive patients with coronary artery disease and sustained monomorphic ventricular tachycardia who were treated with oral sotalol and underwent programmed stimulation to determine drug effectiveness the influence of sotalol on induced ventricular tachycardia morphology was retrospectively examined in 54 patients 60 sotalol rendered the tachycardia non inducible however contrary to drug testing with class i antiarrhythmic agents induction of multiple morphologies at baseline study did not predict failure of subsequent drug testing with sotalol in the remaining 36 patients 40 in whom sotalol did not modify inducibility 21 patients i e a total of 23 manifested at least one new morphology during electropharmacological testing on sotalol this effect was independent of the degree of left ventricular dysfunction infarct location and numbers of morphologies at baseline but corresponded with drug induced changes in refactoriness this observation may be related to a proarrhythmic effect of sotalol slowing of ventricular tachycardia rate and changes in morphology may have implications in patients receiving implantable cardioverter defibrilators or those undergoing ablative procedures drug testing pleomorphism refractoriness sotalol ventricular tachycardia binding objects to scenarios of use scenarios are a natural and effective medium for thinking in general and for design in particular our work seeks to develop a potential unification between recent scenario oriented work in object oriented analysis design methods and scenario oriented work in the analysis design of human computer interaction we illustrate this perspective by showing 1 how scenario questioning can be used to systematically interrogate the knowledge and practices of potential users and thereby to create object oriented analysis models that are psychologically valid 2 how depicting an individual object s point of view can serve as a pedagogical scaffold to help students of object oriented analysis see how to identify and assign object responsibilities in creating a problem domain model and 3 how usage scenarios can be employed to motivate and coordinate the design implementation refactoring and reuse of object oriented software 1994 academic press inc a timing model for the revised simplex method it is shown that the time spent in a widely implemented version of the revised simplex method for linear programming can be modeled as the classic inventory control system using an economic order quantity eoq formula an approximation to the optimal frequency for basis refactorization can be inferred such timing models can be used to significantly reduce the cost of routine applications as well as to predict the performance of new variants of the algorithm 1993 computational mathematical programming linear programming simplex method iterative bad data suppression applied to state estimators based on the augmented matrix method the augmented matrix method for power system state estimation combines simple conception good numerical behavior and computational efficiency concerning bad data processing however the method presents a difficulty the calculation of normalized residuals is not straightforward so that the implementation of conventional bad data identification procedures may become complicated this paper presents a technique for bad data processing based on weighted residuals and a nonquadratic cost function to circumvent that problem the weighted residuals are immediately available from the proposed formulation for the augmented matrix method the non quadratic cost function is piecewise quadratic constant and the break points are varied through the iterations to allow proper bad data identification the application of a diakoptical technique avoids the need for costly refactorizations of the augmented matrix the results from simulation studies carried out with the ieee 14 bus and 30 bus test systems are presented 1991 compensation technique for q limit enforcements in a constant complex jacobian power flow model this paper presents a simple and efficient compensation technique to deal with bus type switchings associated with q limit enforcements at voltage controlled pv buses in a constant jacobian power flow model the jacobian is expressed in the complex variable form resulting in reduced storage requirements as compared to real form of representation of the jacobian the structure of the jacobian is preserved irrespective of bus type switchings while q limit enforcements are performed at the pv buses this feature permits implementation of optimal ordering of buses in an efficient way while factorizing the jacobian matrix the jacobian is held constant throughout the load flow solution process incremental secondary injections isis are provided at the respective pv buses to maintain the specified voltages the required injections are computed from the proposed compensation model results indicate that the proposed technique is quite efficient as the number of iterations for solution to converge irrespective of bus type switchings remains same as that in unadjusted solution case because of its simplicity and efficiency the proposed model could become an alternative to the technique of matrix refactorization dealing with such problems of q limit enforcements associated with bus type switchings in constant matrix power flow methods the proposed model is tested on several power systems and the results are highly encouraging 1990 by hemisphere publishing corporation computing karmarkar projections quickly the paper presents a numerical method for computing the projections for karmarkar s new algorithm for linear programming the method is simple to implement fully exploits sparsity and appears in limited experimentation to have good stability properties preliminary numerical experience indicates that the method promises advantages over methods that refactor a matrix at every iteration 1988 the mathematical programming society inc cholesky factorization karmarkar s method linear programming rank one updates determination of the thermal conductivity of ceramics by the hot wire technique the thermal conductivity lambda of magnesium oxide based refractories was determined by the hot wire technique over the temperature range from 300 to 1000 degree c the results exhibit an error not exceeding the systematic error of this method plus or minus 10 percent the standard unit used for such measurement was improved by adding a high accuracy temperature regulator to the constant temperature maintenance system this reduced the time required for temperature stabilization in successive runs by a factor of 3 to 4 the experimental results were correlated by formulas which can be used in practical calculations of thermal conductivities of refactories in the above temperature range tests of refractoriness and conduction during clinical electrophysiologic studies yields and roles relationships between refractoriness and conduction and the likelihood of obtaining results from these tests have not been reported in detail in patients undergoing clinically indicated electrophysiologic testing therefore attempts were made in 100 such patients to determine the effective and functional refractory periods erp frp of the atrium atrioventricular av node and specialized ventricular conduction system during sinus rhythm and atrial pacing conduction was tested using incremental ramp atrial pacing to facilitate comparison of conduction and refractoriness effective and functional conduction periods ecp fcp were defined ecp longest pacing cycle length failing to conduct and fcp shortest conducted cycle length one or more determinations of atrial refractoriness were possible in 95 subjects but no measurable atrial conduction end points were attained in contrast av nodal erps or frps could be determined in only 47 using the extrastimulus technique in spite of multiple atrial drive pacing rates av nodal ecps and fcps could be determined in all 100 patients using ramp pacing comparison of atrial erps and frps in patients in whom av nodal refractoriness could and could not be determined showed no significant differences patients in whom it was not possible to determine av nodal erps and frps had shorter ecps and fcps than other patients thus inability to determine av nodal refractory periods was caused by prior atrial refractoriness atrial frp longer than av nodal erp block or refactoriness in the atrium or av node prevented detailed evaluation of the ventricular specialized conduction system in all but a few subjects av nodal ecps correlated with erps but were longer fcps also correlated but were shorter than the frps the maximum av node delay ah interval was the same with ramp pacing and extrastimulus testing during atrial pacing in the high right atrium refractory period testing is more useful than rapid pacing for evaluation of av nodal function particularly in large groups of patients such as those undergoing drug studies conduction testing will provide more nearly universal data than testing for refractoriness neither method is able to provide routine assessment of the ventricular specialized conduction system the factor structure and internal consistency of the self concept and motivation inventory what face would you wear preschool kindergarten form the self concept and motivation inventory what face would you wear preschool kindergarten form has the potential to be of use in measuring the academic self concept of preschoolers this study sought to determine if the theoretical three factor structure of the scamin could be recovered in a state wide sample of kindergarten students in 1986 5742 kindergarteners from tennessee schools participating in the reduced pupil teacher ratio project were given the preschool kindergarten form of the scamin the sample was drawn from 42 school districts in all geographic regions of tennessee and represented a mix of inner city urban rural and suburban schools the intercorrelation matrix of the 24 scamin items was analyzed by the principal components method and extracted factors were rotated to a varimax solution an initial analysis suggested the presence of an atheoretical factor and two items which appeared to be unrelated to any obtained factor subsequent refactoring of the scamin resulted in the successful recovery of the expected three factor structure cronbach s alpha for the scales academic self concept achievement investment and achievement needs were 0 666 0 599 and 0 598 respectively the results of this factor analysis of the early preschool kindergarten form of the scamin suggest both strengths and weaknesses in the factorial composition of the 24 scamin items users of the scamin are cautioned against a naive application of this instrument s scales 1988 sage publications all rights reserved partial matrix refactorization partial refactorization methods update the ldu factors of a matrix to reflect changes in some its elements this paper presents two new partial refactorization methods for sparse matrices test results indicate that they are significantly more efficient than existing techniques and have the potential to speed up a number of important power system problems copyright 1986 by the institute of electrical and electronics engineers inc partial matrix refactorization partial refactorization methods update the ldu factors of a matrix to reflect changes in some of its elements this paper presents two new partial refactorization methods for sparse matrices test results indicate that they are more efficient than existing techniques and have the potential to speed up a number of important power system problems sparse matrix factor modification in structural reanalysis structural reanalysis problems such as in nonlinear finite element analysis or optimum design involve progressive changes in the global stiffness matrix and its matrix factors although many studies have been devoted to the subject of matrix factor modification most investigations have dealt with the problem separately from sparse matrix methods this paper introduces a graph‐theoretic model for the forward solution procedure which is applicable for identifying the modified entries of the matrix factors due to changes in the original matrix applications of this graph‐theoretic model to existing refactorization methods are presented the relation between substructuring and sparse matrix ordering strategies and their effects on reanalysis are discussed modification of a sparse matrix associated with an n × n finite element grid ordered by the nested dissection scheme is analysed copyright 1985 john wiley sons ltd refractory arrhythmias invasive diagnosis and treatment the term refactory in relation to cardiac arrhythmias is defined and the method of electrophysiologic investigation of arrhythmias presented two modes of invasive arrhythmia treatment are available which afford favorable results namely tachycardia pacemaker and surgery indications for each of these procedures are discussed electron microscopic examination of the dissolution behavior of fusion cast glass furnace blocks 1 investigation of diffusion in a simple model system a detailed analysis of the corrosion of both traditional and fusion cast refactories is made difficult by the interaction of complex processes such as diffusion and convection a simple laboratory method has therefore been developed to determine by electron microprobe concentration distributions in the contact zone when there is exchange by diffusion without convection because convection is eliminated the method allows the properties of the glass refractory interface at the beginning of the experiment to be evaluated and the dissolution layer of the refractory to be measured to gain a better knowledge of the sodium enrichment occurring at the glass refractory interface diffusion experiments have been made with a simple model system comprising a sodium silicate glass and an alumina rich glass similar to the glassy phase in fusion cast refractories experimental results are presented in microphotographs and discussed the factorial structure of responses to perceptual complexity a series of figures differing in complexity were exposed to 44 nursing students ss were monitored for gsr and heart rate while they looked at each figure for as long as they wished they then rated each figure on 20 semantic differential type scales the data were factor analyzed by the principal axis method with communalities iterated by refactoring followed by varimax rotation four factors were extracted and the first three were identified as osgood s activity evaluative and potency factors it was suggested that the activity factor relates to arousal raising stimulus properties while the evaluative factor relates to arousal reducing or restraining stimulus properties 1971 psychonomic journals inc all rights reserved the measurement of speed in motor performance when the centroid method of factor analysis was applied to two sets of data on athletic performances three significant factors emerged strength velocity and dead weight scores on this speed factor were predicted by the multiple regression technique the factor loadings on the speed factor being used as the criterion correlations and these predicted scores were correlated with each of the other variables when the original tables augmented by the new speed variable were refactored the computed speed factor fell on the speed axis as a primary trait it is thus shown that it is possible to isolate and measure a factor which appears in variables under consideration only as a compound 1940 psychometric society hierarchical clustering for adaptive refactorings identification this paper studies an adaptive refactoring problem it is well known that improving the software systems design through refactoring is one of the most important issues during the evolution of object oriented software systems we focus on identifying the refactorings needed in order to improve the class structure of a software systems in an adaptive manner when new application classes are added to the system we propose an adaptive clustering method based on an hierarchical agglomerative approach that adjusts the structure of the system that was established by applying a hierarchical agglomerative clustering algorithm before the application classes set changed the adaptive method identifies more efficiently the refactorings that would improve the structure of the extended software system without decreasing the accuracy of the obtained results an experiment testing the method s efficiency is also reported a survey on search based software design this survey investigates search based approaches to software design the basics of the most popular meta heuristic algorithms are presented as background to the search based viewpoint software design is considered from a wide viewpoint including topics that can also be categorized as software maintenance or re engineering search based approaches have been used in research from the high architecture design level to software clustering and finally software refactoring enhancing and predicting software quality with search based methods is also taken into account as a part of the design process the background for the underlying software engineering problems is discussed after which search based approaches are presented summarizing remarks and tables collecting the fundamental issues of approaches for each type of problem are given the choices regarding critical decisions such as representation and fitness function when used in meta heuristic search algorithms are emphasized and discussed in detail ideas for future research directions are also given 2010 elsevier inc search algorithms search based software engineering software design software quality assure high quality code using refactoring and obfuscation techniques nowadays software refactoring techniques are widely adopted to enhance the quality of software by improving its understandability performance as well as other quality related design attributes on the other hand various kinds of software obfuscation methods have been proposed to protect security sensitive information involved in software implementations this paper analyzes how refactoring and obfuscation use reverse transformations to improve quality and security of software code and proposes a systematic modeling approach based on i to support the selection of refactoring techniques and obfuscation methods under different social environmental and operational situations first top level softgoals guiding designer s decision making are identified and analyzed next accidental programming bad smells and intentional code cracker s threats to these softgoals are identified and analyzed then refactoring and obfuscation transformations are modeled as countermeasures for these threats eventually their reversal relations and counteracting patterns are examined using example code segments 2010 ieee i obfuscation refactoring software quality the conan tool to identify crosscutting concerns in object oriented systems this paper presents the main features of conan a tool supporting an approach to find scattered and tangled class members in oo systems and to group them in concerns the recovered information is useful for refactoring migration tasks such as towards aspect oriented programming aop 2010 ieee incremental refactoring using seeds refactoring is one major issue to improve the design of software systems increasing the internal software quality it is a disciplined technique for improving the structure of existing code without changing its observable behaviour we have previously introduced a clustering based approach for identifying refactorings in an object oriented software system essentially it takes the existing software system and restructure it using a k means based clustering algorithm kred in order to obtain a better design but in time the software system evolves and new application classes are added for implementing new functional requirements we propose in this paper a k means based incremental clustering method incremental refactoring using seeds irus that is capable to re partition the existing software system when new application classes are added to it the method starts from the clusters obtained by applying kred before the software system s extension the result is reached more efficiently than running kred again from the scratch on the extended software system an experimental evaluation proving the method s efficiency is also reported clustering incremental refactoring software engineering inferring design patterns using the rep graph periodic refactoring of a large source code often becomes a necessity especially for long lived projects in order to increase maintainability and extensibility of such projects design pattern based refactoring can be seen as an emerging alternative manual inspection of source code to find candidate spots where patterns can be introduced is time consuming therefore automated tools can help in identifying candidate spots where patterns can be introduced the level of source code abstraction plays an important role for building such tools we propose a new abstraction for object oriented source code that is named as refactoring pattern rep graph to realize an effective design pattern based refactoring tool the rep graph abstracts the source code information thereby making the process of design pattern inference easier the proposed tool identifies candidate spots in a given source code to introduce design patterns jot 2010 design pattern design pattern inference abstracting abstract machines we describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well established abstract machines to demonstrate the technique and support our claim we transform the cek machine of felleisen and friedman a lazy variant of krivine s machine and the stack inspecting cm machine of clements and felleisen into abstract interpretations of themselves the resulting analyses bound temporal ordering of program events predict return flow and stack inspection behavior and approximate the flow and evaluation of by need parameters for all of these machines we find that a series of well known concrete machine refactorings plus a technique we call store allocated continuations leads to machines that abstract into static analyses simply by bounding their stores we demonstrate that the technique scales up uniformly to allow static analysis of realistic language features including tail calls conditionals side effects exceptions first class continuations and even garbage collection copyright 2010 acm abstract interpretation abstract machines on the use of genetic programming for automated refactoring and the introduction of design patterns maintaining an object oriented design for a piece of software is a difficult time consuming task prior approaches to automated design refactoring have focused on making small iterative changes to a given software design however such approaches do not take advantage of composition of design changes thus limiting the richness of the refactoring strategies that they can generate in order to address this problem this paper introduces an approach that supports composition of design changes and makes the introduction of design patterns a primary goal of the refactoring process the proposed approach uses genetic programming and software engineering metrics to identify the most suitable set of refactorings to apply to a software design we illustrate the efficacy of this approach by applying it to a large set of published models as well as a real world case study copyright 2010 acm design patterns evolutionary computation intelligent search object oriented design refactoring search based software engineering software metrics ecoop 2010 object oriented programming 24th european conference proceedings the proceedings contain 25 papers the topics discussed include detecting missing method calls in object oriented software debugging model transformation failures using dynamic tainting automatically extracting class diagrams from spreadsheets the essence of javascript verifying executable object oriented specifications with separation logic verifying generics and delegates recency types for analyzing scripting languages correct refactoring of concurrent java code programming coordinated behavior in java doubts about the positive impact of static type systems on programming tasks in single developer projects an empirical study a type system for data centric synchronization type safe eventful sessions in java capabilities for uniqueness and borrowing embedding languages without breaking tools self replicating objects for multicore platforms and falling back on executable specifications a type system for data centric synchronization data centric synchronization groups fields of objects into atomic sets to indicate they must be updated atomically each atomic set has associated units of work code fragments that preserve the consistency of that atomic set we present a type system for data centric synchronization that enables separate compilation and supports atomic sets that span multiple objects thus allowing recursive data structures to be updated atomically the type system supports full encapsulation for more efficient code generation we evaluate our proposal using aj which extends the java programming language with data centric synchronization we report on the implementation of a compiler and on refactoring classes from standard libraries and a multi threaded benchmark to use atomic sets our results suggest that data centric synchronization enjoys low annotation overhead while preventing high level data races 2010 springer verlag berlin heidelberg isolating javascript in dynamic code environments we analyze the source code of four well known large web applications namelywordpress phpbb phpmyadmin and drupal we want to quantify the level of language intermixing in modern web applications and if possible we want to categorize all coding idioms that involve intermixing of javascript with a server side programming language like php our analysis processes more than half of a million of locs and identifies about 1 000 scripts these scripts contain 163 cases where the source code is mixed in a way that is hard to isolate javascript from php we manually investigate all 163 scripts and proceed in a classification scheme of five distinct classes our analysis can be beneficial for all applications that apply operations in the client side part of a web application various xss mitigation schemes as well as code refactoring and optimization tools copyright 2010 acm javascript web security recommending rename refactorings variable names play a major role in program comprehension however their choice is often subject to the intuition or intention of individual programmers although code conventions and style guides may constrain identifier usage programmers are individuals naming program concepts individually especially if different parts of a program are written by different programmers inconsistent naming of program entities may follow this is unfortunate since consistent naming would aid program comprehension in particular if references pointing to same objects used in similar ways are named equally as a first approach we focus on assignments to discover possible inconsistency of naming exploiting that a variable assigned to another likely points to same objects and if declared with the same type is likely used for the same purpose to explore the feasibility of our approach we implemented a tool recommending rename refactorings to harmonize variable names based on an analysis of assignments and static type information evaluated on some open source projects the results seem promising enough to aim for some extensions such as application to method names inferred type information and weakly type checked languages copyright 2010 acm assignment analysis identifiers rename refactoring variable naming barriers to systematic model transformation testing introduction model driven engineering mde techniques support extensive use of models in order to manage the increasing complexity of software systems appropriate abstractions of software system elements can ease reasoning and understanding and thus limit the risk of errors in large systems automatic model transformations play a critical role in mde since they automate complex tedious error prone and recurrent software development tasks airbus uses automatic code synthesis from scade models to generate the code for embedded controllers in the airbus a380 commercial tools for model transformations exist objecteering and together from borland are tools that can automatically add design patterns in a uml class model esterel technologies have a tool for automatic code synthesis for safety critical systems other examples of transformations are refinement of a design model by adding details pertaining to a particular target platform refactoring a model by changing its structure to enhance design quality or reverse engineering code to obtain an abstract model these software development tasks are critical and thus the model transformations that automate them must be validated a fault in a transformation can introduce a fault in the transformed model which if undetected and not removed can propagate to other models in successive development steps as a fault propagates across transformations it becomes more difficult to detect and isolate since model transformations are meant to be reused faults present in them may result in many faulty models model transformations constitute a class of programs with unique characteristics that make testing them challenging the complexity of input and output data lack of model management tools and the heterogeneity of transformation languages pose special problems to testers of transformations in this paper we identify current model transformation characteristics that contribute to the difficulty of systematically testing transformations we present promising solutions and propose possible ways to overcome these barriers 2010 acm isec 10 proceedings of the 2010 india software engineering conference the proceedings contain 22 papers the topics discussed include a tool for software development driven by customer interaction towards software test data generation using discrete quantum particle swarm optimization a scheme to prioritize classes at the early stage for improving observable reliability proving unreachability using bounded model checking modeling ontologies as executable domain specific languages a desiderata for refactoring based software modularity improvement an application synopsis tool for database applications developed using oracle application express medical software a regulatory process framework experience report a knowledge repository centric approach to performance tuning connectedness testing of restful web services using strong conflicts to detect quality issues in component based complex systems and distributed software development projects work breakdown approaches to overcome key coordination challenges are popular classes more defect prone traces of the evolution of software systems are left in a number of different repositories such as configuration management systems bug tracking systems and mailing lists developers use e mails to discuss issues ranging from low level concerns bug fixes refactorings to high level resolutions future planning design decisions thus e mail archives constitute a valuable asset for understanding the evolutionary dynamics of a system we introduce metrics that measure the popularity of source code artifacts i e the amount of discussion they generate in e mail archives and investigate whether the information contained in e mail archives is correlated to the defects found in the system our hypothesis is that developers discuss problematic entities more than unproblematic ones we also study whether the precision of existing techniques for defect prediction can be improved using our popularity metrics 2010 springer verlag cscout a refactoring browser for c despite its maturity and popularity the c programming language still lacks tool support for reliably performing even simple refactoring browsing or analysis operations this is primarily due to identifier scope complications introduced by the c preprocessor the cscout refactoring browser analyses complete program families by tagging the original identifiers with their precise location and classifying them into equivalence classes orthogonal to the c language s namespace and scope extents a web based user interface provides programmers with an intuitive source code analysis and navigation front end while an sql based back end allows more complex source code analysis and manipulation cscout has been successfully applied to many medium and large sized proprietary and open source projects identifying thousands of modest refactoring opportunities 2009 elsevier b v all rights reserved browser c preprocessor refactoring clustering based adaptive refactoring it is well known that maintenance and evolution represent important stages in the lifecycle of any software system about 66 from the total cost of the software systems development improving the software systems design through refactoring is one of the most important issues during the evolution of object oriented software systems refactoring aims at changing a software system in such a way that it does not alter the external behavior of the code but improves its internal structure in this paper we approach the problem of adaptive refactoring and we propose an adaptive method to cope with the evolving structure of any object oriented application namely we handle here the case when new application classes are added to the software system and the current restructuring scheme must be accordingly adapted the approach proposed in this paper extends our previous clustering based approach for identifying refactorings in an object oriented software system we also provide an example illustrating the efficiency of the proposed approach adaptive refactoring clustering restructuring identification of refactoring opportunities introducing polymorphism polymorphism is one of the most important features offered by object oriented programming languages since it allows to extend modify the behavior of a class without altering its source code in accordance to the open closed principle however there is a lack of methods and tools for the identification of places in the code of an existing system that could benefit from the employment of polymorphism in this paper we propose a technique that extracts refactoring suggestions introducing polymorphism the approach ensures the behavior preservation of the code and the applicability of the refactoring suggestions based on the examination of a set of preconditions 2009 elsevier inc all rights reserved object oriented design polymorphism refactoring state strategy design pattern slice based metrics for identifying refactoring in order to improve the efficiency and accuracy of identifying refactoring an automated refactoring identification technology is presented first a measurement method based on program slicing is constructed to quantify the program dependence between the elements secondly the elements with unreasonable location and affiliation in the original code are identified using measurement results and thus program s bad smell is automatically identified compared with previous manual identification the method can automatically analyze the source code and point out the unreasonable code so the efficiency of refactoring identification is improved it is recommended to change bad smell using the corresponding refactoring which may make the code more reasonable and easier to maintain finally three refactoring examples demonstrate that the method can identify some objects of refactoring which verify the feasibility of the method control function distance function metrics program slicing refactoring identification the theory of relative dependency higher coupling concentration in smaller modules recent studies have repeatedly found that smaller modules are proportionally more defect prone in this article the authors formulate and test a hypothesis stating that smaller modules are proportionally more coupled given that dependencies caused by coupling have been consistently associated with defect proneness strong evidence supports this hypothesis furthermore refactoring exacerbates this effect on the basis of this study s highly consistent results the authors state the empirically based theory of relative dependency that is in large scale software systems smaller modules will be proportionally more dependent compared to larger ones these findings have two implications for practice first we now have an empirically supported mechanism explaining the observations that defect concentration is higher in smaller modules practitioners can use this mechanism as evidence while seeking resources and support to revise or amend their organizations quality assurance and quality control practices second particularly for the projects that refactor extensively such as those using agile methods focusing defect detection activities on smaller modules will increase their efficiency and effectiveness even more 2010 ieee product metrics restructuring reverse engineering software engineering software maintainability software metrics and measurement software quality software quality assurance software science sqa validation and verification object oriented program method level clone detection based on similarity measurement code clone detection is important for refactoring and extraction of reusable assets the present code clone detection method is on the basis of detection of similar code segments which brings difficulty for further clone analysis and refactoring aiming at this problem this paper offers a method level clone detection method for object oriented program based on similarity measurement which detects method level cloned code our method utilizes comments of the code method signature and syntactic similarity to measure the degree of the clone based on the method mentioned above further refactoring can be realized by combining similar methods of sub classes into one method and pulling it up into super class our method s effectiveness has been verified by analyzing the result of the experiment on the code of jdk the initial experiment result shows that our method can help developer detect method level code clone both accurately and effectively clone detection code clone object oriented refactoring reverse engineering capabilities and roles of enterprise wikis in organizational communication purpose the article alerts technical communicators to wiki technology an emerging new medium that allows dispersed groups to create shared content via collaborative editing and different time communication wiki based collaborative content creation enables new communication practices and thereby challenges several assumptions of existing media choice theories method analysis of empirical evidence from 32 published case descriptions and reports to evaluate wiki technology in a corporate context based on the defining characteristics of three media choice theories i e media richness theory theory of media synchronicity and common ground theory results wikis meet or exceed capabilities of several other communication and collaboration media and thus provide a credible alternative to other business communication technologies currently in use further distinct media capabilities of wikis are not fully represented by current media choice theories suggesting the need to extend media choice theories to recognize these unique capabilities conclusion the unique features of enterprise wikis enable new collaboration practices and challenge some of the core theoretical assumptions of media choice theories the refactoring capability of wikis is identified as a unique feature that enables new forms of collaboration and communication in organizations an implementation that wishes to successfully leverage wiki enabled collaboration opportunities must carefully consider challenges of human interaction such as free riding or conflict of values business communication collaborative writing content refactoring media capability wiki system evolution at the attribute level an empirical study of three java oss and their refactorings in this paper we focus on the net changes in attributes across versions of oss and use net class change data class additions and deletions as well as refactoring data from a previous study to inform our understanding of how those three systems evolved as they did while the majority of new attributes were added at levels 1 and 2 of the inheritance these patterns were not consistent the research question addresses the evolutionary relationship between classes and attributes as well as the connection between those changes and refactorings although some evidence of attributes following patterns conformant with class additions was found we also identified occurrences of attributes being added unilaterally a strong correspondence was also found between attribute addition and the refactoring data finally we explore features of a fourth system with seven inheritance levels for similar characteristics attribute evolution oo refactoring pro php refactoring many businesses and organizations depend on older high value php software that risks abandonment because it is impossible to maintain the reasons for this may be that the software is not well designed there is only one developer the one who created the system who can develop it because he didn t use common design patterns and documentation or the code is procedural not object oriented with this book you ll learn to identify problem code and refactor it to create more effective applications using test driven design copyright 2010 by francesco trucchia and jacopo romei all rights reserved software refactoring at the function level using new adaptive k nearest neighbor algorithm improving the quality of software is a vital target of software engineering constantly evolving requirements force software developers to enhance modify or adapt software thus increasing internal complexity maintenance effort and ultimately cost in trying to balance between the needs to change software maintain high quality and keep the maintenance effort and cost low refactoring comes up as a solution refactoring aims to improve a number of quality factors among which is understandability enhancing understandability of ill structured software decreases the maintenance effort and cost to improve understandability designers need to maximize cohesion and minimize coupling which becomes more difficult to achieve as software evolves and internal complexity increases in this paper we propose a new adaptive k nearest neighbor a knn algorithm to perform clustering with different attribute weights the technique is used to assist software developers in refactoring at the function method level this is achieved by identifying ill structured software entities and providing suggestions to improve cohesion of such entities we also compare the proposed technique with three function level clustering techniques single linkage algorithm slink complete linkage algorithm clink and weighted pair group method using arithmetic averages wpgma a knn showed competitive performance with the other three algorithms and required less computational complexity clustering code restructuring cohesion function level cohesion software quality software refactoring agile processes in software engineering and extreme programming 11th international conference xp 2010 proceedings the proceedings contain 56 papers the topics discussed include extending refactoring guidelines to perform client and test code adaptation security testing in agile web application development a case study using the east methodology adoption of team estimation in a specialist organizational environment extreme product line engineering refactoring for variability a test driven approach towards understanding communication structure in pair programming applying scrum in an oss development process an empirical evaluation understanding the importance of trust in distributed agile projects a practical perspective introducing agile methods in a large software development team the developers changing perspective structuring complexity issues for efficient realization of agile business requirements in distributed environments and adoption of software engineering process innovations the case of agile software development methodologies the evolution and impact of code smells a case study of two open source systems code smells are design flaws in object oriented designs that may lead to maintainability issues in the further evolution of the software system this study focuses on the evolution of code smells within a system and their impact on the change behavior change frequency and size the study investigates two code smells god class and shotgun surgery by analyzing the historical data over several years of development of two large scale open source systems the detection of code smells in the evolution of those systems was performed by the application of an automated approach using detection strategies the results show that we can identify different phases in the evolution of code smells during the system development and that code smell infected components exhibit a different change behavior this information is useful for the identification of risk areas within a software system that need refactoring to assure a future positive evolution 2009 ieee refactoring uml models using openarchitectureware to measure uml model quality and perform pattern matching on uml models with ocl queries in object oriented software development the unified modeling language uml 20 has become the de facto modeling standard uml plays an important role for software factories in which a high quality abstract uml model is the primary source of input used to generate a working system while there are many tools that enable assisted refactoring of source code there are few tools that enable assisted refactoring of uml models in order to determine uml model quality for uml models used in code generation projects a selection of quality metrics has been made while there are a large number of metrics available to determine code quality there are only a limited number of metrics applicable to uml models most model quality metrics have been derived from code quality metrics 16 syntactic and semantic model check rules have been implemented that allow detection of undesirablemodel properties the syntactic model checkers have been derived directly from the uml specification the semantic model checkers have been derived from a range of anti pattern descriptions we have delivered a prototype that detects undesirable model features in order to test the model improvement capabilities the prototype contains selected model quality metrics syntactic and semantic model check rules both metrics and rules have been formulated in the object constraint language ocl 21 which operates on uml models the system is built using open source tools allowing easy extensions of the prototype the effects of suggested repair actions on the model are measurable through the selected model quality metrics and by subjective comparison the prototype was able to improve model quality for four industry models both by metrics and subjective comparison copyright 2009 acm metrics model quality ocl semantic rules syntactic rules uml improving safety when refactoring aspect oriented programs checking correctness with respect to a formal semantics is expensive thus the refactoring tools are commonly implemented in an ad hoc way and may perform transformations that do not preserve behavior the problem becomes still worse when we consider refactoring aspect oriented ao programs we present a practical technique for increasing confidence on whether a given transformation applied to an ao program preserves behavior this technique was evaluated against 12 transformations performed in eclipse which intended to be refactorings it detected that 91 of them do not preserve behavior a second evaluation was accomplished with a 65 kloc real case study containing 475 classes it is implemented in java and was refactored to aspectj both versions are intended to be equivalent but our technique detected a behavioral change aspect oriented programming detecting behavioral changes refactoring the 3rd acm workshop on refactoring tools wrt 09 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of specific transformations that need to be performed tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial program analysis and applying the transformations may affect many locations throughout a program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in modern day ides until recently there has not been a suitable forum for discussions among researchers and developers of such tools our prior refactoring tools workshops initially at ecoop 2007 then at oopsla 2008 clearly met a need and there was strong interest expressed in holding a follow on workshop this workshop features both presentations given by developers and researchers in the field of refactoring as well as demonstrations of practical refactoring tools program analysis program manipulation refactoring transformation maintenance and agile development challenges opportunities and future directions software entropy is a phenomenon where repeated changes gradually degrade the structure of the system making it hard to understand and maintain this phenomenon imposes challenges for organizations that have moved to agile methods from other processes despite agile s focus on adaptability and responsiveness to change we have investigated this issue through an industrial case study and reviewed the literature on addressing software entropy focussing on the detection of code smells and their treatment by refactoring we found that in order to remain agile despite of software entropy developers need better support for understanding planning and testing the impact of changes however it is exactly work on refactoring decision support and task complexity analysis that is lacking in literature based on our findings we discuss strategies for dealing with entropy in this context and present avenues for future research what motivate software engineers to refactor source code evidences from professional developers refactoring is an increasingly practiced method in industry software development however existing research mostly focus on the technical aspect of refactoring we still know little about the human behavior domain on this issue software developer s motivation has been recognized as a key human factor for the software development and maintenance tasks therefore identifying what motivates software developer refactor their or others source code will bring both theoretical and practical implications in this paper we report our case studies in four software development organizations through interviews with 10 professional software developers we identified the major factors that motivate their refactoring activities an empirical model on refactoring motivation is also presented based on the data collected strengthening refactoring towards software evolution with quantitative and experimental grounds refactoring is a process meant to improve the internal quality of software systems however while on one hand the guidelines for this delicate process are still empirical and qualitative on the other hand software product metrics often indicate that this process has the opposite results also there is a lack of evidence regarding improvements on maintainability due to refactoring this means that this process although widely acknowledged as one of the best software practices is difficult to deploy within large scale software systems and can be better grounded to address these challenges we propose a method for refactoring with quantitative and experimental grounds upon the consolidation of this method we will build the necessary blocks to implement and validate it 2009 ieee quality analysis and evaluation techniques review and audit software design software engineering tools and methods software quality tools identifying fragments to be extracted from long methods long and complex methods are hard to read or maintain and thus usually treated as bad smells known as long method on the contrary short and well named methods are much easier to read maintain and extend in order to divide long methods into short ones refactoring extract method was proposed and has been widely used however extracting methods manually is time consuming and error prone though existing refactoring tools can automatically extract a selected fragment from its inclosing method which fragment within a long method should be extracted has to be determined manually in order to facilitate the decision making we propose an approach to recommend fragments within long methods for extraction the approach is implemented as a prototype called automed with the tool we evaluate the approach on a nontrivial open source project the evaluation results suggest that refactoring cost of long methods can be reduced by nearly 40 the main contribution of this paper is an approach to recommending fragments within long methods to be extracted as well as an initial evaluation of the approach 2009 ieee bad smells extract method long method refactoring an empirical study of java system evolution at the method level exploring the evolution of systems can provide valuable insights into the traits of developers and inform our understanding of system dynamics while we usually expect an objectoriented system to grow in classes as it ages what are not so obvious are patterns in the evolution of specific class features in this paper we explore empirical traits of four java open source systems using data extracted by two tools and informed by a previous study of inheritance depth evolution we analyse evolution at a lower level of granularity given by the methods of a class on an incremental change per version basis rather than absolute class size per version evolution at a finer grain can identify trends not possible on a class wide basis the approach thus represents a white box view of the investigation of evolutionary forces our analysis also allowed direct comparison with a set of low level refactorings extracted by an automated tool in a previous study scrutiny of trends in methods was further motivated by the fact that the vast majority of refactorings apply not at the class level but at the method level 2009 ieee empirical evolution java method oss refactoring of statecharts statecharts are an important tool for specifying the behavior of reactive systems and development tools can automatically generate object oriented code from them as the system is refactored it is necessary to modify the associated statecharts as well performing operations such as grouping or ungrouping states extracting part of a statechartnto a separate class and merging states and transitions refactoring tools embedded in object oriented development environments are makng it much easier for developers to modify their programs however tool support for refactoring statecharts does not yet exist as a result developers avoid making certain changes that are too difficult to perform manually even though design quality deteriorates methodologically statecharts were meant to enable a systems engineer to describe a complete system which would then be refined into a concrete implementation object oriented or other this process is not supported by object oriented development environments which force each statechart to be specified as part of a class automated tool support for refactoring statecharts will also make this kind of refinement possible this paper describes a case study that shows the usefulness of refactoring support for statecharts and presents an initial catalog of relevant refactorings we show that a top down refinement process helps identify the tasks and classes in a natural way 2009 springer verlag berlin heidelberg analysing refactoring dependencies using unfolding of graph transformation systems refactoring has emerged as a successful technique to reduce complexity of object oriented designs but due to implicit dependencies not all sequences of refactorings are appropriate in this paper we model refactoring steps as graph transformation and use the unfolding analysis technique to choose the sequence of refactorings best suited in order to improve the design we use graphs to represent software architectures at the class level and graph transformation to formally describe their refactoring operations this makes it possible to use concepts and techniques from the theory of graph transformation such as unfolding to identify dependencies between refactoring steps copyright 2009 acm graph transformation systems search based refactoring evolving enterprise application using refined use case and refactoring mapping how to effectively evolve enterprise application with the frequently changing requirement is a challenge to software engineering requirement is a noticeable cause of evolution of enterprise application and requirement changes cannot be estimated precisely in many cases therefore the main problem is how to capture requirements and changes and propagate the proper modification to application the traditional method based on model and code re generating is not conducive to management and maintenance refactoring has given guidance to gradual evolution of object oriented software this paper presents a approach using refined use case to capture the requirement to modeling enterprise application and using the refactoring mappings between requirement and models to effectively maintain model and other parts of the application which helps to smooth the evolution process of enterprise applications 2009 ieee change propagation refined use case requirement refactoring software evolution a quantitative evaluation of software quality enhancement by refactoring using dependency oriented complexity metrics the maintainability of software depends on the quality of software software under evolution is modified and enhanced to cater the new requirements due to this the software becomes more complex and deviates from its original design in turn lowering the quality refactoring makes object oriented software systems maintainable effective refactoring requires proper metrics to quantitatively ascertain the improvement in the quality after refactoring in this direction we have made an effort to quantitatively evaluate the quality enhancement by refactoring using dependency oriented complexity metrics in this paper three experimental cases are given the metrics have successfully indicated quantitatively the presence of defects and the improvement in the quality of designs after refactoring these metrics have acted as quality indicators with respect to designs considered under ripple effects before and after refactoring metrics as quality indicators help to estimate the required maintenance efforts 2009 ieee dcoupling dependency oriented complexity metrics design defects quality refactoring proceedings 16th asia pacific software engineering conference apsec 2009 the proceedings contain 63 papers the topics discussed include improving the accuracy of software effort estimation based on multiple least square regression models by estimation error based data partitioning on the relationship between different size measures in the software life cycle investigating the effect of refactoring on software testing effort extracting high level functional design from software requirements identifying fragments to be extracted from long methods a graph based approach to detecting causes of implied scenarios under the asynchronous and synchronous communication styles extracting environmental constraints to make reactive system specifications realizable monitoring composite services with universal modal sequence diagrams the context dynamics matrix cdm an approach to modeling context tool support for component based software architectures and web services composition by i o data structure correspondences escape the waterfall agile for aerospace agile is an umbrella software methodology that incorporates many of the best practices of the last couple of decades in this paper we will examine some of those key techniques for possible application in the aerospace domain starting with a brief literature review to identify the key agile publications and the germane do 178b work virtually all agile practices can be mapped to a do 178b software development process we provide a detailed analysis of the key practices with a preliminary assessment of the ease of implementation for each an analysis of a number of the difficulties involving transitioning from a traditional waterfall software development process to agile practices will show that though difficult a transition is possible the transition to agile development does not require sudden sweeping change but instead can be accomplished through incorporating agile methods into an existing process we will document successful integration of test driven development pair programming refactoring an iterative approach and other agile methods into a traditional do 178b software development process we conclude with a call for a collaborative effort to further explore agile as an answer to the urgent need for new approaches to complex systems that have become increasingly difficult to verify and validate 2009 ieee a study of interorganizational process refactoring based on inheritance technology the formal modeling and correctness analysis of interorganizational business processes is one of the hot topics in business process management this paper focuses on the modeling and refactoring of interorganizational processes with the integrated view of process activities and data the data oriented interorganizational process modeling method is proposed based on the inheritance concept from software engineering two kinds of process inheritance are defined to analyze the proper adjustment of interorganizational processes moreover the refactoring stage and curve of interorganizational processes are identified 2009 ieee inheritance technology interorganizational process petri nets process refactoring figd an open source intellectual property violation detector figd fingerprint generator detector is an open source java application capable of detecting intellectual property violations in compiled java programs without requiring access to the original source files figd uses a modification of the n gram method which is very accurate in discovering everything from blatantly copied source to more advanced attempts of obfuscation such as variable refactoring or white space insertions our improvements to the algorithm allow us to increase the speed of detection and create small fingerprints which can be stored for future comparisons towards a model refactoring conflict resolution algorithm conflict resolution is a key problem in research of model refactoring while the majority of researchers focus on conflicts detection conflict resolution is usually performed manually after being analyzed known conflicts three categories of conflicts could be resolved which include conflicts of parallel applications of the same rule symmetric conflicts and asymmetric conflicts this paper concentrates on automating conflicts resolution so as to realize the automatic model refactoring this method provides an integrated algorithm based on manual analysis of the three categories of conflicts this algorithm could preliminarily realize the automatic resolution of conflicts mentioned which are caused by the parallel application of refactoring rules 2009 ieee algorithm conflict conflict resolution critical pairs model refactoring an empirical investigation of the key factors for refactoring success in an industrial context refactoring is an increasingly practiced method in industrial software development stated simply refactoring is an ongoing software improvement process that simplifies the internal structure of existing software without changing its external behavior the purpose is to improve the software and facilitate future maintenance and enhancement existing studies on refactoring mainly focus on its technical aspects and thus do not consider the team and human factors that influence its success to identify the major facilitating factors for the success of refactoring we interviewed 10 industrial software developers and combined their responses with a study of the existing literature formulated a model of refactoring success the resulting conceptual model comprises both technical and non technical factors technical factors include level testing and debugging and tools while the non technical factors include communication and coordination support activities individual capability skills and programmer participation we propose to verify this model empirically through a survey of professional software developers main body of refactoring practitioners the survey design is provided empirical software engineering human factors maintenance refactoring software development incremental model synchronization in model driven development environments most modern model driven software development environments rely heavily on model transformations for generating various software design artifacts and eventually even source code however during development maintenance and evolution activities these software artifacts are subject to updates and refactoring operations in such model driven development environments these software artifacts need to be re synchronized every time one of them is altered so that they all remain consistent according to some specific rules relations and domain constraints until now the standard approach to model synchronization has been the re application of all transformation rules aiming thus for the complete re generation of all artifacts in all models involved this complete re application is a safe yet computationally expensive way to ensure consistency among models in this paper we present a method for re synchronizing software models in an incremental fashion by utilizing an indexing model in this respect using the proposed methodology the time required for maintaining global model consistency is proportional to the size of the changes and not that of the models involved the proposed approach has been applied for the incremental re synchronization of large and complex models in the eclipse web tools platform wtp results indicate that this solution can significantly reduce the time required to re synchronize models in such comprehensive development environments as wtp copyright 2009 ali razavi kostas kontogiannis ibm canada ltd system evolution at the attribute level an empirical study of three java oss and their refactorings in this paper we focus on the net changes in attributes across versions of oss and use net class change data class additions and deletions as well as refactoring data from a previous study to inform our understanding of how those three systems evolved as they did while the majority of new attributes were added at levels 1 and 2 of the inheritance these patterns were not consistent the research question addresses the evolutionary relationship between classes and attributes as well as the connection between those changes and refactorings although some evidence of attributes following patterns conformant with class additions was found we also identified occurrences of attributes being added unilaterally a strong correspondence was also found between attribute addition and the refactoring data finally we explore features of a fourth system with seven inheritance levels for similar characteristics attribute evolution oo refactoring safer typing of complex api usage through java generics when several incompatible implementations of a single api are in use in a java program the danger exists that instances from different implementations may inadvertently be mixed leading to errors in this paper we show how to use generics to prevent such mixing the core idea of the approach is to add a type parameter to the interfaces of the api and tie the classes that make up an implementation to a unique choice of type parameter in this way methods of the api can only be invoked with arguments that belong to the same implementation we show that the presence of a type parameter in the interfaces does not violate the principle of interface based programming clients can still completely abstract over the choice of implementation in addition we demonstrate how code can be reused between different implementations how implementations can be defined as extensions of other implementations and how different implementations may be mixed in a controlled and safe manner to explore the feasibility of the approach gauge its usability and identify any issues that may crop up in practical usage we have refactored a fairly large existing api based application suite and we report on the experience gained in the process copyright 2009 acm family polymorphism generics interface based programming programming patterns genutest a unit test and mock aspect generation tool unit testing plays a major role in the software development process what started as an ad hoc approach is becoming a common practice among developers it enables the immediate detection of bugs introduced into a unit whenever code changes occur hence unit tests provide a safety net of regression tests and validation tests which encourage developers to refactor existing code with greater confidence one of the major corner stones of the agile development approach is unit testing agile methods require all software classes to have unit tests that can be executed by an automated unit testing framework however not all software systems have unit tests when changes to such software are needed writing unit tests from scratch which is hard and tedious might not be cost effective in this paper we propose a technique which automatically generates unit tests for software that does not have such tests we have implemented genutest a prototype tool which captures and logs interobject interactions occurring during the execution of java programs using the aspect oriented language aspectj these interactions are used to generate junit tests they also serve in generating mock aspects mock object like entities which enable testing units in isolation the generated junit tests and mock aspects are independent of the tool and can be used by developers to perform unit tests on the software comprehensiveness of the unit tests depends on the software execution we applied genutest to several open source projects such as nanoxml and jode we present the results explain the limitations of the tool and point out direction to future work to improve the code coverage provided by genutest and its scalability springer verlag 2009 an application of intelligent data analysis techniques to a large software engineering dataset within the development of large software systems there is significant value in being able to predict changes if we can predict the likely changes that a system will undergo then we can estimate likely developer effort and allocate resources appropriately within object oriented software development these changes are often identified as refactorings very few studies have explored the prediction of refactorings on a wide scale within this paper we aim to do just this through applying intelligent data analysis techniques to a uniquely large and comprehensive software engineering time series dataset our analysis show extremely promising results allowing us to predict the occurrence of future large changes 2009 springer berlin heidelberg hidden markov models software engineering time series analysis local search based refactoring as graph transformation to improve both performance scalability and traceability understandability of search based refactoring in this paper we propose a local formulation of refactoring based on graph transformation we use graphs to represent software architectures at the class level and graph transformation to formally describe their refactoring operations this makes it possible to use concepts and techniques from the theory of graph transformation such as unfolding and critical pair analysis to identify dependencies between refactoring steps as a result we are able to express the search problem as an instance of the ant colony optimisation metaheuristic 2009 ieee using static analysis to extract c 0x concepts using concepts to abstract domain knowledge is the basis for generic programming concept will be a new language feature in c 0x which provides solid base for developing reusable and extendable generic software to make better use of new generic programming features of c 0x it is necessary to identify concepts in legacy c programs and refactor them to c 0x programs this paper presents an automatic method to identify concepts with static analysis analyzes the usages of type parameters in legacy programs to extract valid expression constraints and associate type constraints concepts can be inferred by these constraints the approach is applied to the c standard template library to identify most of the potential concepts in stl the study convinces that this method is helpful to identify concepts in legacy c programs c 0x concept constraint analysis generic programming software refactoring class structure refactoring of object oriented softwares using community detection in dependency networks the quality of a software system is largely determined by its internal structures which always degrade over the software evolution therefore the structures have to be reconditioned from time to time however the existing methods are very complex and resource consuming when doing this task in this paper we present an approach to recondition the class structures of object oriented oo software systems it uses attribute method networks and method method networks to represent attributes methods and dependencies between them it proposes a guided community detection algorithm to obtain the optimized community structures in the method method networks which also correspond to the optimized class structures it also provides a list of refactorings by comparing the optimized class structures with the real class structure in software systems and inspecting the attribute method networks the approach is evaluated using the open source case study jhotdraw 5 1 and the advantages of our approach are illustrated in comparison with existing methods higher education press and springer verlag gmbh 2009 class refactoring community detection complex networks object oriented oo software software dependency networks software refactoring an expert system for determining candidate software classes for refactoring in the lifetime of a software product development costs are only the tip of the iceberg nearly 90 of the cost is maintenance due to error correction adaptation and mainly enhancements as lehman and belady lehman m m belady l a 1985 program evolution processes of software change academic press professional state that software will become increasingly unstructured as it is changed one way to overcome this problem is refactoring refactoring is an approach which reduces the software complexity by incrementally improving internal software quality our motivation in this research is to detect the classes that need to be rafactored by analyzing the code complexity we propose a machine learning based model to predict classes to be refactored we use weighted naïve bayes with infogain heuristic as the learner and we conducted experiments with metric data that we collected from the largest gsm operator in turkey our results showed that we can predict 82 of the classes that need refactoring with 13 of manual inspection effort on the average 2008 elsevier ltd all rights reserved naive bayes refactor prediction refactoring software metrics web services and formal methods 5th international workshop ws fm 2008 revised selected papers the proceedings contain 14 papers the topics discussed include on the expressive power of process interruption and compensation modelling and analysis of time constrained flexible workflows with time recursive ecatnets contract compliance and choreography conformance in the presence of message queues verification of choreographies during execution using the reactive event calculus restful petri net execution validation and discovery of non deterministic semantic e services fault compensation and termination in ws bpel 2 0 a comparative analysis refactoring long running transactions on the fly model based testing of web services with jambition towards a formal framework for workflow interoperability security types for sessions and pipelines why does my service have no partners proof techniques for adapter generation and efficient controllability analysis of open nets concept analysis for class cohesion a concept lattice based approach for analysis of class cohesion is presented the approach facilitates rapid identification of less cohesive classes it also helps identify less cohesive methods attributes and classes in one go further the approach guides refactorings such as extract class move method localize attributes and remove unused attributes the effectiveness of the technique is demonstrated through examples 2009 ieee identification of extract method refactoring opportunities extract method has been recognized as one of the most important refactorings since it decomposes large methods and can be used in combination with other refactorings for fixing a variety of design problems however existing tools and methodologies support extraction of methods based on a set of statements selected by the user in the original method the goal of the proposed methodology is to automatically identify extract method refactoring opportunities and present them as suggestions to the designer of an objectoriented system the suggested refactorings adhere to three principles the extracted code should contain the complete computation of a given variable declared in the original method the behavior of the program should be preserved after the application of the refactoring and the extracted code should not be excessively duplicated in the original method the proposed approach is based on the union of static slices that result from the application of a block based slicing technique the soundness of the identified refactoring opportunities has been evaluated by an independent designer on the system that he developed 2009 ieee a new method for acquisition of boc modulation signal based on refactoring theory to cross correlation a boc modulated signal presents multiple peaks auto correlation function the zeros of cross correlation can make a false judgment by acquisition phase so based on the idea of fractal a new acquisition method has been proposed using a simple folding theory a new cross correlation function was refactored the influence of local zeros was eliminated and the probability of detecting is enhanced comparing to the acquisition method with three parallel tags the simulation was completed the analysis to the simulation result has shown that the method can provide phase information to the track loop and adapt to acquisition for high rank boc modulated signal acquisition boc modulated signal folding arithmetic zeros of cross correlation an integrated crosscutting concern migration strategy and its semi automated application to jhotdraw in this paper we propose a systematic strategy for migrating crosscutting concerns in existing object oriented systems to aspect oriented programming solutions the proposed strategy consists of four steps mining exploration documentation and refactoring of crosscutting concerns we discuss in detail a new approach to refactoring to aspect oriented programming that is fully integrated with our strategy and apply the whole strategy to an object oriented system namely the jhotdraw framework moreover we present a method to semi automatically perform the aspect introducing refactorings based on identified crosscutting concern sorts which is supported by a prototype tool called sair we perform an exploratory case study in which we apply this tool on the same object oriented system and compare its results with the results of manual migration in order to assess the feasibility of automated aspect refactoring both the refactoring tool sair and the results of the manual migration are made available as open source the latter providing the largest aspect introducing refactoring available to date we report on our experiences with conducting both case studies and reflect on the success and challenges of the migration process aspect oriented programming code refactoring concern modeling cross cutting concerns program analysis reverse engineering software engineering adaptive quality forecasting strategy of xml data streams aimed at the currently shortage of xml streams quality detecting an adaptive quality forecasting method of xml data streams xafs is presented it uses the vector matrix built by the xml keys as windows uses vector product wavelet transform to multilevel decompose and refactor the xml streams series and then forecasts the xml streams quality combing squares support vector machines for even more adapting net load it proposes a control strategy by weight and adaptive adjustment to ensure xml streams quality contrasting with other corresponding algorithms a series of emulation experiments shows that this method has proper rather precision and practicability so it is an effective forecasting method of xml streams mining forecasting least squares support vector machines vector product wavelet transform xml data streams xml database identification of move method refactoring opportunities placement of attributes methods within classes in an object oriented system is usually guided by conceptual criteria and aided by appropriate metrics moving state and behavior between classes can help reduce coupling and increase cohesion but it is nontrivial to identify where such refactorings should be applied in this paper we propose a methodology for the identification of move method refactoring opportunities that constitute a way for solving many common feature envy bad smells an algorithm that employs the notion of distance between system entities attributes methods and classes extracts a list of behavior preserving refactorings based on the examination of a set of preconditions in practice a software system may exhibit such problems in many different places therefore our approach measures the effect of all refactoring suggestions based on a novel entity placement metric that quantifies how well entities have been placed in system classes the proposed methodology can be regarded as a semi automatic approach since the designer will eventually decide whether a suggested refactoring should be applied or not based on conceptual or other design quality criteria the evaluation of the proposed approach has been performed considering qualitative metric conceptual and efficiency aspects of the suggested refactorings in a number of open source projects 2009 ieee design quality feature envy jaccard distance move method refactoring object oriented design guidelines for enabling the extraction of aspects from existing object oriented code when extracting crosscutting concerns from object oriented systems to aspects it is often needed to transform the code in order to enable the application of aspects although not extensively documented in the literature object oriented transformations are critical to turn legacy systems ready to aspect oriented refactoring for this reason in this paper we provide a set of guidelines for maintainers and developers interested in preparing object oriented systems to the aspect technology moreover we present a tool that can help developers to identify the need of object oriented transformations we also evaluate the proposed guidelines and supporting tool through two case studies jot 2008 iron and steel mill applications a new and quick method for the chemical analysis of refractories a new quick and portable method of chemical analysis were presented so as to analyses refractories that are used in operations involving the continuous pouring of steel with a description of overall principles of laser induced breakdown spectroscopy libs the method is quite versatile and can be used equally well on solid liquids or gases to provide a qualitative analysis of the chemical composition of the sample or of the analyses product the method also makes it possible to quickly identify different materials on refactories used for continuous steel pouring are shown hereinafter the method also allows to check on line the grades of refractory to approve the parts of new works and or in production along with the use to presort contaminated refractories during the dismantling of glass furnaces client based cohesion metrics for java programs one purpose of software metrics is to measure the quality of programs the results can be for example used to predict maintenance costs or improve code quality an emerging view is that if software metrics are going to be used to improve quality they must help in finding code that should be refactored often refactoring or applying a design pattern is related to the role of the class to be refactored in client based metrics a project gives the class a context these metrics measure how a class is used by other classes in the context we present a new client based metric lcic lack of coherence in clients which analyses if the class being measured has a coherent set of roles in the program interfaces represent the roles of classes if a class does not have a coherent set of roles it should be refactored or a new interface should be defined for the class we have implemented a tool for measuring the metric lcic for java projects in the eclipse environment we calculated lcic values for classes of several open source projects we compare these results with results of other related metrics and inspect the measured classes to find out what kind of refactorings are needed we also analyse the relation of different design patterns and refactorings to our metric our experiments reveal the usefulness of client based metrics to improve the quality of code 2009 elsevier b v all rights reserved cohesion design patterns java metrics refactoring an exploratory investigation on refactoring in industrial context refactoring which is an efficient method to improve the quality of the existing code has been widely used in practical software development and maintenance activities the current refactoring researches are more focus on the technical aspect of refactoring but pay little attention to its use in real software development environment however software development and maintenance in their nature are human centric activities the lack of systematic empirical studies has resulted in the gap between current refactoring researches and industrial practices to bridge this research gap we conduct this exploratory study to learn more about the actual use of refactoring in the industrial context using a series of semi controlled interviews as our major research method we gathered first hand information on how the refactoring is used by practitioners we built a three stage framework to describe the overall refactoring process 19 basic factors are identified and categorized we also identify the most important ones and the factors that may trigger potential conflicts between developers and the managers some related issues such as this study s implications are also discussed 2009 springer berlin heidelberg human factors industrial context refactoring refactoring prediction using class complexity metrics in the lifetime of a software product development costs are only the tip of the iceberg nearly 90 of the cost is maintenance due to error correction adoptation and mainly enhancements as belady and lehman lehman and belady 1985 state that software will become increasingly unstructured as it is changed one way to overcome this problem is refactoring refactoring is an approach which reduces the software complexity by incrementally improving internal software quality our motivation in this research is to detect the classes that need to be rafactored by analyzing the code complexity we propose a machine learning based model to predict classes to be refactored we use weighted naïve bayes with infogain heuristic as the learner and we conducted experiments with metric data that we collected from the largest gsm operator in turkey our results showed that we can predict 82 of the classes that need refactoring with 13 of manual inspection effort on the average defect prediction naïve bayes refactor prediction refactoring software metrics weighted naïve bayes systematically refactoring inheritance to delegation in java because of the strong coupling of classes and the proliferation of unneeded class members induced by inheritance the suggestion to use composition and delegation instead has become commonplace the presentation of a corresponding refactoring in the literature may lead one to believe that such a transformation is a straightforward undertaking however closer analysis reveals that this refactoring is neither always possible nor does it necessarily achieve its desired effect we have therefore identified the necessary preconditions and realizable postconditions of the refactoring and built a tool that can perform it completely automatically by applying this tool to all subclasses of several open source projects we have collected evidence of the applicability of the refactoring and of its capability to deliver on its promises the refactoring builds on constraint graphs originally developed for type inference to check the preconditions and to compute the necessary delegation as well as the subtype relationships that must be maintained copyright 2008 acm design experimentation languages is the need to follow chains a possible deterrent to certain refactorings and an inducement to others a current and difficult challenge in the software engineering arena is assessment of code smells and subsequent re engineering decisions the mechanics of seventy two individual object oriented refactorings are specified in the seminal text by fowler providing the steps that need to be undertaken to complete each while it is relatively easy to identify related refactorings i e those that each refactoring itself directly uses as part of those mechanics what is not so clear is the chain of required refactorings that may emerge due to these indirect and composite relationships in this paper we investigate the characteristics of fourteen of the seventy two refactorings identifying for each its related refactorings and the implications this may have for the overall time and effort required to carry out each we supported our analysis with data from a previous empirical analysis the key result was that refactorings inducing long chains tended to be utilized less by developers than refactorings with short chains suggesting that complexity given by long chains may be a real consideration prior to refactoring empirically long chains were found to be composed of sets of smaller inter related refactorings on a general note understanding the composition of refactorings is recognized as an emerging yet under researched area but has significant implications for the amount of effort that a developer might have to invest in any single change to a system involving refactoring chains object oriented refactoring tools a metric based approach for reconstructing methods in bject oriented systems refactoring is an important activity to improve software quality which tends to become worse through repetitive bug fixes and function additions unfortunately it is difficult to perform appropriate refactorings because a refactoring needs certain costs and its effects should be greater than the costs this paper describes an approach for appropriate refactorings the approach identifies spots to be refactored and it suggests how they should be improved moreover the approach estimates the effects of the refactorings the approach requires a lightweight source code analysis for measuring several metrics so that it can be applied to middle or large scale software system the approach can make the refactoring process more effective and efficient one copyright 2008 acm refactoring software maintenance source code analysis on the relation of refactoring and software defects this paper analyzes the influence of evolution activities such as refactoring on software defects in a case study of five open source projects we used attributes of software evolution to predict defects in time periods of six months we use versioning and issue tracking systems to extract 110 data mining features which are separated into refactoring and non refactoring related features these features are used as input into classification algorithms that create prediction models for software defects we found out that refactoring related features as well as non refactoring related features lead to high quality prediction models additionally we discovered that refactorings and defects have an inverse correlation the number of software defects decreases if the number of refactorings increased in the preceding time period as a result refactoring should be a significant part of both bug fixes and other evolutionary changes to reduce software defects copyright 2008 acm mining software archives refactoring software evolution 3rd international symposium on leveraging applications of formal methods verification and validation isola 2008 the proceedings contain 61 papers the special focus in this conference is on leveraging applications of formal methods verification and validation the topics include architecture based specification and verification of embedded software systems information system engineering supporting observation orientation decision and compliant action modelling coordination and compensation animating event b models by formal data models automated formal testing of c api using t2c framework tailoring and optimising software for automotive multicore system timing validation of automotive software towards using reo for compliance aware business process modeling a use case driven approach to formal service oriented modelling safety and response time analysis of an automotive accident assistance service a framework for analyzing and testing the performance of software services assuring the satisfiability of sequential extended regular expressions computing must and may alias to detect null pointer dereference program verification by reduction to semi algebraic systems solving debugging statecharts via model code traceability formal use of design patterns and refactoring a component based access control monitor navigating the requirements jungle non functional avionics requirements measurement based timing analysis weaving a formal methods education with problem based learning encouraging the uptake of formal methods training in an industrial context computer supported collaborative learning with mind maps thinking in user centric models specialization and instantiation aspects of a standard process for developing educational modules contexts and context awareness in view of the diagram predicate framework the use of adaptive semantic hypermedia for ubiquitous collaboration systems the use of formal ontology to specify context in ubiquitous computing high service availability in matrics for the ocs the ask system and the challenge of distributed knowledge discovery requirements for ontology based design project assessment organizing the worlds machine learning information workflow testing directed generation of test data for static semantics checker optimizing the system observability level for diagnosability weaving authentication and authorization requirements into the functional model of a system using z promotion simple gedanken experiments in leveraging applications of formal methods and composition of web services using wrappers a quantitative method to detect design defects and to ascertain the elimination of design defects after refactoring one of the ways to make object oriented software systems maintainable is refactoring effective refactoring requires a proper method to detect design defects recently some quantitative design defects detection methods which are based on metrics have been developed however there is a scope for a design defects detection method which considers design change propagation probabilities between artifacts that are connected through intermediate artifacts a quantitative method is proposed in this paper considering the above aspect the main advantage of the proposed method is it can be used not only for design defects detection but also to ascertain quantitatively the elimination of design defects after refactoring making use of the proposed method in example designs two different design defects are detected and the elimination of these defects after refactoring from the design is known quantitatively the frame work in which this method is used is given bad smells design change propagation probability matrix design defects divergent change refactoring shotgun surgery clustering based automatic refactorings identification the aim of this paper is to approach the problem of improving the design of an object oriented software system by identifying the appropriate refactorings it is well known that improving the quality of software systems design is an important issue during the evolution of object oriented software systems this improvement can be achieved by refactoring the software system in order to improve its internal structure but without altering the external behavior of the code in this paper we introduce a hierarchical divisive clustering algorithm for automatic identification of refactorings that improve the internal structure of a software system we evaluate our approach using jhotdraw case study and a real software system emphasizing its advantages in comparison with existing similar approaches 2008 ieee clustering refactoring software design hierarchical clustering based automatic refactorings detection the structure of software systems is subject of many changes during the systems lifecycle a continuous improvement of the software systems structure can be made using refactoring that assures a clean and easy to maintain software structure in this paper we are focusing on the problem of restructuring object oriented software systems using hierarchical clustering we propose two hierachical clustering based algorithms which takes an existing software and reassembles it using clustering in order to obtain a better design suggesting the needed refactorings we evaluate the proposed algorithms using the open source case study jhotdraw and a real software system providing a comparison with previous approaches algorithm clustering object oriented systems refactoring software engineering system design sort based refactoring of crosscutting concerns to aspects crosscutting concerns in object oriented programming hinder evolution because of their symptoms tangling and scattering to benefit from the modularisation capabilities for crosscutting concerns provided by aspect oriented programming which prevent tangling and scattering aspect introducing refactoring can be used the first step in aspect introducing refactoring is identifying and documenting crosscutting concerns in existing code the second step is refactoring the identified concerns to aspects this paper describes a tool called sair that can perform the second step of the aspect introducing refactoring for the first step documenting sair uses crosscutting concern sorts of the various possible sorts sair currently supports the two most commonly encountered ones role superimposition and consistent behavior the refactoring towards aspects of concerns of these sorts is illustrated on an open source application jhotdraw 2008 acm cluster analysis of java dependency graphs we present a novel approach to the analysis of dependency graphs of object oriented programs we propose to use the girvan newman clustering algorithm to compute the modular structure of programs this is useful in assisting software engineers to redraw component boundaries in software in order to improve the level of reuse and maintainability the results of this analysis can be used as a starting point for refactoring the software we present barrio an eclipse plugin that can detect and visualise clusters in dependency graphs extracted from java programs by means of source code and byte code analysis these clusters are then compared with the modular structure of the analysed programs defined by package and container specifications two metrics are introduced to measure the degree of overlap between the defined and the computed modular structure some empirical results obtained from analysing non trivial software packages are presented 2008 acm anti pattern detection cluster analysis dependency analysis refactoring mining change patterns in aspectj software evolution understanding software change patterns during evolution is important for researchers concerned with alleviating change impacts it can provide insight to understand the software evolution predict future changes and develop new refactoring algorithms however most of the current research focus on the procedural programs like c or object oriented programs like java seldom effort has been made for aspect oriented software in this paper we propose an approach for mining change patterns in aspectj software evolution our approach first decomposes the software changes into a set of atomic change representations then employs the apriori data mining algorithm to generate the most frequent itemsets the patterns we found reveal multiple properties of software changes including their kind frequency and correlation with other changes in our empirical evaluation on several non trivial aspectj benchmarks we demonstrate that those change patterns can be used as measurement aid and fault predication for aspectj software evolution analysis 2008 ieee documenting and evaluating scattered concerns for framework usability a case study scattered concerns design features whose implementations span multiple program units can pose extra difficulty for developers to locate understand modify and extend in particular since successful application frameworks tend to be widely used by many developers the impact of scattered concerns on framework usability can be especially significant ideally every scattered concern present at the framework interface should be carefully evaluated to justify its introduction if it cannot be avoided it should at least be well documented to facilitate its use to gain insights into how scattered concerns are actually designed and documented in industrial frameworks a method for documenting and evaluating scattered concerns is proposed and a manual pilot study on the jfc swing jtree is performed in this method concerns are identified and documented in a structured manner listing not only those items which an application must directly depend on but other methods and classes that indirectly contribute to the design of a concern the documented concerns are compared with the framework architecture in order to justify their existence concerns that map nicely to the architecture are deemed to be acceptable as they fit within the design and were explicitly traded off for other quality attributes those that show a mismatch indicate a place where the concern could cause problems for application developers and thus should be either refactored or well documented concerns are also evaluated using design criteria like cohesion and coupling while it is not always possible to identify design flaws in a scattered concern at the least documenting these concerns will make them easier to use the jtree study results in 12 concerns 7 of which are missing or only partially documented in the official swing tutorial 4 framework us ability flaws are identified which if addressed would lead to the removal of 2 of the 12 documented concerns and improvements to another 2 thus the proposed method has the potential to be useful to framework development teams 2008 ieee documenting and evaluating scattered concerns for framework usability a case study scattered concerns design features whose implementations span multiple program units can pose extra difficulty for developers to locate understand modify and extend in particular since successful application frameworks tend to be widely used by many developers the impact of scattered concerns on framework usability can be especially significant ideally every scattered concern present at the framework interface should be carefully evaluated to justify its introduction if it cannot be avoided it should at least be well documented to facilitate its use to gain insights into how scattered concerns are actually designed and documented in industrial frameworks a method for documenting and evaluating scattered concerns is proposed and a manual pilot study on the jfc swing jtree is performed in this method concerns are identified and documented in a structured manner listing not only those items which an application must directly depend on but other methods and classes that indirectly contribute to the design of a concern the documented concerns are compared with the framework architecture in order to justify their existence concerns that map nicely to the architecture are deemed to be acceptable as they fit within the design and were explicitly traded off for other quality attributes those that show a mismatch indicate a place where the concern could cause problems for application developers and thus should be either refactored or well documented concerns are also evaluated using design criteria like cohesion and coupling while it is not always possible to identify design flaws in a scattered concern at the least documenting these concerns will make them easier to use the jtree study results in 12 concerns 7 of which are missing or only partially documented in the official swing tutorial 4 framework usability flaws are identified which if addressed would lead to the removal of 2 of the 12 documented concerns and improvements to another 2 thus the proposed method has the potential to be useful to framework development teams overcoming jvm hotswap constraints via binary rewriting java hotspot vm provides a facility for replacing classes at runtime called hotswap one design property of hotswap is that the signature of a replaced class must remain the same between different versions which significantly constrains the programmer modifying a class to be replaced specifically the programmer is precluded from adding new methods constructors or fields or even changing the signatures of existing methods or fields this paper presents a novel approach that overcomes these constraints of hotswap by using binary refactoring a technique that rewrites the binary representation of a program without affecting its functionality a series of micro and macro benchmarks we conducted demonstrate that the approach is extensible and efficient in particular the new binary refactoring technique which enables the approach produces highly efficient refactored application versions outperforming a widely used prior technique by as much as an order of magnitude these initial results indicate that by rewriting the bytecode of a swapped program one can effectively overcome constraints of hotswap with minimal performance overhead copyright 2008 acm binary refactoring hotswap jvm languages virtual superclass 7th international conference on aspect oriented software development aosd 08 research track proceedings the proceedings contain 17 papers the topics discussed include aspect oriented test case instantiation program program enhance thyself demand driven pattern oriented program enhancement modularity first a case for mixing aop and attribute grammars ajana a general framework for source code level interprocedural dataflow analysis of aspectj software reasoning about aspects with common sense strongaspectj flexible and safe pointcut advice bindings ejflow taming exceptional control flows in aspect oriented programming relational aspects as tracematches test based pointcuts for robust and fine grained join point specification edicts implementing features with flexible binding times support for distributed adaptations in aspect oriented middleware tool supported refactoring of aspect oriented programs and tool support for understanding and diagnosing pointcut expressions verifiable functional purity in java proving that particular methods within a code base are functionally pure deterministic and side effect free would aid verification of security properties including function invertibility reproducibility of computation and safety of untrusted code execution until now it has not been possible to automatically prove a method is functionally pure within a high level imperative language in wide use such as java we discuss a technique to prove that methods are functionally pure by writing programs in a subset of java called joe e a static verifier ensures that programs fall within the subset in joe e pure methods can be trivially recognized from their method signature to demonstrate the practicality of our approach we refactor an aes library an experimental voting machine implementation and an html parser to use our techniques we prove that their top level methods are verifiably pure and show how this provides high level security guarantees about these routines our approach to verifiable purity is an attractive way to permit functional style reasoning about security properties while leveraging the familiarity convenience and legacy code of imperative languages copyright 2008 acm determinism object capabilities pure functions static analysis annotation refactoring inferring upgrade transformations for legacy applications since annotations were added to the java language many frameworks have moved to using annotated plain old java objects pojos in their newest releases legacy applications are thus forced to undergo extensive restructuring in order to migrate from old framework versions to new versions based on annotations version lock in additionally because annotations are embedded in the application code changing between framework vendors may also entail large scale manual changes vendor lock in this paper presents a novel refactoring approach that effectively solves these two problems our approach infers a concise set of semantics preserving transformation rules from two versions of a single class unlike prior approaches that detect only simple structural refactorings our algorithm can infer general composite refactorings and is more than 97 accurate on average we demonstrate the effectiveness of our approach by automatically upgrading more than 80k lines of the unit testing code of four open source java applications to use the latest version of the popular junit testing framework copyright 2008 acm annotations eclipse frameworks java junit metadata refactoring upgrading a study of region extraction and system model on an observation system of time sequenced 3 d ct images for an observation system assisted for diagnosis of 3 d ct images consisting of time sequenced multi slice tomograms the refinement method to obtain the more precise region detection on which noise areas are reduced is proposed the experimental results show that noise areas are reduced effectively and also the system model refined by code refactoring is also proposed to be able to make the system having flexibility also for that the proposed method is implemented testing the impact of pattern based ontology refactoring on ontology matching results we observe the impact of ontology refactoring based on detection of name patterns in the ontology structure on the results of ontology matching results of our experiment are evaluated using novel logic based measures accompanied by an analysis of typical effects although the pattern detection method only covers a fraction of ontological errors there seems to be a measurable effect on the quality of the resulting matching re approaching the refactoring rubicon fowler saw the availability of automated support for the extract method refactoring in modern ides as an indication for the crossing of the refactoring rubicon in spite of the advances in refactoring technology it seems that this rubicon has not yet been crossed and refactoring support in modern ides leaves a lot to be desired we performed a case study in which we converted a java servlet to use the model view controller pattern using as much automated support as available we found that while the whole conversion could be described as a series of refactorings most of these were inadequately supported by the ide and some were not supported at all based on these findings we outline the requirements from a refactoring framework that will support much more of the conversion process and will also enable the composition of small refactorings into larger ones copyright 2008 acm smart assistance in ecu design and integration over the last years significant effort has been spend to introduce model based software development methods and supporting tools in the development of electronic control units ecu one important future trend will be to complement model based development with smart assistance technologies in the future tools will support developers by offering assistance how to improve designs and calculate the impact of their design decisions for example mapping functional building blocks on ecus requires a sound understanding of multiple criteria such as resource performance dependencies cost safety and electrical power consumption providing assistance by presenting developers alternative choices and their respective impact on system performance power consumption and cost will significantly support the decision making process mapping functionality to ecus without having smart assistance in analyzing the impact of the mapping only addresses constructional aspects but lacks an analysis about the correctness of the execution behavior another example is the translation of requirements into design models assisting the developer in the creation of the design model and at the same time providing early feedback on the effect of design decisions on the implementation of initial requirements will significantly improve the quality of the design in addition through the early detection of design mistakes overall development time will be reduced how can such assistance be achieved to illustrate the answer we sketch the assistance for optimizing the runtime performance of a system today commercial tools exist to determine worst case execution times through precise calculations for ecu software based on this data a system level timing analysis e g through holistic schedulability analysis can be carried out for the sw on a single ecu or in a network of ecus the tools use analytical models to calculate the timing properties and the timing behavior tomorrow this knowledge will be combined with suggestions on how to improve the timing behavior of ecu software these will be design suggestions for architecture models as well as implementation suggestions for rather detailed models furthermore the effects of alternative suggestions such as using an event triggered approach instead of a polling approach can be analyzed precisely and presented to the developer for optimizing runtime performance assistance will be achieved by providing an analytical model and effective patterns to improve timing behavior both parts constitute the timing assistance future assistance technologies are smart because the assistance will be carried out semi automated by offering developers choices within their concrete development task there are many more fields of application for assistance which include on off board partitioning diagnostics refactoring variability and safety the major driver to complement tools with smart assistance is to erase design mistakes early and to guide the developer to successfully master difficult tasks in system design and integration design assistance integration semi automation timing tools the 2nd workshop on refactoring tools wrt 08 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of specific transformations that need to be performed tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial and non local program analysis and applying the transformations may affect many locations in the program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in modern day ides until now there has not been a suitable forum for discussions among researchers and developers of such tools this full day event on refactoring tools fills that need with a strongly practical focus the workshop features both presentations given by developers and researchers in the field of refactoring as well as demonstrations of practical refactoring tools program analysis program manipulation refactoring transformation analysing ontological structures through name pattern tracking concept naming over the taxonomic structure is a useful indicator of the quality of design as well as source of information exploitable for various tasks such as ontology refactoring and mapping we analysed collections of owl ontologies with the aim of determining the frequency of several combined name graph patterns potentially indicating underlying semantic structures such structures range from simple set theoretic subsumption to more complex constructions such as parallel taxonomies of different entity types the final goal is to help refactor legacy ontologies as well as to ease automatic alignment among different models the results show that in most ontologies there is a significant number of occurrences of such patterns moreover their detection even using very simple methods has precision sufficient for a semi automated analysis scenario 2008 springer verlag berlin heidelberg automated aspect recommendation through clustering based fan in analysis identifying code implementing a crosscutting concern ccc automatically can benefit the maintainability and evolvability of the application although many approaches have been proposed to identify potential aspects a lot of manual work is typically required before these candidates can be converted into refactorable aspects in this paper we propose a new aspect mining approach called clustering based fan in analysis cbfa to recommend aspect candidates in the form of method clusters instead of single methods cbfa uses a new lexical based clustering approach to identify method clusters and rank the clusters using a new ranking metric called cluster fanin experiments on linux and jhotdraw show that cbfa can provide accurate recommendations while improving aspect mining coverage significantly compared to other state of the art mining approaches 2008 ieee conflict aware schedule of software refactorings software refactoring is to restructure the internal structure of object oriented software to improve software quality especially maintainability extensibility and reusability while preserving its external behaviours according to predefined refactoring rules we may find many places in the software where refactorings can be applied applying each refactoring we may achieve some effect quality improvement if we can apply all of the available refactorings we can achieve the greatest effect however the conflicts among refactorings usually make it impossible the application of a refactoring may change or delete elements necessary for other refactorings and thus disables these refactorings as a result the application order schedule of the available refactorings determines which refactorings will be applied and thus determines the total effect achieved by the refactoring activity consequently conflicting refactorings had better be scheduled rationally so as to promote the total effect of refactoring activities however how to schedule conflicting refactorings is rarely discussed in this paper a conflict aware scheduling approach is proposed it schedules refactorings according to the conflict matrix of refactorings and effects of each individual refactoring the scheduling model is a multi objective optimisation model we propose a heuristic algorithm to solve the scheduling model we also evaluate the proposed scheduling approach in non trivial projects evaluation results suggest that refactoring activities with the scheduling approach lead to greater effect quality improvement than refactoring activities without explicit scheduling the institution of engineering and technology 2008 a metric based approach to identifying refactoring opportunities for merging code clones in a java software system a code clone is a code fragment that has other code fragments identical or similar to it in the source code the presence of code clones is generally regarded as one factor that makes software maintenance more difficult for example if a code fragment with code clones is modified it is necessary to consider whether each of the other code clones has to be modified as well removing code clones is one way of avoiding problems that arise due to the presence of code clones this makes the source code more maintainable and more comprehensible this paper proposes a set of metrics that suggest how code clones can be refactored as well the tool aries which automatically computes these metrics is presented the tool gives metrics that are indicators for certain refactoring methods rather than suggesting the refactoring methods themselves the tool performs only lightweight source code analysis hence it can be applied to a large number of code lines this paper also describes a case study that illustrates how this tool can be used based on the results of this case study it can be concluded that this method can efficiently merge code clones copyright 2008 john wiley sons ltd code clone metrics object oriented refactoring software maintenance antlrworks an antlr grammar development environment programmers tend to avoid using language tools resorting to ad hoc methods because tools can be hard to use their parsing strategies can be difficult to understand and debug and their generated parsers can be opaque black boxes in particular there are two very common difficulties encountered by grammar developers understanding why a grammar fragment results in a parser non determinism and determining why a generated parser incorrectly interprets an input sentence this paper describes antlrworks a complete development environment for antlr grammars that attempts to resolve these difficulties and in general make grammar development more accessible to the average programmer the main components are a grammar editor with refactoring and navigation features a grammar interpreter and a domain specific grammar debugger antlrworks primary contributions are a parser non determinism visualizer based on syntax diagrams and a time traveling debugger that pays special attention to parser decision making by visualizing lookahead usage and speculative parsing during backtracking copyright 2008 john wiley sons ltd debugger grammar development gui parser rapid prototyping compound record clustering algorithm for design pattern detection by decision tree learning recovering design patterns applied in a system can help refactoring the system machine learning algorithms have been successfully applied in mining data patterns however one of the main obstacles of applying them for design pattern detection is the difficulty of collecting training examples unlike other applications a design pattern instance typically includes a group of classes with certain relationships thus the possible combinations of the group of classes can be enormous which results in huge training sets making the application of machine learning algorithms impracticable in this paper we propose an innovative method using matrix transformations to cluster the training examples our method can significantly reduce the size of training examples thus making it possible to be efficiently applied in machine learning algorithm 2008 ieee decision tree design pattern detection machine learning training example proceedings 2nd ifip ieee international symposium on theoretical aspects of software engineering tase 2008 the proceedings contain 40 papers the topics discussed include prob gets nauty effective symmetry reduction for b and z models bounded model checking of compositional processes improving encoding efficiency for bounded model checking symbolic model checking apsl an extension to pointer logic for verification a generic model for confinement and its application a fundamental permission interpretation for ownership types structure and interpretation of computer programs a petri net based approach for supporting aspect oriented modeling a model driven method for the development of web applications user interaction layer a conceptual framework to integrate fault prediction sub process for software product lines executable requirements specification formal semantics of live activity diagrams a mde based approach for bridging formal models and uml model refactoring with emphasis on behavior preservation efficient automated marshaling of c data structures for mpi applications we present an automated approach for marshaling c data structures in high performance computing hpc applications our approach utilizes a graphical editor through which the user can express a subset of an object s state to be marshaled and sent across a network our tool mpi serializer then automatically generates efficient marshaling and unmarshaling code for use with the message passing interface mpi the predominant communication middleware for hpc systems our approach provides a more comprehensive level of support for c language features than the existing state of the art and does so in full compliance with the c language standard specifically we can marshal effectively and efficiently non trivial language constructs such as polymorphic pointers dynamically allocated arrays nonpublic member fields inherited members and stl container classes additionally our marshaling approach is also applicable to third party libraries as it does not require any modifications to the existing c source code we validate our approach through two case studies of applying our tool to automatically generate the marshaling functionality of two realistic hpc applications the case studies demonstrate that the automatically generated code matches the performance of typical hand written implementations and surpasses current state of the art c marshaling libraries in some cases by more than an order of magnitude the results of our case studies indicate that our approach can be beneficial for both the initial construction of hpc applications as well as for the refactoring of sequential applications for parallel execution 2008 ieee multidimensional correlation of software source code standard ways of calculating the similarity of different computer programs are needed in computer science such measurements can be useful in many different areas such as clone detection refactoring compiler optimization and run time optimization such standards are particularly important for uncovering plagiarism trade secret theft copyright infringement and patent infringement other uses include locating open source code within a proprietary program and determining the authors of different programs in a previous paper 19 i introduced the concept of source code correlation presented a theoretical basis for such a measure and described a program codematch that compares software source code and calculates correlation that paper compared the described method of source code correlation against existing methods of comparing source code and found it to be significantly superior this paper refines that definition of source code correlation and presents a new more robust definition of multidimensional source code correlation 2008 ieee an empirical study of evolution of inheritance in java oss previous studies of object oriented 00 software have reported avoidance of the inheritance mechanism and cast doubt on the wisdom of deep inheritance levels from an evolutionary perspective the picture is unclear we still know relatively little about how over time changes tend to be applied by developers our conjecture is that an inheritance hierarchy will tend to grow breadth wise rather than depth wise this claim is made on the basis that developers will avoid extending depth in favour of breadth because of the inherent complexity of having to understand the functionality of superclasses thus the goal of our study is to investigate this empirically we conduct an empirical study of seven java open source systems osss over a series of releases to observe the nature and location of changes within the inheritance hierarchies results showed a strong tendency for classes to be added at levels one and two of the hierarchy rather than anywhere else over 96 of classes added over the course of the versions of all systems were at level 1 or level 2 the results suggest that changes cluster in the shallow levels of a hierarchy this is relevant for developers since it indicates where remedial activities such as refactoring should be focused 2008 ieee refactoring effect estimation based on complexity metrics refactoring is a set of operations to improve maintainability or understandability or other attributes of a software system without changing the external behavior of it and it is getting much attention recently however it is difficult to perform appropriate refactorings since the impact of refactoring should justify the cost therefore before a refactoring is really performed the effect and the cost of it should be estimated the estimation makes it possible for us to adequately assess whether each refactoring should be performed or not this paper shows that it is difficult for developers to perform appropriate refactorings and proposes a method estimating refactoring effect the method has been implemented as a software tool and a case study was conducted with it the result of the case study showed that the estimation of the tool helped a developer of the target software system to perform an appropriate refactoring 2008 ieee annotation refactoring inferring upgrade transformations for legacy applications since annotations were added to the java language many frameworks have moved to using annotated plain old java objects pojos in their newest releases legacy applications are thus forced to undergo extensive restructuring in order to migrate from old framework versions to new versions based on annotations version lock in additionally because annotations are embedded in the application code changing between framework vendors may also entail largescale manual changes vendor lock in this paper presents a novel refactoring approach that effectively solves these two problems our approach infers a concise set of semantics preserving transformation rules from two versions of a single class unlike prior approaches that detect only simple structural refactorings our algorithm can infer general composite refactorings and is more than 97 accurate on average we demonstrate the effectiveness of our approach by automatically upgrading more than 80k lines of the unit testing code of four open source java applications to use the latest version of the popular junit testing framework copyright 2008 acm annotations eclipse frameworks java junit metadata refactoring upgrading object oriented software systems restructuring through clustering it is well known that maintenance and evolution represent important stages in the lifecycle of any software system about 66 from the total cost of the software systems development that is why in this paper we are focusing on the problem of automating an essential activity that appears in the maintenance and evolution of software systems the problem of identifying refactorings that would improve the structure of the system refactoring is the process of improving the design of software systems by improving their internal structure without altering the external behavior of the code the aim of this paper is to introduce a new clustering algorithm casyr clustering algorithm for software systems restructuring that can be used for improving software systems design by identifying the appropriate refactorings the proposed approach can be useful for assisting software engineers in their daily work of refactoring software systems we evaluate our approach on a real software system and we also provide a comparison with previous approaches 2008 springer verlag berlin heidelberg alloy as a refactoring checker refactorings are systematic changes made to programs models or specifications in order to improve their structure without changing the externally observable behaviour we will examine how a constraint solver the alloy analyzer can be used to automatically check if refactorings applied to a formal specification written in z meet this requirement furthermore we identify a class of refactorings for which the use of this tool is reasonable in general 2008 elsevier b v all rights reserved alloy behaviour preservation refactoring refinement z using fca to suggest refactorings to correct design defects design defects are poor design choices resulting in a hard to maintain software hence their detection and correction are key steps of a disciplined software process aimed at yielding high quality software artifacts while modern structure and metric based techniques enable precise detection of design defects the correction of the discovered defects e g by means of refactorings remains a manual hence error prone activity as many of the refactorings amount to re distributing class members over a possibly extended set of classes formal concept analysis fca has been successfully applied in the past as a formal framework for refactoring exploration here we propose a novel approach for defect removal in object oriented programs that combines the effectiveness of metrics with the theoretical strength of fca a case study of a specific defect the blob drawn from the azureus project illustrates our approach 2008 springer verlag berlin heidelberg design defects formal concept analysis refactoring detection of clone sequences and classes using ast in order to reduce code redundancy and improve program structure a novel approach based on abstract syntax is presented to detect clone code and several kinds of code clones that occur frequently in programs are outlined corresponding refactoring techniques are also presented abstract syntax of the analyzed program is represented as binary tree bast isomorphism of sub bast is judged statement by statement similar statement sequences are detected as clone sequences 1 tuple clone classes are detected according to isomorphism of sub bast by the join operation of clone classes 2 tuple and other clone classes can be achieved stage by stage the experiment analyzes several open source projects and clone sequences and classes are detected four kinds of code clones are induced from the detection result which have the following characters respectively accessing different properties of the same class s objects at the same program point modifying some variable names applying the same operation to different types modifying variables defined outside the clone area all the four kinds of clone codes are refactored successfully clone class clone detection code clone software maintenance proceedings 23rd acm conference on object oriented programming systems languages and applications oopsla 2008 the proceedings contain 36 papers the topics discussed include caching and incrementalisation in the java query language interprocedural query extraction for transparent persistence deep typechecking and refactoring join patterns for visual basic whiteoak introducing structural typing into java mixing source and bytecode a case for compilation by normalization tolerating memory leaks jolt lightweight dynamic analysis and removal of object churn qvm an efficient runtime for detecting defects in deployed systems contention aware scheduler unlocking execution parallelism in multithreaded java programs dynamic optimization for efficient strong atomicity jstar towards practical verification for java verifying correct usage of atomic blocks and typestate enforcing object protocols by combining static and runtime analysis the impact of static dynamic coupling on remodularization and sound and extensible renaming for java contract specification in java classification characterization and a new marker method design by contract dbc originated in the eiffel programming language is generally accepted as a practical method for building reliable software currently however few languages have built in support for it in recent years several methods have been proposed to support dbc in java we compare eleven dbc tools for java by analyzing their impact on the developer s programming activities which are characterized by seven quality attributes identified in this paper it is shown that each of the existing tools fails to achieve some of the quality attributes this motivates us to develop ezcontract an open source dbc tool for java that achieves all of the seven quality attributes ezcontract achieves streamlined integration with the working environment notably standard java language is used and advanced ide features that work for standard java programs can also work for the contract enabled programs such features include incremental compilation automatic refactoring and code assist copyright 2008 the institute of electronics information and communication engineers characterization classification contract specification design by contract java quality attribute modularity oriented refactoring refactoring in spite of widely acknowledged as one of the best practices of object oriented design and programming still lacks quantitative grounds and efficient tools for tasks such as detecting smells choosing the most appropriate refactoring or validating the goodness of changes this is a proposal for a method supported by a tool for cross paradigm refactoring e g from oop to aop based on paradigm and formalism independent modularity assessment 2008 ieee web application evaluation and refactoring a quality oriented improvement approach rinton press web applications must be usable and accessible at the same time their continuous evolution makes it difficult to keep a high degree of external quality refactoring is a practice of agile methods well suited for the maintenance and evolution of web applications however this practice is mainly intended and used to improve maintainability and extensibility of the design and code rather than external qualities such as usability we believe that the concept of refactoring as behavior preserving transformations can be applied to the navigation and presentation models of a web application with the purpose of improving external quality for this reason we have defined the concept of web model refactoring this paper demonstrates how it is possible to improve the external quality of a web application by combining a mature quality measurement and evaluation method webqem with web model refactoring webqem is used to identify needs for improvement recommend web model refactorings and assess their impact on some defined attributes of a web product entity we present a case study showing how a typical shopping cart in an e commerce site can improve its usability and content quality with our integrated improvement approach external quality incami indicators metrics usability improvement web model refactoring web quality evaluation webqem 2nd ifip tc 2 central and east european conference on software engineering techniques cee set 2007 the proceedings contain 23 papers the special focus in this conference is on measurement processes uml and experiments the topics include formalisms in software engineering extending gqm by argument structures on metamodel based design of software metrics automatic transactions identification in use cases a collaborative method for reuse potential assessment in reengineering based product line adoption capable leader and skilled and motivated team practices to introduce extreme programming platform independent programming of data intensive applications using uml towards uml intensive framework for model driven development uml static models in formal approach alarming results from a comparative case study measuring the human factor with the rasch model empirical analysis of a distributed software development project extending software architecting processes with decision making activities a tool for supporting feature driven development in time role specific notification as formal means to balance agile practices in global software development settings an integrated approach for identifying relevant factors influencing software development productivity a framework for qos contract negotiation in component based applications a case study on the impact of refactoring on quality and productivity in an agile team support for cooperative design of end user tailorable software and considering the potential for further integration defining and detecting bad smells of aspect oriented software bad smells are software patterns that are generally associated with bad design and bad programming they can be removed by using the refactoring technique which improves the quality of software aspect oriented ao software development which involves new notions and the different ways of thinking for developing software and solving the crosscutting problem possibly introduces different kinds of design flaws defining bad smells hidden in ao software in order to point out bad design and bad programming is then necessary this paper proposes the definition of new ao bad smells moreover appropriate existing ao refactoring methods for eliminating each bad smell are presented the proposed bad smells are validated the results show that after removing the bad smells by using appropriate refactoring methods the software quality is increased 2007 ieee a programming interface for determining refactorings of object oriented software systems using clustering improving the quality of the software systems design is the most important issue during the evolution of object oriented software systems refactoring 4 is a process that helps to maintain the internal software quality during the whole software lifecycle a clustering approach for improving software systems design is introduced in 2 for the same purpose some clustering algorithms kred in 2 pamred in 8 hac in 3 that identify the appropriate refactorings for object oriented software systems were developed based on these approaches in this paper we aim at presenting a programming interface for determining refactorings of object oriented software systems using clustering rdi refactorings determination interface using this interface we can simply develop applications for determining refactorings of object oriented software systems using clustering an experiment using the designed interface is also presented 2007 ieee detection and correction of design defects in object oriented designs design defects come from poor design choices and have the effect of degrading the quality of object oriented designs therefore they present opportunities for improvements however design defects have not been precisely specified and there are few appropriate tools that allow their detection as well as their correction our goal is to provide a systematic method to specify systematically design defects precisely and to generate automatically detection and correction algorithms from their specifications the detection algorithms are based not only on metrics but also on semantical and structural properties whereas the correction algorithms are based on refactorings we apply and validate these algorithms on open source object oriented programs to show that our method allows a systematic specification a precise detection and a suitable correction of design defects antipatterns code smells design defects detection correction meta modelling refactorings specification migrating object oriented code to aspect oriented programming aspect oriented programming aop is a new programming paradigm that offers a novel modularization unit for the crosscutting concerns functionalities originally spread across several modules and tangled with each other can be factored out into a single separate unit called an aspect we investigated automated techniques that can be used to support the migration of existing object oriented programming oop code to aop to migrate an application to the new paradigm a preliminary identification of the crosscutting concerns is required aspect mining then refactoring is applied to transform the scattered concerns into aspects the proposed methods have been assessed on case studies for a total of more than half a million lines of code 2007 ieee size and frequency of class change from a refactoring perspective a previous study by bieman et al investigated whether large object oriented classes were more susceptible to change than smaller classes the measure of change used in the study was the frequency with which the features of a class had been changed over a specific period of time from a refactoring perspective the frequency of class change is of value but even for a relatively simple refactoring such as rename method multiple classes may undergo minor modification without any net increase in class and system size in this paper we suggest that the combination of versions of a class and number of added lines of code in the bad code smell detection process may give a better impression of which classes are most suitable candidates for refactoring as such effort in detecting bad code smells should apply to classes with a high growth rate as well as a high change frequency to support our investigation data relating to changes from 161 java classes was collected results concluded that it is not necessarily the case that large classes are more change prone than relatively smaller classes moreover the bad code smell detection process is informed by using the combination of change frequency and class size as a heuristic 2007 ieee loc refactoring version a software metric for coherence of class roles in java programs the purpose of software metrics is to measure the quality of programs the results can be for example used to predict maintenance costs or improve code quality an emerging view is that if software metrics are going to be used to improve quality they must help in finding code that should be refactored often refactoring or applying a design pattern is related to the role of the class to be refactored in client based metrics a project gives the class a context these metrics measure how a class is used by other classes in the context we present a new client based metric lcic lack of coherence in clients which analyses if the class being measured has a coherent set of roles in the program interfaces represent the roles of classes if a class does not have a coherent set of roles it should be refactored or a new interface should be defined for the class we have implemented a tool for measuring the metric lcic for java projects in the eclipse environment we calculated lcic values for classes of several open source projects we compare these results with results of other related metrics and inspect the measured classes to find out what kind of refactorings are needed we also analyse the relation of different design patterns and refactorings to our metric our experiments reveal the usefulness of client based metrics to improve the quality of code copyright 2007 acm cohesion design patterns java metrics refactoring toward an implementation of the form template method refactoring this paper presents an implementation of the form template method refactoring this transformation has not been automated yet but has many similarities with other transformations such as clone detection and removal or method extraction forming a template method is a difficult process because it has to deal with code statements directly few abstractions and algorithms have been investigated yet compared to transformations dealing with higher level aspects such as the classes methods fields and their relations we present a new algorithm that performs this transformation in a semi automated way on java programs we state the difficulties inherent to this transformation and propose solutions to handle them 2007 ieee declarative object identity using relation types object oriented languages define the identity of an object to be an address based object identifier the programmer may customize the notion of object identity by overriding the equals and hashcode methods following a specified contract this customization often introduces latent errors since the contract is unenforced and at times impossible to satisfy and its implementation requires tedious and error prone boilerplate code relation types are a programming model in which object identity is defined declaratively obviating the need for equals and hashcode methods this entails a stricter contract identity never changes during an execution we formalize the model as an adaptation of featherweight java and implement it by extending java with relation types experiments on a set of java programs show that the majority of classes that override equals can be refactored into relation types and that most of the remainder are buggy or fragile springer verlag berlin heidelberg 2007 mining software evolution to predict refactoring can we predict locations of future refactoring based on the development history in an empirical study of open source projects we found that attributes of software evolution data can be used to predict the need for refactoring in the following two months of development information systems utilized in software projects provide a broad range of data for decision support versioning systems log each activity during the development which we use to extract data mining features such as growth measures relationships between classes the number of authors working on a particular piece of code etc we use this information as input into classification algorithms to create prediction models for future refactoring activities different state of the art classifiers are investigated such as decision trees logistic model trees propositional rule learners and nearest neighbor algorithms with both high precision and high recall we can assess the refactoring proneness of object oriented systems although we investigate different domains we discovered critical factors within the development life cycle leading to refactoring which are common among all studied projects 2007 ieee api evolution support with diff catchup refactoring is an important activity in the evolutionary development of object oriented software systems several ides today support the automated application of some refactorings at the same time there is substantial on going research aimed at developing support for deciding when and how software should be refactored and for estimating the effect of the refactoring on the quality requirements of the software on the other hand understanding the refac torings in the evolutionary history of a software system is essential in understanding its design rationale which might be very helpful in assisting future maintenance and evolution tasks the jdevan tool supports a comprehen sive refactoring analysis process including the extraction of logical design elements and relations from the system s code the recovery of design level changes from one version to the next the identification of refactorings as compo sitions of such changes and the interactive visualization and analysis of the recovered changes in this paper we discuss jdevan method and argue for its effectiveness with two case studies on realistic open source object oriented software in the context of which we show how the recovered refactoring knowledge may be used to guide future development 2007 ieee d 2 10 g object oriented design methods d 2 2 eprogrammer workbench d 2 3 coding tools and techniques d 2 3 a object oriented programming object oriented programming refactoring restructuring software systems using clustering in this paper we are focusing on the problem of restructuring object oriented software systems using clustering techniques refactoring 1 is one major issue to improve the design of software systems increasing the internal software quality this paper aims at introducing a new k medoids based clustering algorithm that can be used for improving the design of software systems by identifying the needed refactorings the algorithm uses a measure that evaluates a software system design clustering 2 is used in order to recondition the class structure of a software system the proposed approach can be useful for assisting software engineers in their daily works of refactoring software systems we evaluate our approach using the open source case study jhotdraw 3 illustrating the advantages of our approach in comparison with existing approaches 2007 ieee clustering refactoring system design improving predictive models of cognitive complexity using an evolutionary computational approach a case study the development of software is a human endeavor and program comprehension is an important factor in software maintenance predictive models can be used to identify software components as potentially problematic for the purpose of future maintenance such modules could lead to increased development effort and as such may be in need of mitigating actions such as refactoring or assigning more experienced developers source code metrics can be used as input features to classifiers however there exist a large number of structural measures that capture different aspects of coupling cohesion inheritance complexity and size in machine learning feature selection is the process of identifying a subset of attributes that improves a classifier s performance this paper presents initial results when using a genetic algorithm as a method of improving a classifier s ability to discover cognitively complex classes that degrade program understanding copyright 2007 national research council canada dean jin scheduling of conflicting refactorings to promote quality improvement software refactoring is to restructure object oriented software to improve its quality especially extensibility reusability and maintainability while preserving its external behaviors for a special software system there are usually quite a few refactorings available at the same time but these refactorings may conflict with each other in other words carrying out a refactoring may disable other refactorings consequently only a subset of the available refactorings can be applied together and which refactorings will be applied depends on the schedule application order of the refactorings furthermore carrying out different subsets of the refactorings usually leads to different improvement of software quality as a result in order to promote the improvement of software quality refactorings should be scheduled rationally however how to schedule refactorings is rarely discussed usually software engineers carry out refactorings immediately when they are found out they do not wait until all applicable refactorings are found out and scheduled in other words the refactorings are not scheduled explicitly and conflicts among them are not taken into consideration though more and more refactorings are formalized and automated by refactoring tools refactoring tools apply refactorings usually in a nondeterministic fashion in random in this paper we propose a scheduling approach to schedule conflicting refactorings to promote the improvement of software quality achieved by refactorings conflicts among refactorings are detected and then a scheduling model is presented and then a heuristic algorithm is proposed to solve the scheduling model results of experiments suggest that the proposed scheduling approach is effective in promoting the improvement of software quality copyright 2007 acm conflict quality schedule software refactoring 3rd international ieee workshop on software evolvability 2007 se the proceedings contain 11 papers the topics discussed include complexity of finite state machines as a tool for understanding software evolution enhancing software evolution through design pattern detection attributes for characterizing the evolution of architectural design decisions size and frequency of class change from a refactoring perspective defining software evolvability from a free open source software perspective tracing software evolution history with design goals a tentative technique for the study and planning of co evolution in product software startups the darwin project evolvability of software intensive systems floss managed data sources maturity level a first attempt software phenetics phylogeny and evolution a requirement level modification analysis support framework and software evolvability an ecosystem point of view the crss metric for package design quality package design is concerned with the determining the best way to partition the classes in a system into subsystems a poor package design can adversely affect the quality of a software system in this paper we present a new metric class reachability set size crss the distribution of which can be used to determine if the relationships between the classes in a system preclude it from a good package design we compute crss distributions for programs in a software corpus in order to show that some real programs are precluded in this way also we show how the crss metric can be used to identify candidates for refactoring so that the potential package structure of a system can be improved copyright 2007 australian computer society inc 13th americas conference on information systems amcis 2007 volume 2 the proceedings contain 68 papers the special focus in this conference is on information systems business improvements and mobile technologies in business in america the topics include is professionals assess the usefulness of the four most common is courses mastery level learning and the art of database design is curriculum recommendations for web courses based on current technology use by fortune 400 companies exploring technology frames through interview narratives an empirical study examining the usage and perceived importance of xp practices an integrated framework for code reuse and refactoring in extreme programming development of an information technology audit process quality framework the role of diversity and technology in global virtual teams the impacts of electronic collaboration and information exploitation capability on firm performance leader delegation task significance and trust in global software development teams a facilitators perspective on successful virtual communities of practice the role of it human capability in knowledge transfer process under it outsourcing situations an agent based reverse pricing model for reducing bullwhip effect in supply chains multi dimensional data visualization techniques for exploring financial performance data classification algorithm sensitivity to training data with non representative attribute noise the roles of positive and negative utility in predicting online wine purchase behaviour the moderating role of perceived effectiveness of third party control on trust and online purchasing intentions and estimating risk in information technology projects inspecting automated test code a preliminary study testing is an essential part of an agile process as test is automated and tends to take the role of specifications in place of documents however whenever test cases are faulty developers time might be wasted to fix problems that do not actually originate in the production code because of their relevance in agile processes we posit that the quality of test cases can be assured through software inspections as a complement to the informal review activity which occurs in pair programming inspections can thus help the identification of what might be wrong in test code and where refactoring is needed in this paper we report on a preliminary empirical study where we examine the effect of conducting software inspections on automated test code first results show that software inspections can improve the quality of test code especially the repeatability attribute the benefit of software inspections also apply when automated unit tests are created by developers working in pair programming mode springer verlag berlin heidelberg 2007 automated testing empirical study pair programming refactoring software inspection unit test model driven engineering languages and systems 10th international conference models 2007 proceedings the proceedings contain 46 papers the topics discussed include reconciling tggs with qvt guided development with multiple domain specific languages an empirical study of the impact of ocl smells and refactorings on the understandability of ocl specifications on metamodeling in megamodels improving inconsistency resolution with side effect evaluation and costs model composition in product lines and feature interaction detection using critical pair analysis automated semantic analysis of design models piecewise modelling with state subtypes deriving operation contracts from uml class diagrams model driven approach for managing human interface design life cycle integrating heterogeneous tools into model centric development of interactive applications a business process driven approach for generating e commerce user interfaces and integrated definition of abstract and concrete syntax for textual languages icsm 2007 proceedings of the 2007 ieee international conference on software maintenance the proceedings contain 72 papers the topics discussed include the inevitable stability of software change mining the lexicon used by programmers during software evolution evidence based analysis and inferring preconditions for bug detection feature location and extraction using landmarks and barriers matching control flow of program versions tracing model elements design recovery and maintenance of build systems multi objective genetic algorithm to support class responsibility assignment a maintainable software architecture for fast and modular bioinformatics sequence search applying interface contract mutation in regression testing of component based software automated refactoring of legacy java software to enumerated types computation of static execute after relation with applications to software maintenance and automatic test generation from gui applications for testing web services jdeodorant identification and removal of feature envy bad smells in this demonstration we present an eclipse plug in that identifies feature envy bad smells in java projects and resolves them by applying the appropriate move method refactorings the main contribution is the ability to pre evaluate the impact of all possible move refactorings on design quality and apply the most effective one 2007 ieee feature diagrams and logics there and back again feature modeling is a notation and an approach for modeling commonality and variability in product families in their basic form feature models contain mandatory optional features feature groups and implies and excludes relationships it is known that such feature models can be translated into propositional formulas which enables the analysis and configuration using existing logicbased tools in this paper we consider the opposite translation problem that is the extraction of feature models from propositional formulas we give an automatic and efficient procedure for computing a feature model from a formula as a side effect we characterize a class of logical formulas equivalent to feature models and identify logical structures corresponding to their syntactic elements while many different feature models can be extracted from a single formula the computed model strives to expose graphically the maximum of the original logical structure while minimizing redundancies in the representation the presented work furthers our understanding of the semantics of feature modeling and its relation to logics opening avenues for new applications in reverse engineering and refactoring of feature models 2007 ieee analysis of measurement set qualitative characteristics for state estimation purposes the paper proposes a new tool for real time assessment of measurement sets in the context of power system state estimation this tool incorporates many functions including observability analysis and restoration as well as identification of critical measurements and critical sets using only network topology data the proposed methodology updates the qualitative characteristics of the current available measurement set in real time the identification of critical measurements and sets is done using only network topology and is completed before running any state estimation mapping the system states and using information concepts a new state space is obtained where the relationship information between measurements and states is straightforward this map is easily found via triangular factorisation of the jacobian matrix starting from a basecase measurement set every time a snapshot of measurements has to be analysed only refactorisation has to be carried out sparse matrix techniques speed up the process the method was tested in the ieee 14 bus system as well as in the brazilian 383 bus system proving to be reliable fast easy to implement and suitable for real time operation the institution of engineering and technology 2007 31st annual ieee software engineering workshop sew 31 2007 proceedings the proceedings contain 31 papers the topics discussed include determining the applicability of agile practices to mission and life critical systems a framework for flexible and executable usability patterns standards aspect oriented requirements modeling using model checking to validate style specific architectural refactoring patterns research on aspect connectors for software architecture adaptation an alternative method employing uses cases for early effort estimation a reference net based formalization of concurrent cognitive decision making algebraic approach to operational semantics and observation oriented semantics for a timed shared variable language with probability a refinement based framework for computing loop behavior looking into compensable transactions a software safety risk taxonomy for use in retrospective safety cases and modeling and verifying web services choreography using process algebra simultaneous modification support based on code clone analysis maintaining software systems becomes more difficult as their size and complexity increase one factor that makes software maintenance more difficult is the presence of code clones a code clone is defined as a code fragment occurring more than once in identical or similar form into a software system for example the presence of code clones is a big factor of overlooking some places that should be modified simultaneously one technique that helps the number of code clones is refactoring there are several research efforts that provide support to refactor code clones but unfortunately some code clones cannot or should not be refactored ex stereotyped process absence of abstraction functionality performance enhancement in order to support maintaining the consistency among code clones we propose a simultaneous modification support method given a software system firstly a maintainer identifies a code fragment that must be modified then only the code clones between the identified code fragment and the source files of the software system are detected we developed a simultaneous modification support tool libra and applied it to open source software systems the results showed that libra was a good searching tool as much as grep which is a useful tool of unix 2007 ieee a survey of reasoning in parallelization we elaborate on reasoning in contemporary semi automatic parallelizing refactoring as the main contribution we summarize contemporary approaches and show that all attempts to reason in parallelization thus far have amounted to local code analysis given data and control dependencies we conclude that by retaining this perspective only parallelization continues to exploit merely a subset of the reasoning methods available today and is likely to remain limited to address this problem we suggest to expand the local analyses such that they take seriously relations between individual local parallelizing transformations we argue that such a coupling allows to process sparser parallelizable constructs such as producer consumer coordination we identify questions to be addressed to put this principle into action and report on going work on reasoning mechanisms able to support this 2007 ieee use of a genetic algorithm to identify source code metrics which improves cognitive complexity predictive models in empirical software engineering predictive models can be used to classify components as overly complex such modules could lead to faults and as such may be in need of mitigating actions such as refactoring or more exhaustive testing source code metrics can be used as input features for a classifier however there exist a large number of measures that capture different aspects of coupling cohesion inheritance complexity and size in a large dimensional feature space some of the metrics may be irrelevant or redundant feature selection is the process of identifying a subset of the attributes that improves a classifier s discriminatory performance this paper presents initial results of a genetic algorithm as a feature subset selection method that enhances a classifier s ability to discover cognitively complex classes that degrade program understanding 2007 ieee encapsulating objects with confined types object oriented languages provide little support for encapsulating objects reference semantics allows objects to escape their defining scope and the pervasive aliasing that ensues remains a major source of software defects this paper presents kacheck j a tool for inferring object encapsulation properties of large java programs our goal is to develop practical tools to assist software engineers thus we focus on simple and scalable techniques kacheck j is able to infer confinement the property that all instances of a given type are encapsulated in their defining package this simple property can be used to identify accidental leaks of sensitive objects as well as for compiler optimizations we report on the analysis of a large body of code and discuss language support and refactoring for confinement 2007 acm tracking code clones in evolving software code clones are generally considered harmful in software development and the predominant approach is to try to eliminate them through refactoring however recent research has provided evidence that it may not always be practical feasible or cost effective to eliminate certain clone groups we propose a technique for tracking clones in evolving software our technique relies on the concept of abstract clone region descriptors crd which describe clone regions within methods in a robust way that is independent from the exact text of the clone region or its location in a file we present our definition of crds and describe a complete clone tracking system capable of producing crds from the output of a clone detection tool notify developers of modifications to clone regions and support the simultaneous editing of clone regions we report on two experiments and a case study conducted to assess the performance and usefulness of our approach 2007 ieee relationship between age and refractive predictability of excimer laser in situ keratomileusis objective to explore the relationship between age and refractive predictability of excimer laser in situ keratomileusis lasik for the correction of myopia design retrospective case series participants 362 patients 703 eyes who had performed lasik methods according to the age patients were divided into four groups ≤30y 31 34y 35 39y and ≥40y their preoperative and postoperative refractive powers examined with automatic refactor as well as manifest optometry were analysed and followed up from 6 months to 2 years according to pre operative refractive power patietns were divided into low and moderate myopia group ≤ 6 00d high myopia group 6 25 ∼ 12 00d and super high myopia group ≥ 12 25d the eyes with refractive power at post operative 2 years ≥ 1 00d were regressive eyes main outcome measures refractive error before surgery intended residual refractive power and 3 6 12 24 months post operative refractive powers results there were no significant differences between intended residual refractive powers and refractive powers at post operative 6 month in 3 groups 40y p 0 059 0 369 0 546 while there were significant differences in the group of ≥40y p 0 001 there were significant differences on the rate of regression among groups according or refractive power a significant positive correlation was found between regression and refractive error before surgery regression in 57 83 patients was found among post operative 6 months conclusions the refractive predictability of lasik was influenced by age refractive error and postoperative time for older high myopic patients indication for lasik should be well known strictly attempted correction should be adjusted according to age the degree of myopia habit of eye using to get more satisfactory effects age excimer laser in situ keratomileusis refractive power automatic inference of structural changes for matching across program versions mapping code elements in one version of a program to corresponding code elements in another version is a fundamental building block for many software engineering tools existing tools that match code elements or identify structural changes refactorings and api changes between two versions of a program have two limitations that we overcome first existing tools cannot easily disambiguate among many potential matches or refactoring candidates second it is difficult to use these tools results for various software engineering tasks due to an unstructured representation of results to overcome these limitations our approach represents structural changes as a set of high level change rules automatically infers likely change rules and determines method level matches based on the rules by applying our tool to several open source projects we show that our tool identifies matches that are difficult to find using other approaches and produces more concise results than other approaches our representation can serve as a better basis for other software engineering tools 2007 ieee corpus refactoring a feasibility study background most biomedical corpora have not been used outside of the lab that created them despite the fact that the availability of the gold standard evaluation data that they provide is one of the rate limiting factors for the progress of biomedical text mining data suggest that one major factor affecting the use of a corpus outside of its home laboratory is the format in which it is distributed this paper tests the hypothesis that corpus refactoring changing the format of a corpus without altering its semantics is a feasible goal namely that it can be accomplished with a semi automatable process and in a time effcient way we used simple text processing methods and limited human validation to convert the protein design group corpus into two new formats wordfreak and embedded xml we tracked the total time expended and the success rates of the automated steps results the refactored corpus is available for download at the bionlp sourceforge website http bionlp sourceforge net the total time expended was just over three person weeks consisting of about 102 hours of programming time much of which is one time development cost and 20 hours of manual validation of automatic outputs additionally the steps required to refactor any corpus are presented conclusion we conclude that refactoring of publicly available corpora is a technically and economically feasible method for increasing the usage of data already available for evaluating biomedical language processing systems 2007 johnson et al licensee biomed central ltd analysing refactoring dependencies using graph transformation refactoring is a widely accepted technique to improve the structure of object oriented software nevertheless existing tool support remains restricted to automatically applying refactoring transformations deciding what to refactor and which refactoring to apply still remains a difficult manual process due to the many dependencies and interrelationships between relevant refactorings in this paper we represent refactorings as graph transformations and we propose the technique of critical pair analysis to detect the implicit dependencies between refactorings the results of this analysis can help the developer to make an informed decision of which refactoring is most suitable in a given context and why we report on several experiments we carried out in the agg graph transformation tool to support our claims springer verlag 2007 agg critical pair analysis dependency analysis graph transformation refactoring bridging the gap between aspect mining and refactoring aspect mining techniques help to identify crosscutting structure that could potentially be modularized through object oriented oo or aspect oriented refactoring ao this paper describes a case study in which we used aspect mining techniques to identify and refactor crosscutting concerns using aspect oriented programming we observed that in our case there were many subtle variations in the implementation of the concerns that made them non trivial to modularize with ao refactoring in the end we solved our modularization problem using traditional oo refactoring we conclude that there exists an important gap between the identification of crosscutting concerns and the technologies available to mitigate the problem copyright 2007 acm towards automated restructuring of object oriented systems software aging is an important cost contributor to the maintenance of aging software systems recent years have brought significant progress in the area of automatic detection of code smells as well as tool support for refactoring and implementing design patterns in the code nonetheless there is hardly any tool support to help the maintainer decide how to refactor in a given situation such that the recommended refactorings are also meaningful in that particular situation most of the existing techniques are either merely supporting the process such as visualizations or cannot guarantee meaningful refactorings such as optimization based techniques this paper introduces and experimentally evaluates a novel tool supported approach to determine meaningful refactorings to structural flaws in object oriented systems the refactorings recommended by our approach are guaranteed to lead to a meaningful and more maintainable structure in each analyzed situation the approach contributes to a dramatic reduction of costs by reducing the need and scope of detailed manual code analysis 2007 ieee high impact refactoring based on architecture violations software refactoring has been identified as a key technique for the maintenance and evolution of object oriented system most interesting are high impact refactorings that is refactorings that have a strong impact on the quality of the system s architecture bad smells and code metrics have been suggested as means for identifying refactormg needs according to our experience these techniques are useful yet in order to spot opportunities for high impact refactorings they should be complemented with the analysis of architectural violations the subject of this report is a mid sized java enterprise application from the telecommunications domain whose functionality had to be radically extended we show how we combined several tools and techniques to identify opportunities for high impact refactorings and discuss the resulting architecture the refactoring process tool support as well as related experiences 2007 ieee proceedings csmr 2007 11th european conference on software maintenance and reengineering software evolution in complex software intensive systems the proceedings contain 44 papers the topics discussed include a case study of defect density and charge density and their progress over time consistently incorporating changes to evolve transition based systems a probabilistic approach to predict changes in object oriented software systems towards automatic restructuring of object oriented systems a feature oriented adaptive component model for dynamic evolution a maintenance oriented framework for software components characterization metamodel based inference of inter model correspondence how clones are maintained an empirical study exploring inter module relationships in evolving software systems the dynamic function coupling metric and its use in software evolution online construction of dynamic object process graphs and high impact refactoring based on architecture violations an empirical study of the bad smells and class error probability in the post release object oriented system evolution bad smells are used as a means to identify problematic classes in object oriented systems for refactoring the belief that the bad smells are linked with problematic classes is largely based on previous metric research results although there is a plethora of empirical studies linking software metrics to errors and error proneness of classes in object oriented systems the link between the bad smells and class error probability in the evolution of object oriented systems after the systems are released has not been explored there has been no empirical evidence linking the bad smells with class error probability so far this paper presents the results from an empirical study that investigated the relationship between the bad smells and class error probability in three error severity levels in an industrial strength open source system our research which was conducted in the context of the post release system evolution process showed that some bad smells were positively associated with the class error probability in the three error severity levels this finding supports the use of bad smells as a systematic method to identify and refactor problematic classes in this specific context 2006 elsevier inc all rights reserved bad smells design evolution empirical study object oriented design open source software software metrics proceedings 14th ieee international conference on program comprehension icpc 2006 the proceedings contain 40 papers the topics discussed include digging the development dust for refactorings studying the evolution of software systems using change clusters a synergistic approach to program comprehension dynamic analysis of software systems using execution pattern mining integrating reverse engineering tools using a service sharing methodology an architecture to support model driven software visualization automated extraction of database interactions in web applications an approach for extracting workflows from e commerce applications leveraged quality assessment using information retrieval techniques a metric based heuristic framework to detect object oriented design flaws dynamic data structure analysis for java programs profile based approach to support comprehension of software behavior the cognitive assignment eclipse plug in fluid source code views understanding obfuscated code and reverse engineering scripting language extensions detecting similar java classes using tree algorithms similarity analysis of source code is helpful during development to provide for instance better support for code reuse consider a development environment that analyzes code while typing and that suggests similar code examples or existing implementations from a source code repository mining software repositories by means of similarity measures enables and enforces reusing existing code and reduces the developing effort needed by creating a shared knowledge base of code fragments in information retrieval similarity measures are often used to find documents similar to a given query document this paper extends this idea to source code repositories it introduces our approach to detect similar java classes in software projects using tree similarity algorithms we show how our approach allows to find similar java classes based on an evaluation of three tree based similarity measures in the context of five user defined test cases as well as a preliminary software evolution analysis of a medium sized java project initial results of our technique indicate that it 1 is indeed useful to identify similar java classes 2 successfully identifies the ex ante and ex post versions of refactored classes and 3 provides some interesting insights into within version and between version dependencies of classes within a java project copyright 2006 acm change analysis software evolution software repositories tree similarity measures does god class decomposition affect comprehensibility continuous alterations and extensions of a software system introduce so called god classes accumulating ever more responsibilities as god classes make essential steps in program comprehension harder it is expected that effective and efficient techniques to resolve them will facilitate future maintenance tasks this work reports on a laboratory experiment with 63 computer science students in which we verified whether the decomposition of a god class using well known refactorings can affect comprehensibility of the relevant code part five alternative god class decompositions were derived through application of refactorings by which the responsibilities of a natural god class were increasingly split into a number of collaborating classes our results indicate that the derived class decompositions differed significantly with regard to the ability of students to map attributes in the class hierarchy to descriptions of the problem domain moreover this effect has been found to interact with the institution in which the participants were enrolled confirming that comprehensibility is a subjective notion for which we have to take into account people s skills and expectations this work indicates that improving comprehensibility is within the grasp of a single maintainer preparing for future change requests by redistributing the responsibilities of a god class using well known refactorings comprehension decomposition refactoring paying down design debt with strategic refactoring our studies indicate that strategic refactoring using design patterns is the most effective way to repair decaying code for object oriented oo systems however applying a pattern based approach to legacy system repair or even post design pattern injection is often difficult and in some cases if misapplied detrimental 2006 ieee software technologies strategic refactoring refactoring detection based on umldiff change facts queries refactoring is an important activity in the evolutionary development of object oriented software systems several ides today support the automated application of some refactorings at the same time there is substantial on going research aimed at developing support for deciding when and how software should be refactored and for estimating the effect of the refactoring on the quality requirements of the software on the other hand understanding the refactorings in the evolutionary history of a software system is essential in understanding its design rationale yet only very limited support exists for detecting refactorings in this paper we present our approach for detecting refactorings by analyzing the system evolution at the design level we evaluate our method with case studies examining two realistic examples of object oriented software 2006 ieee towards a catalogue of refactorings and code smells for aspectj in this paper we contribute to the characterisation of a programming style specific to aspect oriented programming for this purpose we present a collection of refactorings for aspect oriented source code comprising refactorings to enable extraction to aspects of crosscutting concerns from object oriented legacy code the subsequent tidying up of the extracted aspects and factoring out of common code from similar aspects to superaspects the second group of refactorings is documented in detail in addition we propose some new aspect oriented code smells including one smell that is specific to aspect modules we also propose a reinterpretation of some of the traditional object oriented code smells in the light of aspect orientation to detect the presence of crosscutting concerns springer verlag berlin heidelberg 2006 proceedings of the 10th european conference on software maintenance and reengineering csmr 2006 the proceedings contain 46 papers the topics discussed include integrating legacy software into a service oriented architecture analyzing the reuse potential of migrating legacy components to a service oriented architecture object oriented legacy system trace based logic testing can lsi help reconstructing requirements traceability in design and test realistic load testing of web applications scenario driven dynamic analysis for comprehending large software systems regaining lost knowledge through dynamic analysis and aspect orientation an industrial experience report a language independent framework for context sensitive formatting qscope an open extensible framework for measuring software projects a framework for software architecture refactoring using model transformations and semantic annotations case studies of visual language based design patterns recovery and efficient identification of design patterns with bit vector algorithm from bad smells to refactoring metrics smoothing the way this chapter presents a study on the relation of refactoring bad smells and metrics the notions of refactoring and bad smells are revised as well as metrics that can be used as guides in the refactoring process connection among those metrics the usual flaws that could be suggested by them and the required corrective actions to reduce or erase these flaws are analyzed the usual flaws can be described in terms of bad smells and the corrective actions in terms of the refactoring operations suggested by each bad smell then we can go from metrics to bad smells and from this to refactoring the chapter also describes solutions for tool support in a language independent manner in this sense it describes the tool architecture which can be defined as metamodel centered a metamodel representing a family of languages is defined as well as framework based solutions for collecting metrics as well as for a refactoring engine and repository these solutions allow reusing the effort on a wide family of object oriented languages the developed frameworks were instantiated to work on instances of our own metamode l in addition to this it also describes how to use the approach and its support with other metamodels finally a case study on the use of metrics in bad smells detection is presented 2007 idea group inc refactoring practice how it is and how it should be supported an eclipse case study refactoring is an important activity in the evolutionary development of object oriented software systems yet several questions about the practice of refactoring remain unanswered such as what fraction of code modifications are refactorings and what are the most frequent types of refactorings to gain some insight in this matter we conducted a detailed case study on the structural evolution of eclipse an integrated development environment ide and a plugin based framework our study indicates that 1 about 70 of structural changes may be due to refactorings 2 for about 60 of these changes the references to the affected entities in a component based application can be automatically updated by a refactoring migration tool if the relevant information of refactored components can be gathered through the refactoring engine and 3 state of the art ides such as eclipse support only a subset of commonly applied low level refactorings and lack support for more complex ones which are also frequent based on our findings we draw some conclusions on high level design requirements for a refactoring based development environment 2006 ieee identifying refactoring opportunities by identifying dependency cycles the purpose of refactoring is to improve the quality of a software system by changing its internal design so that it is easier to understand or modify or less prone to errors and so on one challenge in performing a refactoring is quickly determining where to apply it we present a tool jepends that analyses the source code of a system in order to identify classes as possible refactoring candidates our tool identifies dependency cycles among classes because long cycles are detrimental to understanding testing and reuse we demonstrate our tool on a widelydownloaded open source medium sized java program and show how cycles can be eliminated through a simple refactoring copyright 2006 australian computer society inc common refactorings a dependency graph and some code smells an empirical study of java oss refactoring as a software engineering discipline has emerged over recent years to become an important aspect of maintaining software refactoring refers to the restructuring of software according to specific mechanics and principles in this paper we describe an analysis of the results from a tool whose purpose was to identify and extract refactorings from seven open source java systems in particular we analyzed the mechanics of the most commonly and least commonly applied refactorings to try and account for their frequency results showed the most common refactorings of the fifteen coined a gang of six to be generally those with a high in degree and low out degree when mapped on a dependency graph the same refactorings also featured strongly in the remedying of bad code smells remarkably and surprisingly inheritance and encapsulation based refactorings were found to have been applied relatively infrequently we offer explanations for why this may be the case the paper thus identifies core refactorings central to many of the changes made by developers on open source systems while we can not guarantee that developers consciously undertake refactoring in any sense the empirical results demonstrate that simple renaming and moving fields methods between classes are common components of open source system re engineering from a wider software engineering perspective knowledge of what a modification will incur in likely sub tasks is of value to developers whether working on open source or other forms of software copyright 2006 acm code smells refactoring taxonomy testing drivers for software refactoring decisions this paper presents an empirical study of drivers for software refactoring decisions we studied the refactoring decisions made by 37 students evaluating ten methods of a purposefully constructed java program the decision rationales reported by the evaluators were coded to identify the drivers behind the decisions the identified drivers were categorized into structure documentation visual representation and general drivers the evaluators had conflicting opinions both regarding the internal quality of the methods and refactoring decisions complex code problems were detected only by experienced evaluators using regression analysis we looked at the predictive value of drivers explaining the refactoring decisions the most salient driver leading to a favourable refactoring decision was method size this study provides information of the refactoring decisions and helps form a basis for creating code problem detectors by comparing automatic detection and the identified drivers we gained understanding of code problems that are difficult or impossible to detect automatically for example poor algorithm issues detected only by experienced developers and code problems for which the human eye surpasses automatic detection indicate good areas for developer education copyright 2006 acm code smells evolvability maintainability qualitative analysis refactoring the composition refactoring triangle crt practical toolkit from spaghetti to lasagna adding to and restructuring the design of a large existing code base is known to be a difficult and time consuming task there are methods for assisting these challenges such as composition refactoring reengineering and anti patterns detection methods most of these methods concentrate on specific perspectives of software engineering this practical paper presents the composition refactoring triangle crt unified approach for handling multiple changes across complex environments the crt is a combination of the process crp the management tool crmt and the external and internal refactoring elements the crt was constructed during on going need to implement major changes within a living product this paper contains the via delarosa the path of suffering which describes the road of how the crt was created and why other methods failed practical evaluation was conducted using the crt demonstrating its capabilities the unified perspectives of the crt enable improved risk analysis and technical control over multiple architectural evolution changes and their relative dependencies its implementation encourages quick testing procedure code correctness and short time to market response of the development team anti patterns architecture centric evolution design methodology refactoring requirements traceability tracking ripcord rapid interface prototyping for cordless devices mobile devices such as cellular phones are indispensable in our daily life the success and penetration of the market of mobile services and applications does not only depend on good innovative ideas but also on their usability therefore several endeavors have been made to tackle these problems in order to provide suitable usability testing methods for user interfaces but traditional testing methods cannot always be extended to mobile devices directly in contrast to the widely standardized and static testing setup for desktop pcs the variety of physical device specific characteristics as well as the highly dynamic context of use 5 influences these methods in this paper we propose a novel approach for prototyping and testing mobile applications and services it enables testing user interfaces and recording the interaction within context of use in early stages of the product development and therefore allows determining conceptional or design flaws before they can cause cost intensive corrections or even refactoring of the product besides its direct applicability this approach allows us to elaborate if and how classical usability testing methods can be transferred to mobile devices and how they are influenced by the device specific characteristics copyright 2006 acm mobile phones rapid prototyping usability testing identifying good architectural design alternatives with multi objective optimization strategies architecture trade off analysis methods are appropriate techniques to evaluate design decisions and design alternatives with respect to conflicting quality requirements however the identification of good design alternatives is a time consuming task which is currently performed manually to automate this task this paper proposes to use evolutionary algorithms and multi objective optimization strategies based on architecture refactorings to identify a sufficient set of design alternatives this approach will reduce development costs and improve the quality of the final system because an automated and systematic search will identify more and better design alternatives architecture refactorings architecture trade off analysis dependability multi objective optimization identifying refactorings from source code changes software has been and is still mostly refactored without tool support moreover as we found in our case studies programmers tend not to document these changes as refactorings or even worse label changes as refactorings although they are not in this paper we present a technique to detect changes that are likely to be refactorings and rank them according to the likelihood the evaluation shows that the method has both a high recall and a high precision it finds most of the refactorings and most of the found refactoring candidates are really refactorings 2006 ieee phoenix based clone detection using suffix trees a code clone represents a sequence of statements that are duplicated in multiple locations of a program clones often arise in source code as a result of multiple cut paste operations on the source or due to the emergence of crosscutting concerns programs containing code clones can manifest problems during the maintenance phase when a fault is found or an update is needed on the original copy of a code section all similar clones must also be found so that they can be fixed or updated accordingly the ability to detect clones becomes a necessity when performing maintenance tasks however if done manually clone detection can be a slow and tedious activity that is also error prone a tool that can automatically detect clones offers a significant advantage during software evolution with such an automated detection tool clones can be found and updated in less time moreover restructuring or refactoring of these clones can yield better performance and modularity in the program this paper describes an investigation into an automatic clone detection technique developed as a plug in for microsoft s new phoenix framework our investigation finds function level clones in a program using abstract syntax trees asts and suffix trees an ast provides the structural representation of the code after the lexical analysis process the ast nodes are used to generate a suffix tree which allows analysis on the nodes to be performed rapidly we use the same methods that have been successfully applied to find duplicate sections in biological sequences to search for matches on the suffix tree that is generated which in turn reveal matches in the code clone detection code clones software analysis suffix trees proceedings of the isca 15th international conference on software engineering and data engineering sede 2006 the proceedings contain 53 papers the topics discussed include traceability for managing evolutionary change mercury a process management system based on the agent technology management support of interorganizational cooperative software development processes based on dynamic process views agile plan refactoring extending reverse inheritance a strategy to integrate legacy systems debugging with software visualization and contract discovery a method to improve software testability alternative approach to utilize software defect reports estimating software reliability with static analysis techniques software defect fractal description operational and program schemas a framework for requirements elicitation techniques selection the effects of requirements and task uncertainty on software product quality correctness as a relative gradual software property and remote sensing and prompting for early stage dementia patients ifip working conference on software engineering techniques set 2006 the proceedings contain 35 papers the special focus in this conference is on software engineering techniques the topics include scenario based component behavior filtration mobile ambients in aspect oriented software architectures the architecture of distributed systems driven by autonomic patterns an optimizing ocl compiler for metamodeling and model transformation environments modeling of component based self adapting context aware applications for mobile devices a performance analysis infrastructure for component based system hosted by middleware estimation of mean response time of multi agent systems integrated approach to modelling and analysis using rtcp nets hybrid modeling and verification of java based software an evolutionary approach to project management process improvement for software intensive projects improved bayesian networks for software project risk assessment using dynamic discretisation software risk management an approach to software quality specification and evaluation spoqe feedback from users on a software product to improve its quality in engineering application automatic software validation process an analysis of use case based testing approaches based on a defect taxonomy minimizing test execution time during test generation an integrated regression testing framework to multi threaded java programs dynalloy as a formal method for the analysis of java programs verification of uml state diagrams using concurrent state machines aspect oriented response injection advanced mutation operators applicable in c programs an open platform of data quality monitoring for erp information systems managing data from heterogeneous data sources using knowledge layer checkpoint based resumption in data warehouses a c refactoring browser and method extraction esc java2 as a tool to ensure security in the source code of java applications a tool for maintaining proper java code structure and multidimensional legacy aspects of modernizing web based systems a fast and reliable quadratic approach for q adjustments in fast decoupled load flow model the paper presents a new fast reliable and relatively simple decoupled quadratic load flow dqlf algorithm for q adjustments in power flow solutions q adjusted solutions are inevitable for reactive power planning and management studies for solving power flow problems the fast decoupled load flow fdlf is probably the most popular because of its efficiency but for q adjusted studies the matrix updating problem associated with b″ matrix remains unresolved refactorization of b″ matrix demands more cpu time the proposed approach eliminates formation and refactorization of b″ matrix for both well behaved and ill conditioned systems of q unadjusted and adjusted cases the new method minimizes the computational burden by solving for the busbar voltage magnitudes v using a non linear quadratic equation and it reduces the execution time significantly the solution of this non linear equation undoubtedly offers better solution than that of a linear version improved and reliable convergence on normal and ill conditioned system is expected enforcement of q limits is also very simple and effective the proposed algorithm also proved to handle large degrees of ill conditioning in q adjusted studies compared to the standard fdlf model the performance of the proposed model is investigated by a number of case studies on ieee test systems 14 30 57 118 bus and results are reported for ieee 118 bus system the results indicate the established better convergence and reliability of the proposed model it is atleast 50 faster than the traditional fdlf model for q adjusted case studies copyright kth 2006 decoupled quadratic load flow dqlf fast decoupled load flow fdlf ill condition r factor model refactorings through rule based inconsistency resolution the goal of model driven engineering is to raise the level of abstraction by shifting the focus to models as a result complex software development activities move to the modelling level as well one such activity is model refactoring a technique for restructuring the models in order to improve some quality attributes of the models as a first contribution of this paper we argue and show that refactoring a model is enabled by inconsistency detection and resolution inconsistencies in or between models occur since models typically describe a software system from different viewpoints and on different levels of abstraction a second contribution of this paper is rule based inconsistency resolution which enables reuse of different inconsistency resolutions across model refactorings and manages the flow of inconsistency resolution steps automatically copyright 2006 acm description logics inconsistency management model refactoring rule based systems an approach to refactoring of executable uml models design erosion is one of the unavoidable effects of software evolution this destructive phenomenon occurs also in the context of executable uml models which are primary artefacts in agile mda software development methodology model refactorings are model transformations that can be applied with the aim of counteracting design erosion of uml models in this paper we present a systematic approach to specification of both executable uml model refactorings as well as associated bad smells in models the application of this method is illustrated on an exemplary refactoring and a related bad smell moreover we show how this transformation and detection of the bad smell can be implemented in telelogic tau a state of the art uml case tool copyright 2006 acm executable uml model refactoring refactoring tools and complementary techniques poorly designed software systems are difficult to understand and maintain modifying code in one place could lead to unwanted repercussions elsewhere due to high coupling adding new features can cause further quality degradation to the code if proper design and architectural concerns were not implemented development in a large enterprise system with such attributes will over time lead to a myriad of concerns unless the system is periodically overhauled or refactored in some way refactoring can aid the developer to improve the design of the code and to make it cleaner without changing its behaviour this study provides answers for some of the questions on refactoring a refactoring tool survey is given the ides surveyed include some of the most popular commercial and open source offerings from intellij s idea ibm s eclipse and sun s netbeans we also explain a way to automatically find targets for refactorings via automatic detection of code smells from static code analysis concerns on viewing compiler refactorings as a fully automated refactorings are raised we will perform a critical evaluation of refactoring by surveying these tools 2006 ieee search based determination of refactorings for improving the class structure of object oriented systems a software system s structure degrades over time a phenomenon that is known as software decay or design drift since the quality of the structure has major impact on the maintainability of a system the structure has to be reconditioned from time to time even if recent advances in the fields of automated detection of bad smells and refactorings have made life easier for software engineers this is still a very complex and resource consuming task search based approaches have turned out to be helpful in aiding a software engineer to improve the subsystem structure of a software system in this paper we show that such techniques are also applicable when reconditioning the class structure of a system we describe a novel search based approach that assists a software engineer who has to perform this task by suggesting a list of refactorings our approach uses an evolutionary algorithm and simulated refactorings that do not change the system s externally visible behavior the approach is evaluated using the open source case study jhotdraw copyright 2006 acm design heuristics evolutionary algorithms refactoring software metrics abstraction classes in software design we distinguish three abstraction strata in software design statements i strategic design statements architectural design determine global constraints such as programming paradigms architectural styles component based software enginering standards design principles and law governed regularities ii tactical design statements detailed design determine local constraints such as design patterns programming idioms and refactorings iii implementation statements determine specific properties of the implementation such as a class diagrams and program documentation seeking to ground this intuition in a well defined vocabulary we define two criteria of distinction in mathematical logic we present the intension locality hypothesis postulating that the spectrum of software design statements is divided into three well defined abstraction classes as follows i the class of non local statements n l contains strategic statements ii the class of local and intensional statements l i contains tactical statements and iii the class of local and extensional statements l e contains implementation statements we demonstrate a broad range of software design statements that corroborate our hypothesis we conclude with a proof of the architectural mismatch theorem according to which architectural mismatch arises from attempting to combine components that assume conflicting non local statements the institution of engineering and technology 2006 tool supported refactoring of existing object oriented code into aspects aspect oriented programming aop provides mechanisms for the separation of crosscutting concerns functionalities scattered through the system and tangled with the base code existing systems are a natural testbed for the aop approach since they often contain several crosscutting concerns which could not be modularized using traditional programming constructs this paper presents an automated approach to the problem of migrating systems developed according to the object oriented programming oop paradigm into aspect oriented programming aop a simple set of six refactorings has been defined to transform oop to aop and has been implemented in the aop migrator tool an eclipse plug in a set of enabling transformations from oop to oop complement the initial set of refactorings the paper presents the results of four case studies which use the approach to migrate selected crosscutting concerns from medium sized java programs in the range of 10k to 40k lines of code into equivalent programs in aspectj the case study results show the feasibility of the migration and indicate the importance of the enabling transformations as a preprocessing step 2006 ieee aspect oriented software development program transformation refactoring mptp 0 2 design implementation and initial experiments this paper describes the second version of the mizar problems for theorem proving mptp system and first experimental results obtained with it the goal of the mptp project is to make the large formal mizar mathematical library mml available to current first order automated theorem provers atps and vice versa and to boost the development of domain based knowledge based and generally ai based atp methods this version of mptp switches to a generic extended tptp syntax that adds term dependent sorts and abstract fraenkel terms to the tptp syntax we describe these extensions and explain how they are transformed by mptp to standard tptp syntax using relativization of sorts and deanonymization of abstract terms full mizar proofs are now exported and also encoded in the extended tptp syntax allowing a number of atp experiments this covers for example consistent handling of proof local constants and proof local lemmas and translating of a number of mizar proof constructs into the tptp formalism the proofs using second order mizar schemes are now handled by the system too by remembering and if necessary abstracting from the proof context the first order instances that were actually used these features necessitated changes in mizar in the mizar to tptp exporter and in the problem creating tools mizar has been reimplemented to produce and use natively a detailed xml format suitable for communication with other tools the mizar to tptp exporter is now just a xslt stylesheet translating the xml tree to the tptp syntax the problem creation and other mptp processing tasks are now implemented in about 1 300 lines of prolog all these changes have made mptp more generic more complete and more correct the largest remaining issue is the handling of the mizar arithmetical evaluations we describe several initial atp experiments both on the easy and on the hard mml problems sometimes assisted by machine learning it is shown that on the nonarithmetical problems countersatisfiability completions is no longer detected by the atp systems suggesting that the mizar deconstruction done by mptp is in this case already complete about every fifth nonarithmetical theorem is proved in a fully autonomous mode in which the premises are selected by a machine learning system trained on previous proofs in 329 of these cases the newly discovered proofs are shorter than the mml originals and therefore are likely to be used for mml refactoring this situation suggests that even a simple inductive or deductive system trained on formal mathematics can be sometimes smarter than mml authors and usable for general discovery in mathematics springer science business media inc 2007 atp mizar mml mpa mptp proof discovery re proving refactoring programs to secure information flows adding a sound information flow security policy to an existing program is a difficult task that requires major analysis of and changes to the program in this paper we show how refactoring programs into distinct components of high and low security is a useful methodology to aid in the production of programs with sound information flow policies our methodology proceeds as follows given a program with no information flow controls a program slicer is used to identify code that depends on high security inputs high security code so identified is then refactored into a separate component which may be accessed by the low security component via public method calls a security policy that labels input data and checks the output points can then enforce the desired end to end security property controlled information releases can occur at explicit declassification points if deemed safe the result is a well engineered program with explicit interfaces between components of different security levels copyright 2006 acm declassification information flow refactoring slicing approach to automated software design improvement object oriented software design improving technology is an effective means to increase system flexibility for adapting to future requirement variation and expansion in this paper a software design improving approach based on micro architecture anti pattern and case based reasoning is presented to improve software quality and maintainability in this approach problematic inflexible structures and corresponding refactoring alternatives at micro architecture level are formally defined and described as cases their organization and index mechanism in the case base are studied following the 4r procedures of cbr similarity measurement methods on class diagrams sequence diagrams oo quality metric factors and semantic constraints are discussed based on the measurement results some algorithms on identifying anti patterns instances in a given original design and replacing them by designs with high quality are presented furthermore a supporting system cbdit is developed to aid this approach anti pattern case based reasoning design pattern refactoring software evolution a stability oriented business component refactoring method using bayesian analysis reusable components should be continuously refactored during the full lifecycle to modify those designs unsuitable to reuse and to improve reuse performance in this paper we proposed a stability oriented business component refactoring method using bayesian analysis before introduction on this method a unified feature oriented component model and its reuse mechanism are briefly proposed with the classification of component reuse styles modification levels in this method clear separation of stability is considered as the goal of refactoring to decrease reuse cost practical reuse data is utilized as the information source of refactoring and bayesian analysis method is adopted to calculate posterior distribution and estimation of a set of stability parameters by analyzing variation tendency of each parameter component designers can take three basic refactoring operations and ten concrete refactoring rules to reconfigure granularity and instantiation degree of components to realize reuse cost optimization in order to evaluate performance improvement before and after refactoring five metrics are addressed a practical case is compendiously shown to validate the effectiveness of this method with some qualitative comparisons with other refactoring methods in literatures 2006 asian network for scientific information bayesian analysis method component refactoring reuse cost optimization stability statistical reuse data ecoop 2006 object oriented programming 20th european conference proceedings the proceedings contain 27 papers the topics discussed include design patterns 15 years later codequest scalable source code queries with datalog efficient object querying for java automatic perfetching by traversal profiling in object persistence architectures the runtime structure of object ownership on ownership and accessibility scoped types and aspects for real life java transparently reconciling transactions with locking for java synchronization object technology a grand narrative the continuing quest for abstraction early concurrent mobile objects modeling a simple post office turning the network into a database with active xml superglue component programming with object oriented signals variance and generalized constraints for c generics automated detection of refactorings in evolving components and managing the evolution of aspect oriented software with model based pointcuts adaptive star grammars we propose an extension of node and hyperedge replacement grammars called adaptive star grammars and study their basic properties a rule in an adaptive star grammar is actually a rule schema which via the so called cloning operation yields a potentially infinite number of concrete rules adaptive star grammars are motivated by application areas such as modeling and refactoring object oriented programs we prove that cloning can be applied lazily unrestricted adaptive star grammars are shown to be capable of generating every type 0 string language however we identify a reasonably large subclass for which the membership problem is decidable springer verlag berlin heidelberg 2006 applying and combining three different aspect mining techniques understanding a software system at source code level requires understanding the different concerns that it addresses which in turn requires a way to identify these concerns in the source code whereas some concerns are explicitly represented by program entities like classes methods and variables and thus are easy to identify crosscutting concerns are not captured by a single program entity but are scattered over many program entities and are tangled with the other concerns because of their crosscutting nature such crosscutting concerns are difficult to identify and reduce the understandability of the system as a whole in this paper we report on a combined experiment in which we try to identify crosscutting concerns in the jhotdraw framework automatically we first apply three independently developed aspect mining techniques to jhotdraw and evaluate and compare their results based on this analysis we present three interesting combinations of these three techniques and show how these combinations provide a more complete coverage of the detected concerns as compared to the original techniques individually our results are a first step towards improving the understandability of a system that contains crosscutting concerns and can be used as a basis for refactoring the identified crosscutting concerns into aspects springer science business media llc 2006 object oriented reengineering patterns and techniques surprising as it may seem many of the early adopters of the object oriented paradigm already face a number of problems typically encountered in large scale legacy systems software engineers are now confronted with millions of lines of industrial source code developed using object oriented design methods and languages of the late 80s and early 90s these systems exhibit a range of problems effectively preventing them from satisfying the evolving requirements imposed by their customers this tutorial will share our knowledge concerning the reengineering of object oriented legacy systems we will draw upon our experiences to show you techniques and tools we have applied on real industrial oo systems to detect and repair problems in particular we will discuss issues like reverse engineering design extraction metrics refactoring and program visualisation 2005 ieee a measurement framework for object oriented software testability testing is an expensive activity in the development process of any software system measuring and assessing the testability of software would help in planning testing activities and allocating required resources more importantly measuring software testability early in the development process during analysis or design stages can yield the highest payoff as design refactoring can be used to improve testability before the implementation starts this paper presents a generic and extensible measurement framework for object oriented software testability which is based on a theory expressed as a set of operational hypotheses we identify design attributes that have an impact on testability directly or indirectly by having an impact on testing activities and sub activities we also describe the cause effect relationships between these attributes and software testability based on thorough review of the literature and our own testing experience following the scientific method we express them as operational hypotheses to be further tested for each attribute we provide a set of possible measures whose applicability largely depends on the level of details of the design documents and the testing techniques to be applied the goal of this framework is twofold 1 to provide structured guidance for practitioners trying to measure design testability 2 to provide a theoretical framework for facilitating empirical research on testability 2005 elsevier b v all rights reserved diagnosing design problems in object oriented systems software decay is a phenomenon that plagues aging software systems while in recent years there has been significant progress in the area of automatic detection of code smells on one hand and code refactorings on the other hand we claim that existing restructuring practices are seriously hampered by their symptomatic and informal non repeatable nature this paper makes a clear distinction between structural problems and structural symptoms also known as code smells and presents a novel causal approach to restructuring object oriented systems our approach is based on two innovations the encapsulation of correlations of symptoms and additional contextual information into higher level design problems and the univocal explicit mapping of problems to unique refactoring solutions due to its explicit repeatable nature the approach shows high potential for increased levels of automation in the restructuring process and consequently a decrease in maintenance costs 2005 ieee an experiment on subjective evolvability evaluation of object oriented software explaining factors and interrater agreement recent trends in software development have emphasized the importance of refactoring in preserving software evolvability we performed two experiments on software evolvability evaluation i e evaluating the existence of certain code problems called code smells and the refactoring decision we studied the agreement of the evaluators interrater agreement was high for simple code smells and low for the refactoring decision furthermore we analyzed evaluators demographics and source code metrics as factors explaining the evaluations the code metrics explained over 70 of the variation regarding the simple code smell evaluations but only about 30 of the refactoring decision surprisingly the demographics were not useful predictors neither for evaluating code smells nor the refactoring decision the low agreement for the refactoring decisions may indicate difficulty in building tool support simulating real life subjective refactoring decisions however code metrics tools should be effective in highlighting straightforward problems e g simple code smells 2005 ieee refactoring support for class library migration as object oriented class libraries evolve classes are occasionally deprecated in favor of others with roughly the same functionality in java s standard libraries for example class hashtable has been superseded by hashmap and iterator is now preferred over enumeration migrating client applications to use the new idioms is often desirable but making the required changes to declarations and allocation sites can be quite labor intensive moreover migration becomes complicated and sometimes impossible if an application interacts with external components if a legacy class is not completely equivalent to its replacement or if multiple interdependent classes must be migrated simultaneously we present an approach in which mappings between legacy classes and their replacements are specified by the programmer then an analysis based on type constraints determines where declarations and allocation sites can be updated the method was implemented in eclipse and evaluated on a number of java applications on average our tool could migrate more than 90 of the references to legacy classes copyright 2005 acm design theory languages refactoring support for class library migration as object oriented class libraries evolve classes are occasionally deprecated in favor of others with roughly the same functionality in java s standard libraries for example class hashtable has been superseded by hashmap and iterator is now preferred over enumeration migrating client applications to use the new idioms is often desirable but making the required changes to declarations and allocation sites can be quite labor intensive moreover migration becomes complicated and sometimes impossible if an application interacts with external components if a legacy class is not completely equivalent to its replacement or if multiple interdependent classes must be migrated simultaneously we present an approach in which mappings between legacy classes and their replacements are specified by the programmer then an analysis based on type constraints determines where declarations and allocation sites can be updated the method was implemented in eclipse and evaluated on a number of java applications on average our tool could migrate more than 90 of the references to legacy classes copyright 2005 acm design theory languages a formal approach to designing a class subclass structure using a partial order on the functions we present a formal method for designing the class structure based on a partial order on the functions which is derived from the use relationship between the functions and the various data items we can regard this method as an initial step in building a theory of refactoring and design patterns our method can identify the functions which should be factored into subfunctions including their desired signatures and a reduced use complexity in order to simplify the class subclass structure a similar remark holds for the decomposition or consolidation of data items as well we illustrate our method with several examples 2005 ieee class hierarchy partial order refactoring towards a catalog of aspect oriented refactorings in this paper we present a collection of aspect oriented refactorings covering both the extraction of aspects from object oriented legacy code and the subsequent tidying up of the resulting aspects in some cases this tidying up entails the replacement of the original implementation with a different centralized design made possible by modularization the collection of refactorings includes the extraction of common code in various aspects into abstract superaspects we review the traditional object oriented code smells in the light of aspect orientation and propose some new smells for the detection of crosscutting concerns in addition we propose a new code smell that is specific to aspects 2005 acm aspect oriented programming code smells object oriented programming programming style refactoring towards an approach for aspect oriented software reengineering this paper presents a reengineering approach to help in migrating pure object oriented codes to a mixture of objects and aspects the approach focuses on aspect mining to identify potential crosscutting concerns to be modeled and implemented as aspects and on refactoring techniques to reorganize the code according to aspect oriented paradigm by using code transformations it is possible to recover the aspect oriented design using a transformational system with the recovered design it is possible to add or modify the system requirements in a case tool and to generate the codes in an executable language in this case aspectj aop aspect mining mvcase refactoring software reengineering software transformation identifying traits with formal concept analysis traits are basically mixins or interfaces but with method bodies in languages that support traits classes are composed out of traits there are two main advantages with traits firstly decomposing existing classes into traits from which they can be recomposed improves the factoring of hierarchies secondly it increases the library reuse potential by providing more reusable traits identifying traits and decomposing class hierarchies into traits is therefore an important and challenging task to facilitate maintainability and evolution in this paper we present how we use formal concept analysis to identify traits in inheritance hierarchies our approach is two staged first we identify within a hierarchy maximal groups of methods that have a set of classes in common second we cluster cohesive groups of methods based on method invocations as potential traits we applied our approach on two significant hierarchies and compare our results with the manual refactorization of the same code which was done by the authors of traits copyright 2005 acm formal concept analysis logical views mixins traits icse 2005 proceedings of the 3rd workshop on software quality 3 wosq 2005 the proceedings contain 13 papers the topics discussed include value based quality processes and results using idave to determine availability requirements software quality economics for defect detection techniques using failure prediction qfd application in software process management and improvement based on cmm improving quality through software process improvement in thailand initial analysis software quality development and assurance in rup msf and xp a comparative study quality cleanroom and formal methods dealing with imprecise quality factors in software design early estimation of software quality using in process testing metrics a controlled case study aries refactoring support tool for code clone a real time measure of software system families an empirical assessment of using stereotypes to improve reading techniques in software inspections and trade off analysis in web development an experiment on the use of qfd extending dynamic aspect mining with static information aspect mining tries to identify crosscutting concerns in legacy systems and thus supports the refactoring into an aspect oriented design we briefly introduce dynamit a dynamic aspect mining tool that detects crosscutting concerns based on tracing method executions while the approach is generally fairly precise further analysis revealed that some false positives were systematically caused by dynamic binding furthermore some aspect candidates were blurred or not detected due to not sufficient tracing mechanisms of method executions when using aspectj s execution pointcuts for the trace generation we enhanced the mining capabilities of dynamit by taking additional static type information into account and generating the traces using call pointcuts instead in an initial case study with anchovis a 1300 loc java program the number of mined aspect candidates increased by a factor of three while the number of false positives remained zero 2005 ieee archeology of code duplication recovering duplication chains from small duplication fragments code duplication is a common problem and a well known sign of bad design as a result of that in the last decade the issue of detecting code duplication led to various solutions and tools that can automatically find duplicated blocks of code however duplicated fragments rarely remain identical after they are copied they are oftentimes modified here and there this adaptation usually scatters the duplicated code block into a large amount of small islands of duplication which detected and analyzed separately hide the real magnitude and impact of the duplicated block in this paper we propose a novel automated approach for recovering duplication blocks by composing small isolated fragments of duplication into larger and more relevant duplication chains we validate both the efficiency and the scalability of the approach by applying it on several well known open source case studies and discussing some relevant findings by recovering such duplication chains the maintenance engineer is provided with additional cases of duplication that can lead to relevant refactorings and which are usually missed by other detection methods 2005 ieee code duplication design flaws quality assurance detecting and visualizing refactorings from software archives we perform knowledge discovery in software archives in order to detect refactorings on the level of classes and methods our refvis prototype finds these refactorings in cvs repositories and relates them to transactions and configurations additionally refvis relates movements of methods to the class inheritance hierarchy of the analyzed project furthermore we present our visualization technique that illustrates these refactorings refvis provides both a class hierarchy layout and a package layout and uses color coding to distinguish different kinds of refactorings details on each can be displayed on demand using mouse over tooltips finally we demonstrate by case studies on two open source projects how refvis facilitates understanding of refactorings applied to a software project 2005 ieee reverse engineering goal models from legacy code a reverse engineering process aims at reconstructing high level abstractions from source code this paper presents a novel reverse engineering methodology for recovering stakeholder goal models from both structured and unstructured legacy code the methodology consists of the following major steps 1 refactoring source code by extracting methods based on comments 2 converting the refactored code into an abstract structured program through statechart refactoring and hammock graph construction 3 extracting a goal model from the structured program s abstract syntax tree 4 identifying nonfunctional requirements and derive softgoals based on the traceability between the code and the goal model to illustrate this requirements recovery process we refactor stake holder goal models from two legacy software code bases an unstructured web based email in php squirrelmail and a structured email client system in java columba 2005 ieee multi criteria detection of bad smells in code with uta method bad smells are indicators of inappropriate code design and implementation they suggest a need for refactoring i e restructuring the program towards better readability understandability and eligibility for changes smells are defined only in terms of general subjective criteria which makes them difficult for automatic identification existing approaches to smell detection base mainly on human intuition usually supported by code metrics unfortunately these models do not comprise the full spectrum of possible smell symptoms and still are uncertain in the paper we propose a multi criteria approach for detecting smells adopted from uta method it learns from programmer s preferences and then combines the signals coming from different sensors in the code and computes their utility functions the final result reflects the intensity of an examined smell which allows the programmer to make a ranking of most onerous odors springer verlag berlin heidelberg 2005 refactoring the aspectizable interfaces an empirical assessment aspect oriented programming aims addressing the problem of the crosscutting concerns i e those functionalities that are scattered among several modules in a given system aspects can be defined to modularize such concerns in this work we focus on a specific kind of crosscutting concerns the scattered implementation of methods declared by interfaces that do not belong to the principal decomposition we call such interfaces aspectizable all the aspectizable interfaces identified within a large number of classes from the java standard library and from three java applications have been automatically migrated to aspects to assess the effects of the migration on the internal and external quality attributes of these systems we collected a set of metrics and we conducted an empirical study in which some maintenance tasks were executed on the two alternative versions with and without aspects of the same system in this paper we report the results of such a comparison 2005 ieee aspect oriented programming empirical studies program transformations refactoring predicting the probability of change in object oriented systems of all merits of the object oriented paradigm flexibility is probably the most important in a world of constantly changing requirements and the most striking difference compared to previous approaches however it is rather difficult to quantify this aspect of quality this paper describes a probabilistic approach to estimate the change proneness of an object oriented design by evaluating the probability that each class of the system will be affected when new functionality is added or when existing functionality is modified it is obvious that when a system exhibits a large sensitivity to changes the corresponding design quality is questionable the extracted probabilities of change can be used to assist maintenance and to observe the evolution of stability through successive generations and identify a possible saturation level beyond which any attempt to improve the design without major refactoring is impossible the proposed model has been evaluated on two multiversion open source projects the process has been fully automated by a java program while statistical analysis has proved improved correlation between the extracted probabilities and actual changes in each of the classes in comparison to a prediction model that relies simply on past data 2005 ieee object oriented design methods object oriented programming product metrics quality analysis and evaluation refactoring gcc using structure field access traces amp concept analysis 2005 acm isbn refactoring usually involves statically analyzing source code to understand which transformations safely preserve execution behavior of the program however static analysis may not scale well for large programs when analysis results are too general when tools for analyzing the source code are unwieldy or when the tools simply do not exist in such cases it can be simpler to analyze the program at runtime to gather answers needed for safe code changes i show how dynamic data can guide refactoring of a single data structure into a hierarchy of classes specifically i show how i refactored the gcc compiler to cut its use of heap memory in order to partition the declaration data structure into more efficiently sized parts i used data structure field access traces to automatically identify how the data structure might be refactored i also identified other potential refactorings of the data structure using concept analysis these results then guided byhand modifications to the compiler i finally evaluated what size test cases would be needed to gather adequate information to correctly perform the refactoring the case study showed the refactoring could be performed with the dynamic information but without traces from an exhaustive set of test cases some fields would be moved incorrectly case study gcc meaning preserving restructuring a technique for automatic component extraction from object oriented programs by refactoring component based software development cbd is based on building software systems from previously existing software components in cbd reuse of common parts in component form can reduce the development cost of new systems and reduce the maintenance cost associated with the support of these systems however existing programs have usually been built using another paradigm such as the object oriented oo paradigm oo programs cannot be reused rapidly or effectively in the cbd paradigm even if they contain reusable functions in this paper we propose a technique for extracting components from existing oo programs by our new refactoring extract component our technique of refactoring can identify and extract reusable components composed of classes from oo programs and modify the surrounding parts of extracted components in original programs we have developed a system that performs our refactoring automatically and extracts javabeans components from java programs as a result of evaluation experiments it is found that our system is useful for extracting reusable components along with usage examples from java programs 2004 elsevier b v all rights reserved component based development cbd javabeans object oriented programming refactoring software component software reuse physical properties of the dust in the solar system and its interrelation with small bodies dust particles in the solar system are produced from the small bodies asteroids comets meteoroids and kuiper belt objects a further source of dust is provided by the warm interstellar medium that the sun is currently embedded in and that streams into the solar system we review the physical properties of solar system dust and trace back its interrelation with the small solar system bodies comets contain relatively pristine material that they transport to the inner solar system the alteration of dust in the vicinity of comets is complex and connected to the gas evolution but a significant part of the organic dust material survives these alterations the optical properties of cometary dust are best described with a mixture of silicate and carbon bearing materials as far as the darkness of the cometary material is concerned according to recent models this is not a result of the porosity but rather of the darkness of the carbon bearing component this does not contradict the observation of silicate features in the thermal emission brightness of cometary dust since porous mixtures of silicate and carbon bearing dust can produce the observed polarization and albedo characteristics as well as the silicate features the carbon bearing component is most likely an organic refactory component the relative contributions of different sources change within the solar system dust cloud and depend as well on the measurement technique considered in particular the dust from asteroids which provides a large component of the dust near earth orbit is also preferably seen with most of the detection methods the majority of dust inward from 1 au is produced from cometary dust and meteoroids dust material evaporation induced by collisions inward from 1 au produces a minor heavy ion component in the solar wind plasma known as inner source pick up ions 2006 international astronomical union comets general interplanetary medium meteors meteoroids