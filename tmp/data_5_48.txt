prioritizing the refactoring need for critical component using combined approach 2018 growing science ltd all rights reserved one of the most promising strategies that will smooth out the maintainability issues of the software is refactoring due to lack of proper design approach the code often inherits some bad smells which may lead to improper functioning of the code especially when it is subject to change and requires some maintenance a lot of studies have been performed to optimize the refactoring strategy which is also a very expensive process in this paper a component based system is considered and a fuzzy multi criteria decision making fmcdm model is proposed by combining subjective and objective weights to rank the components as per their urgency of refactoring jdeodorant tool is used to detect the code smells from the individual components of a software system the objective method uses the entropy approach to rank the component having the code smell the subjective method uses the fuzzy topsis approach based on decision makers judgement to identify the critically and dependency of these code smells on the overall software the suggested approach is implemented on component based software having 15 components the constitute components are ranked based on refactoring requirements code smell entropy fmcdm analysis fuzzy topsis refactoring jmove a novel heuristic and tool to detect move method refactoring opportunities 2017 elsevier inc this paper presents a recommendation approach that suggests move method refactorings using the static dependencies established by methods this approach implemented in a publicly available tool called jmove compares the similarity of the dependencies established by a method with the dependencies established by the methods in possible target classes we first evaluate jmove using 195 move method refactoring opportunities synthesized in 10 open source systems in this evaluation jmove precision ranges from 21 small methods to 32 large methods and its median recall ranges from 21 small methods to 60 large methods in the same scenario jdeodorant which is a state of the art move method recommender has a maximal precision of 15 large methods and a maximal median recall of 40 small methods therefore we claim that jmove is specially useful to provide recommendations for large methods we reinforce this claim by means of two other studies first by investigating the overlapping of the recommendations provided by jmove and three other recommenders jdeodorant incode and methodbook second by validating jmove and jdeodorant recommendations with experts in two industrial strength systems dependency sets jdeodorant jmove methodbook move method refactorings recommendation systems an empirical study to improve software security through the application of code refactoring 2017 elsevier b v context code bad smells indicate design flaws that can degrade the quality of software and can potentially lead to the introduction of faults they can be eradicated by applying refactoring techniques code bad smells that impact the security perspective of software should be detected and removed from their code base however the existing literature is insufficient to support this claim and there are few studies that empirically investigate bad smells and refactoring opportunities from a security perspective objective in this paper we investigate how refactoring can improve the security of an application by removing code bad smell method we analyzed three different code bad smells in five software systems first the identified code bad smells are filtered against security attributes next the object oriented design and security metrics are calculated for the five investigated systems later refactoring is applied to remove security related code bad smells the correctness of detection and refactoring of investigated code smells are then validated finally both traditional object oriented and security metrics are again calculated after removing bad smells to assess its impact on the design and security attributes of systems results we found ‘feature envy to be the most abundant security bad smell in investigated projects the ‘move method and ‘move field are commonly applied refactoring techniques because of the abundance of feature envy conclusion the results of security metrics indicate that refactoring helps improve the security of an application without compromising the overall quality of software systems code bad smells empirical study refactoring secured software technical debt and agile software development practices and processes an industry practitioner survey 2017 the authors context contemporary software development is typically conducted in dynamic resource scarce environments that are prone to the accumulation of technical debt while this general phenomenon is acknowledged what remains unknown is how technical debt specifically manifests in and affects software processes and how the software development techniques employed accommodate or mitigate the presence of this debt objectives we sought to draw on practitioner insights and experiences in order to classify the effects of agile method use on technical debt management given the popularity and perceived success of agile methods we explore the breadth of practitioners knowledge about technical debt how technical debt is manifested across the software process and the perceived effects of common agile software development practices and processes on technical debt in doing so we address a research gap in technical debt knowledge and provide novel and actionable managerial recommendations method we designed tested and executed a multi national survey questionnaire to address our objectives receiving 184 responses from practitioners in brazil finland and new zealand results our findings indicate that 1 practitioners are aware of technical debt although there was under utilization of the concept 2 technical debt commonly resides in legacy systems however concrete instances of technical debt are hard to conceptualize which makes it problematic to manage 3 queried agile practices and processes help to reduce technical debt in particular techniques that verify and maintain the structure and clarity of implemented artifacts e g coding standards and refactoring positively affect technical debt management conclusions the fact that technical debt instances tend to have characteristics in common means that a systematic approach to its management is feasible however notwithstanding the positive effects of some agile practices on technical debt management competing stakeholders interests remain a concern agile software development practitioner survey technical debt technical debt management a methodology to infer and refactor an object oriented model from c applications copyright 2017 john wiley sons ltd when analyzing legacy code generating a high level model of an application during the reverse engineering process helps the developers understand how the application is structured and how the dependencies relate the different software entities within the context of procedural programming languages such as c the existing approaches to get a model of the code require documentation and or implicit knowledge that stakeholders acquire during the software building these approaches use the code itself to build a syntactic model where we see the different software artifacts such as variables functions and modules however there is no supporting methodology to detect and analyze if there are relationships dependencies between those artifacts such as which variable in a module is declared using an abstract data type described in another one or which are the functions that are using parameters typed with an abstract data type or any design decision taken by original developers such as how the developer has implemented functions in different modules on the other hand current developers use object oriented oo paradigm to implement not only business applications but also useful methodologies tools that allow semiautomatic analysis of any application we must remark the legacy procedural code still has worth and is working in several industries and as any evolving code the developers have to be able to perform maintenance tasks minimizing the limitations offered by the language based on useful properties that the oo paradigm and their supporting analysis tools provide such as uml models we propose m2k as a methodology to generate a high level model from legacy procedural code mainly written in ansi c to understand how c based applications were implemented is not a new problem in software reengineering however our contribution is based on building an oo model and suggesting different refactorings that help the developer to improve it and to eventually guide a new implementation of the target application specifically the methodology builds cohesive software entities mapped from procedural code and makes the coupling between c entities explicit in the high level model the result of our methodology is a set of refactored class candidates a structure that groups a set of variables and a set of functions obtained from the c applications based on the class candidate model we propose refactorings based on oo design principles to improve the design of the application the most relevant design improvements were obtained with algorithm abstraction by applying the strategy pattern attributes methods relocalization variables types generalization and removing renaming methods attributes besides a methodology and the supporting tool we provide 14 case studies based on real projects implemented in c and we showed how the results validate our proposal design recovery legacy software object oriented paradigm procedural language reengineering refactoring reverse engineering automatic software refactoring via weighted clustering in method level networks 2017 ieee in this study we describe a system level multiple refactoring algorithm which can identify the move method move field and extract class refactoring opportunities automatically according to the principle of high cohesion and low coupling the algorithm works by merging and splitting related classes to obtain the optimal functionality distribution from the system level furthermore we present a weighted clustering algorithm for regrouping the entities in a system based on merged method level networks using a series of preprocessing steps and preconditions the bad smells introduced by cohesion and coupling problems can be removed from both the non inheritance and inheritance hierarchies without changing the code behaviors we rank the refactoring suggestions based on the anticipated benefits that they bring to the system based on comparisons with related research and assessing the refactoring results using quality metrics and empirical evaluation we show that the proposed approach performs well in different systems and is beneficial from the perspective of the original developers finally an open source tool is implemented to support the proposed approach clustering analysis cohesion complex network coupling software refactoring empirical evaluation of software maintainability based on a manually validated refactoring dataset 2017 elsevier b v context refactoring is a technique for improving the internal structure of software systems it has a solid theoretical background while being used in development practice also however we lack empirical research results on the real effect of code refactoring and its application objective this paper presents a manually validated subset of a previously published dataset containing the refactorings extracted by the reffinder tool code metrics and maintainability of 7 open source systems we found that reffinder had around 27 overall average precision on the subject systems thus our manually validated subset has substantial added value using the dataset we studied several aspects of the refactored and non refactored source code elements classes and methods like the differences in their maintainability and source code metrics method we divided the source code elements into a group containing the refactored elements and a group with non refactored elements we analyzed the elements characteristics in these groups using correlation analysis mann–whitney u test and effect size measures results source code elements subjected to refactorings had significantly lower maintainability than elements not affected by refactorings moreover refactored elements had significantly higher size related metrics complexity and coupling also these metrics changed more significantly in the refactored elements the results are mostly in line with our previous findings on the not validated dataset with the difference that clone metrics had no strong connection with refactoring conclusions compared to the preliminary analysis using a not validated dataset the manually validated dataset led to more significant results which suggests that developers find targets for refactorings based on some internal quality properties of the source code like their size complexity or coupling but not clone related metrics as reported in our previous studies they do not just use these properties for identifying targets but also control them with refactorings code refactoring empirical study manually validated empirical dataset software maintainability source code metrics cloud restriction solver a refactoring based approach to migrate applications to the cloud 2017 elsevier b v context the migration of legacy systems to the platform as a service paas model provides several benefits but also brings new challenges such as dealing with the restrictions imposed by the service provider furthermore factors such as time training and the extensive reengineering activities make the migration process time consuming and error prone although there exist several techniques for partial or total migration of legacy applications to the cloud only a few specifically address the resolution of these constraints objective this paper proposes a novel semi automatic approach called cloud restriction solver crs for migrating applications to a paas environment that avoids the cloud restrictions through user defined refactorings methods the approach is supported by two open and extensible tools the first one called crsanalyzer identifies the pieces of code that violate the restrictions of the chosen paas platform while the second one crsrefactor changes those pieces by equivalent cloud enabled services results the applicability of the proposed approach is presented by showing its instantiation for google app engine as an eclipse plugin and by migrating three java applications to that paas successfully in addition an instantiation for ibm bluemix has been created and used to compare the migration of the same application using the developed tools for both cloud providers conclusion the proposed approach fosters software reuse is cloud independent and facilitates the migration of applications to paas platforms cloud migration refactoring software evolution exploiting load testing and profiling for performance antipattern detection 2017 elsevier b v context the performance assessment of complex software systems is not a trivial task since it depends on the design code and execution environment all these factors may affect the system quality and generate negative consequences such as delays and system failures the identification of bad practices leading to performance flaws is of key relevance to avoid expensive rework in redesign reimplementation and redeployment objective the goal of this manuscript is to provide a systematic process based on load testing and profiling data to identify performance issues with runtime data these performance issues represent an important source of knowledge as they are used to trigger the software refactoring process software characteristics and performance measurements are matched with well known performance antipatterns to document common performance issues and their solutions method we execute load testing based on the characteristics of collected operational profile thus to produce representative workloads performance data from the system under test is collected using a profiler tool to create profiler snapshots and get performance hotspot reports from such data performance issues are identified and matched with the specification of antipatterns software refactorings are then applied to solve these performance antipatterns results the approach has been applied to a real world industrial case study and to a representative laboratory study experimental results demonstrate the effectiveness of our tool supported approach that is able to automatically detect two performance antipatterns by exploiting the knowledge of domain experts in addition the software refactoring process achieves a significant performance gain at the operational stage in both case studies conclusion performance antipatterns can be used to effectively support the identification of performance issues from load testing and profiling data the detection process triggers an antipattern based software refactoring that in our two case studies results in a substantial performance improvement empirical data load testing and profiling software performance antipatterns software performance engineering performance driven software model refactoring 2017 elsevier b v context software refactoring is a common practice aimed at addressing requirements or fixing bugs during the software development while refactoring related to functional requirements has been widely studied in the last few years non functional driven refactoring is still critical mostly because non functional characteristics of software are hard to assess and appropriate refactoring actions can be difficult to identify in the context of performance which is the focus of this paper antipatterns represent effective instruments to tackle this issue because they document common mistakes leading to performance problems as well as their solutions objective in order to effectively reuse the knowledge beyond performance antipatterns automation is required to detect and remove them in this paper we introduce a framework that enables in an unique tool context the refactoring of software models driven by performance antipattern detection and removal method we have implemented within the epsilon platform detection rules and refactoring actions on uml models for a set of well known performance antipatterns by exploiting the epsilon languages to check properties and apply refactoring on models we enable three types of refactoring sessions results we experiment our framework on a botanical garden management system to show on one side that antipatterns can effectively drive software refactoring towards models that satisfy performance requirements and on the other side that the automation introduced by epsilon based sessions enables to inspect multiple paths and to propose a variety of solutions conclusion this work demonstrates that automation in performance driven software model refactoring can be beneficial and that performance antipatterns can be powerful instruments in the hands of software engineers for detecting and solving performance problems usually hidden to traditional bottleneck analysis this work also opens the road to the integration of well known techniques for software refactoring driven by functional requirements with novel techniques addressing non functional requirements like performance model driven engineering performance antipatterns performance engineering software refactoring uml a metamodeling approach for the identification of organizational smells in multi agent systems application to aspecs 2016 springer science business media dordrecht software quality is one of the most important subjects in the process development software especially in large and complex systems much effort has been devoted to the development of techniques and concepts to improve software quality over the years we are especially interested on smells which represent anomalies or flaws in the design code that can have serious consequences in maintenance or future development of the systems these techniques have a strong development in the object oriented paradigm however very few studies were conducted in the agent oriented paradigm in this paper we focus on the detection of design smells applied to multi agent systems models based on the organizational approach named organizational design smells ods early and automatic detection of these ods allows reducing the costs and development times while increasing the final product s quality to achieve this objective validation rules were defined based in the evl language the approach is illustrated with two examples their validation rules and the refactoring solutions proposed agent oriented software engineering design smells organization approach validation rules empirical evaluation of the impact of object oriented code refactoring on quality attributes a systematic literature review 1976 2012 ieee software refactoring is a maintenance task that addresses code restructuring to improve its quality many studies have addressed the impact of different refactoring scenarios on software quality this study presents a systematic literature review that aggregates summarizes and discusses the results of 76 relevant primary studies pss concerning the impact of refactoring on several internal and external quality attributes the included pss were selected using inclusion and exclusion criteria applied to relevant articles published before the end of 2015 we analyzed the pss based on a set of classification criteria including software quality attributes and measures refactoring scenarios evaluation approaches datasets and impact results we followed the vote counting approach to determine the level of consistency among the ps reported results concerning the relationship between refactoring and software quality the results indicated that different refactoring scenarios sometimes have opposite impacts on different quality attributes therefore it is false that refactoring always improves all software quality aspects the vote counting study provided a clear view of the impacts of some individual refactoring scenarios on some internal quality attributes such as cohesion coupling complexity inheritance and size but failed to identify their impacts on external and other internal quality attributes due to insufficient findings quality attribute quality measure refactoring scenario systematic literature review metamodel for requirements traceability and impact analysis on agile methods springer international publishing ag 2018 requirements traceability is a requirements management activity used to identify relations between requirements and to enable the comprehension of its dependencies in the agile development changes are normal and occur at any moment in the project requirements are written in the format of user stories which have dependencies between them these dependencies can be technical or related to the business being developed handling dependencies among requirements and impact analysis is a challenge due to the possibility of refactoring and maintenance caused by not analyzed changes this paper aims to propose a metamodel that enables requirements traceability and impact analysis in agile methods the proposed metamodel presents the following contributions enable traceability analysis through the mapping of dependencies between user stories b allow identification of dependencies between user stories and between tasks c management of the evolution of requirements d support on impact analysis of changes agile methods metamodel requirements traceability user stories exploring multilateral cloud computing security architectural design debt in terms of technical debt springer nature singapore pte ltd 2018 this work identifies various design debt causes in a cloud computing system from various dimensions of design debt even though immature un ripen coded service accessible over the internet using the cloud computing paradigm may work fine and be wholly tolerable to the patron but excess quantities will make a service progression that may lead to extreme specialist of software developers and finally an inflexible product delivery of the earliest primary beginning coded service without ripeness or maturity is like going into debts or arrears or due to obligation a petite tiny debt rates progress so protracted as it is paid or rewarded back punctually with a rewrite redraft revising reworking the risk arises when the debt is not repaid and settled every miniature infinitesimal effort spent on imprecise code reckons as interest on that arrears debt intact engineering business can be brought to be idle under the balance load of an unconsolidated non solicit implementation execution and performance discharging object oriented functional or procedural or otherwise this work uses refactoring as a solution for the identified debt in the multilateral cloud security architecture to secure the cloud services cloud computing security design debt design refactoring design smells multilateral cloud security architecture technical debt a large scale empirical study on the lifecycle of code smell co occurrences 2018 elsevier b v context code smells are suboptimal design or implementation choices made by programmers during the development of a software system that possibly lead to low code maintainability and higher maintenance costs objective previous research mainly studied the characteristics of code smell instances affecting a source code file while only few studies analyzed the magnitude and effects of smell co occurrence i e the co occurrence of different types of smells on the same code component this paper aims at studying in details this phenomenon method we analyzed 13 code smell types detected in 395 releases of 30 software systems to firstly assess the extent to which code smells co occur and then we analyze i which code smells co occur together and ii how and why they are introduced and removed by developers results 59 of smelly classes are affected by more than one smell and in particular there are six pairs of smell types e g message chains and spaghetti code that frequently co occur furthermore we observed that method level code smells may be the root cause for the introduction of class level smells finally code smell co occurrences are generally removed together as a consequence of other maintenance activities causing the deletion of the affected code components with a consequent removal of the code smell instances as well as the result of a major restructuring or scheduled refactoring actions conclusions based on our findings we argue that more research aimed at designing co occurrence aware code smell detectors and refactoring approaches is needed code smells co occurrences empirical study mining software repositories fossil a resilient and efficient system for identifying foss functions in malware binaries 2018 copyright is held by the owner author s identifying free open source software foss packages on binaries when the source code is unavailable is important for many security applications such as malware detection software infringement and digital forensics this capability enhances both the accuracy and the efficiency of reverse engineering tasks by avoiding false correlations between irrelevant code bases although the foss package identification problem belongs to the field of software engineering conventional approaches rely strongly on practical methods in data mining and database searching however various challenges in the use of these methods prevent existing function identification approaches from being effective in the absence of source code to make matters worse the introduction of obfuscation techniques the use of different compilers and compilation settings and software refactoring techniques has made the automated detection of foss packages increasingly difficult with very few exceptions the existing systems are not resilient to such techniques and the exceptions are not sufficiently efficient to address this issue we propose fossil a novel resilient and efficient system that incorporates three components the first component extracts the syntactical features of functions by considering opcode frequencies and applying a hidden markov model statistical test the second component applies a neighborhood hash graph kernel to random walks derived from control flow graphs with the goal of extracting the semantics of the functions the third component applies z score to the normalized instructions to extract the behavior of instructions in a function the components are integrated using a bayesian network model which synthesizes the results to determine the foss function the novel approach of combining these components using the bayesian network has produced stronger resilience to code obfuscation we evaluate our system on three datasets including real world projects whose use of foss packages is known malware binaries for which there are security and reverse engineering reports purporting to describe their use of foss and a large repository of malware binaries we demonstrate that our system is able to identify foss packages in real world projects with a mean precision of 0 95 and with a mean recall of 0 85 furthermore fossil is able to discover foss packages in malware binaries that match those listed in security and reverse engineering reports our results show that modern malware binaries contain 0 10–0 45 of foss packages binary code analysis free software packages function fingerprinting malicious code analysis code refactoring using slice based cohesion metrics and aspect oriented programming copyright 2018 inderscience enterprises ltd software restructuring is essential for maintaining software quality it is a usual practice that we first design the software and then go for coding after coding if there is any change in the requirement or if the output is incorrect then we have to modify the code again for each small code modification it is not feasible to alter the design these minor changes made to the code causes decay in the software design software refactoring is used to restructure the code to improve the design and quality of the software in this paper we propose an approach for performing code refactoring we use slice based cohesion metrics to identify the target methods that require refactoring after identifying the target methods we use program slicing to divide the target method into two parts finally we use the concept of aspects to alter the code structure in a manner that does not change the external behaviour of the original module aop aspectj code restructure cohesion metrics program slicing software refactoring on the achievement of high fidelity and scalability for large scale diagonalizations in grid based dft simulations 2018 wiley periodicals inc recent advance in high performance computing hpc resources has opened the possibility to expand the scope of density functional theory dft simulations toward large and complex molecular systems this work proposes a numerically robust method that enables scalable diagonalizations of large dft hamiltonian matrices particularly with thousands of computing cpus cores that are usual these days in terms of sizes of hpc resources the well known lanczos method is extensively refactorized to overcome its weakness for evaluation of multiple degenerate eigenpairs that is the substance of dft simulations where a multilevel parallelization is adopted for scalable simulations in as many cores as possible with solid benchmark tests for realistic molecular systems the fidelity of our method are validated against the locally optimal block preconditioned conjugated gradient lobpcg method that is widely used to simulate electronic structures our method may waste computing resources for simulations of molecules whose degeneracy cannot be reasonably estimated but compared to lobpcg method it is fairly excellent in perspectives of both speed and scalability and particularly has remarkably less 10 sensitivity of performance to the random nature of initial basis vectors as a promising candidate for solving electronic structures of highly degenerate systems the proposed method can make a meaningful contribution to migrating dft simulations toward extremely large computing environments that normally have more than several tens of thousands of computing cores degenerate eigenpairs density functional theory high performance computing lanczos iterations large scale electronic structures are you smelling it investigating how similar developers detect code smells 2017 elsevier b v context a code smell indicates a poor implementation choice that often worsens software quality thus code smell detection is an elementary technique to identify refactoring opportunities in software systems unfortunately there is limited knowledge on how similar two or more developers detect smells in code in particular few studies have investigated if developers agree or disagree when recognizing a smell and which factors can influence on such dis agreement objective we per form a broader study to investigate how similar the developers detect code smells we also analyze whether certain factors related to the developers profiles concerning background and experience may influence such dis agreement moreover we analyze if the heuristics adopted by developers on detecting code smells may influence on their dis agreement method we conducted an empirical study with 75 developers who evaluated instances of 15 different code smell types for each smell type we analyzed the agreement among the developers and we assessed the influence of 6 different factors on the developers evaluations altogether more than 2700 evaluations were collected resulting in substantial quantitative and qualitative analyses results the results indicate that the developers presented a low agreement on detecting all 15 smell types analyzed in our study the results also suggest that factors related to background and experience did not have a consistent influence on the agreement among the developers on the other hand the results show that the agreement was consistently influenced by specific heuristics employed by developers conclusions our findings reveal that the developers detect code smells in significantly different ways as a consequence these findings introduce some questions concerning the results of previous studies that did not consider the different perceptions of developers on detecting code smells moreover our findings shed light towards improving state of the art techniques for accurate customized detection of code smells code smell detection empirical study software maintenance a semi automated framework for the identification and estimation of architectural technical debt a comparative case study on the modularization of a software component 2017 elsevier b v context research and industry s attention has been focusing on developing systems that enable fast time to market in the short term but would assure a sustainable delivery of business value and maintenance operations in the long run a related phenomenon has been identified in architectural technical debt if the system architecture is sub optimal for long term business goals it might need to be refactored a key property of the system assuring long term goals is its modularity or else the degree to which components are decoupled such property allows the product to be evolved without costly changes pervading the whole system however understanding the business benefits of refactoring to achieve modularity is not trivial especially for large refactorings involving substantial architectural changes objective the aim of this study was to develop a technique to identify architectural technical debt in the form of a non modularized component and to quantify the convenience of its repayment method we have conducted a single embedded case study in a large company comparing a component before and after it was refactored to achieve modularity we have developed a holistic framework for the semi automated identification and estimation of architectural technical debt in the form of non modularized components we then evaluate the technique reporting a comparative study of the difference in maintenance and development costs in two coexisting systems one including the refactored component and one including the non refactored one results the main contributions are a measurement system for the identification of the architectural technical debt according to the stakeholders goals a mathematical relationship for calculating and quantifying its interest in terms of extra effort spent in additional development and maintenance and an overall decision framework to assess the benefit of refactoring we also report context specific results that show the estimated benefits of refactoring the specific case of architectural technical debt conclusion we found that it is possible to identify this kind of architectural technical debt and to quantify its repayment convenience thanks to the developed framework it was possible to estimate that the architectural technical debt present in the component was causing substantial continuous extra effort and that the modularization would be repaid in several months of development and maintenance estimation measurement system modularization refactoring software architecture software management technical debt for some places more than others agility and organizational culture springer international publishing ag 2018 the adoption of agile methods for software development has proven to be an activity sensitive to the culture of the organizations seeking to adopt them agile projects occur in different situations from the most ideal to those that require extensive adaptations this study aims to explore the relationship between selected basic cultural assumptions of organizations and agile practices correlations identified were explored looking to offer an initial map suggesting approaches to introduce agile practices based on the cultural profile of the organization the most notable results were that basic cultural assumptions of pragmatism favors communication and collegial participative are the ones most correlated with agile practices and the practices of co location test driven development continuous integration code refactoring pair programming and stand up meeting showed no representative correlations with basic cultural assumptions indicating that they may be a good alternative to start an agile adoption by technical practices one of the main contributions of this work is proposing a preliminary model that highlights the relationship between organizational culture and adoption of agile practices suggesting areas for further research adoption of agile practices agile methodologies agile practices basic assumptions co location continuous integration cultural dimensions organizational culture stand up meeting tdd high precision synchronous phasor measurement based on compressed sensing 2018 editorial board of jilin university all right reserved gps timing synchronization phasor measurement provides important basis for online analysis of wide area power signal currently discrete fourier transform method is widely used in synchronization phasor measurement to eliminate or weaken the measurement error caused by the imprecise synchronous sampling a high precision synchronous phasor measurement algorithm is proposed it is based on compressed sensing cs theory which modifies discrete fourier transform to estimate the results the reconstruction algorithm uses the discrete fourier transform to rarefy the measuring signal and takes the dirichlet matrix as the observation matrix it also refacors measurement signal with cs refactor algorithm the simulation results show that compared with the traditional discrete fourier transform method without extending the measurement time the proposed algorithm can effectively eliminate or weaken the spectrum leakage error and greatly improve the phasor measurement precision of signal compressive sensing discrete fourier transform information processing technology phasor measurement reconstruction algorithm 38th international conference on information systems architecture and technology isat 2017 the proceedings contain 101 papers the special focus in this conference is on information systems architecture and technology the topics include use of the modified epsilon decomposition for the lti models reduction modified hals algorithm for image completion and recommendation system proposal of input shaper in real applications a structure driven process of automated refactoring to design patterns modeling autoreferential relationships in association oriented database metamodel identification of objects based on generalized amplitude phase images statistical models fundamental transforms and models an intelligent multi agent system framework for fault diagnosis of squirrel cage induction motor broken bars performance comparison of neural network training algorithms for load forecasting in smart grids the experiment with quality assessment method based on strategy design pattern example development of a support system for managing the cyber security of information and communication environment of transport brainstorming sessions – towards improving effectiveness and assessment of ideas generation analysis of ims ngn call processing performance using phase type distributions based on experimental histograms motion repeatability of tennis forehand preparation phase without the ball using three dimensional data towards standardized mizar environments formalization of the nominative algorithmic algebra in mizar military and crisis management decision support tools for situation awareness development using sensor data fusion a practical approach to tiling zuker s rna folding using the transitive closure of loop dependence graphs and on loss process in a queueing system operating under single vacation policy a survey on problems related to the teaching of programming in brazilian educational institutions 2017 ieee almost all college and university courses have integrated disciplines for the teaching of programming in their curricula the importance of knowing how to program has contributed towards increasing private and public initiatives for the teaching of programming in different countries many of such initiatives include changes in the curriculum of primary and high schools replacing disciplines by programming classes despite the increasing needs for the learning of programming many limitations and problems as i learning to program ii application of programming concepts iii understanding of programs iv process of refactoring and factoring programs v students motivation and vi teachers difficulties have been imposed on this domain in this perspective this paper presents a survey conducted with brazilian teachers and learners from private and public institutions aiming at i identifying the relevance of the international problems in brazilian higher education ii identifying the main solutions that have been adopted in programming disciplines and their limitations including software solutions and iii collecting problems in teaching of programming in learner s perspective based on the results of the survey a set of main challenges to be solved for providing a better adoption of programming disciplines in brazilian curricula are presented and discussed the challenges are complemented with discussions about the economic and technological limitations of the country moreover means to mitigate the problems presented in both scenarios national and international are discussed as well managing hidden dependencies in oo software a study based on open source projects 2017 ieee dependency based software change impact analysis is the domain concerned with estimating the sets of artifacts impacted by a change to a related artifact research has shown that analysing the various class dependency types independently will never completely reveal the impact sets therefore dependency types are combined to improve the precision of estimated when compared to impact sets software classes can be linked in different ways for instance semantically if their meaning is somewhat related or structurally if one class depends on the services of other classes hidden dependencies arise when two classes linked structurally do not share the same semantic namespace or when semantically dependent classes do not share a structural link with the goal of revealing hidden dependencies during change impact analysis we empirically investigated the relationship between structural and semantic class dependencies in object oriented software systems results show that i semantic and structural links are significantly associated ii the strengths of those links do not play a significant role and iii a significant number of dependencies are hidden we propose two refactoring techniques to deal with hidden dependencies based on existing design patterns we plan to investigate them further to assert whether either has the potential for reducing refactoring and testing effort house of cards code smells in open source c repositories 2017 ieee background code smells are indicators of quality problems that make a software hard to maintain and evolve given the importance of smells in the source code s maintainability many studies have explored the characteristics of smells and analyzed their effects on the software s quality aim we aim to investigate fundamental characteristics of code smells through an empirical study on frequently occurring smells that examines inter category and intra category correlation between design and implementation smells method the study mines 19 design smells and 11 implementation smells in 1988 c repositories containing more than 49 million lines of code the mined data are statistically analyzed using methods such as spearman s correlation and presented through hexbin and scatter plots results we find that unutilized abstraction and magic number smells are the most frequently occurring smells in c code our results also show that implementation and design smells exhibit strong inter category correlation the results of co occurrence analysis imply that whenever unutilized abstraction or magic number smells are found it is very likely to find other smells from the same smell category in the project conclusions our experiment shows high average smell density 14 7 and 55 8 for design and implementation smells respectively for open source c programs such high smell densities turn a software system into a house of cards reflecting the fragility introduced in the system our study advocates greater awareness of smells and the adoption of regular refactoring within the developer community to avoid turning software into a house of cards c code quality code smells design smells implementation smells maintainability predicting move method refactoring opportunities in object oriented code 2017 elsevier b v context refactoring is the maintenance process of restructuring software source code to improve its quality without changing its external behavior move method refactoring mmr refers to moving a method from one class to the class in which the method is used the most often manually inspecting and analyzing the source code of the system under consideration to determine the methods in need of mmr is a costly and time consuming process existing techniques for identifying mmr opportunities have several limitations such as scalability problems and being inapplicable in early development stages most of these techniques do not consider semantic relationships objective we introduce a measure and a corresponding model to precisely predict whether a class includes methods in need of mmr the measure is applicable once a class has entered the early development stages without waiting for other classes to be developed method the proposed measure considers both the cohesion and coupling aspects of methods in addition the measure uses structural and semantic data available within the class of interest a statistical technique is applied to construct prediction models for classes that include methods in need of mmr the models are applied on seven object oriented systems to empirically evaluate their abilities to predict mmr opportunities results the results show both that the prediction models based on the proposed measure had outstanding prediction abilities and that the measure was able to correctly detect more than 90 of the methods in need of mmr within the predicted classes conclusions the proposed measure and corresponding prediction models are expected to greatly assist software engineers both in locating classes that include methods in need of mmr and in identifying these methods within the predicted classes class quality logistic regression analysis move method refactoring object oriented design reengineering legacy applications into software product lines a systematic mapping 2017 springer science business media new york software product lines spls are families of systems that share common assets allowing a disciplined reuse rarely spls start from scratch instead they usually start from a set of existing systems that undergo a reengineering process many approaches to conduct the reengineering process have been proposed and documented in research literature this scenario is a clear testament to the interest in this research area we conducted a systematic mapping study to provide an overview of the current research on reengineering of existing systems to spls identify the community activity in regarding of venues and frequency of publications in this field and point out trends and open issues that could serve as references for future research this study identified 119 relevant publications these primary sources were classified in six different dimensions related to reengineering phases strategies applied types of systems used in the evaluation input artefacts output artefacts and tool support the analysis of the results points out the existence of a consolidate community on this topic and a wide range of strategies to deal with different phases and tasks of the reengineering process besides the availability of some tools we identify some open issues and areas for future research such as the implementation of automation and tool support the use of different sources of information need for improvements in the feature management the definition of ways to combine different strategies and methods lack of sophisticated refactoring need for new metrics and measures and more robust empirical evaluation reengineering of existing systems into spls is an active research topic with real benefits in practice this mapping study motivates new research in this field as well as the adoption of systematic reuse in software companies evolution legacy systems product family reengineering systematic reuse determination of optimum refactoring sequence using a∗ algorithm after prioritization of classes 2017 ieee bad smells are the surface indication of deeper problem into source code therefore they need to be identified as early as possible without compromising on the quality of the software this lead towards the requirement of refactoring that is the process used in improving the internal attributes like maintainability of the software without affecting its external attributes hence to enhance quality in terms of maintainability refactoring should be done in a controlled and iterative manner in this study we have proposed a method that will help researchers and developers to generate a refactoring sequence in advance with the help of heuristic search a∗ algorithm we have chosen one class of an open source project with the help of prioritization technique to illustrate the generation of the sequence a∗ algorithm helps in finding an appropriate sequence which has maximum value of maintainability by choosing a path of minimum metrics value we have identified ten bad smells and used nine refactoring techniques to remove them with the help of this technique software developers and maintainers team would be able to figure out refactoring sequence in advance and hence will help them in completing their work within time and budget constraints a∗ algorithm maintainability metrics quality refactoring sequence semantic preserving pre processing method for c clone code 2017 editorial board of journal of the university of electronic science and technology of china all right reserved the output results of clone code detection tool cannot be directly refactored because of the two reasons one is the false positives of clone inconsistency related bugs detection and the other is that all the detected clones cannot be suitable for refactoring therefore the output results of clone code detection tool need to be pre processed for reducing the error checking of cloning inconsistencies defect a pre processing approach combing adaptive k nearest neighbor clustering with program dependence graph is proposed in this paper to solve these problems first adaptive k nearest neighbor clustering and program dependence graph are used to reduce the false positives of clones inconsistency related bugs detection and then the refactorable clone code is identified to reduce the cost of clone maintenance the results of the study show that our approach not only effectively prunes the false positives of clone inconsistency related bugs but also eliminates the gap between clone code detection and clone refactoring therefore our method contributes to improving the quality of the software and decreasing the cost of software maintenance adaptive k nearest neighbor clustering clone code clone inconsistency related bugs detection program dependence graph refactoring a quality enhancement through defect reduction using refactoring operation 2017 ieee refactoring is widely used technique to enhance overall quality of an existing software system by changing its internal structure without modifying its external behavior although it is difficult to implement the refactoring manually it helps to reduce the defects in the existing software three main types of design defects are investigated in the current study namely blob spaghetti code sc and functional decomposition fd by applying specific rule which are based on the combination of object oriented oo metrics and their threshold values further study also suggests a novel approach to minimize the defects and improve the quality of software system by applying specific refactoring operations into the code five large open source projects jdatepicker jxls jtds jfreechart and jhotdraw were used for the empirical evaluation of the suggested approach results show that the refactoring is very effective for reducing the probability of the number of defects in existing software we found that 20 16 4 14 and 5 defects are reduced in jdatepicker jxls jtds jfreechart and jhotdraw software respectively the results produces in this study are useful for the developers to identify the defect prone areas in the software and reduce the probability of occurrence of defects in source code before its release defect detection internal quality attributes object oriented metrics refactoring software maintainability gems an extract method refactoring recommender 2017 ieee extract method is a widely used refactoring operation to improve method comprehension and maintenance much research has been done to extract codefragments within the method body to form a new method criteria used for identifying extractable code is usually centered around degrees of cohesiveness coupling and length of the method however automatic method extraction techniques have not been highly successful since it can be hard to concretizethe criteria in this work we present a novel system that learns these criteria for extract method refactorings from open source repositories we extractstructural and functional features which encode the concepts of complexity cohesion and coupling in our learning model and train it to extract suitablecode fragments from a given source of a method our tool gems recommends a ranked list of code fragments with high accuracy and greatspeed we evaluated our approach on several open source repositories and compared it against three state of the art approaches 2014 semi jextract andjdeodorant the results on these open source data show the superiority of our machine learning based approach in terms of effectiveness we develop gems asan eclipse plugin with the intention to support software reliability through method extraction evolving software trace links between requirements and source code 2017 springer science business media llc traceability provides support for diverse software engineering activities including safety analysis compliance verification test case selection and impact prediction however in practice there is a tendency for trace links to degrade over time as the system continually evolves this is especially true for links between source code and upstream artifacts such as requirements – because developers frequently refactor and change code without updating the links in this paper we present tle trace link evolver a solution for automating the evolution of bidirectional trace links between source code classes or methods and requirements tle depends on a set of heuristics coupled with refactoring detection tools and informational retrieval algorithms to detect predefined change scenarios that occur across contiguous versions of a software system we first evaluate tle at the class level in a controlled experiment to evolve trace links for revisions of two java applications second we comparatively evaluate several variants of tle across six releases of our in house dronology project we study the results of integrating human analyst feed back in the evolution cycle of this emerging project additionally in this system we compare the efficacy of class level versus method level evolution of trace links finally we evaluate tle in a larger scale across 27 releases of the cassandra database system and show that the evolved trace links are significantly more accurate than those generated using only information retrieval techniques evolution maintenance traceability bug propagation through code cloning an empirical study 2017 ieee code clones are defined to be the identical or nearly similar code fragments in a code base according to a number of existing studies code clones are directly related to bugs and inconsistencies in software systems code cloning i e creating code clones is suspected to propagate temporarily hidden bugs from one code fragment to another however there is no study on the intensity of bug propagation through code cloning in this paper we present our empirical study on bug propagation through code cloning we define two clone evolution patterns that reasonably indicate bug propagation through code cloning we first identify code clones that experienced bug fix changes by analyzing software evolution history and then determine which of these code clones evolved following the bug propagation patterns according to our study on thousands of commits of four open source subject systems written in java up to 33 of the clone fragments that experience bug fix changes can contain propagated bugs around 28 57 of the bug fixes experienced by the code clones can occur for fixing propagated bugs we also find that near miss clones are primarily involved with bug propagation rather than identical clones the clone fragments involved with bug propagation are mostly method clones bug propagation is more likely to occur in the clone fragments that are created in the same commit operation rather than in different commits our findings are important for prioritizing code clones for refactoring and tracking from the perspective of bug propagation does refactoring of test smells induce fixing flaky tests 2017 ieee regression testing is a core activity that allows developers to ensure that source code changes do not introduce bugs an important prerequisite then is that test cases are deterministic however this is not always the case as some tests suffer from socalled flakiness flaky tests have serious consequences as they can hide real bugs and increase software inspection costs existing research has focused on understanding the root causes of test flakiness and devising techniques to automatically fix flaky tests a key area of investigation being concurrency in this paper we investigate the relationship between flaky tests and three previously defined test smells namely resource optimism indirect testing and test run war we have set up a study involving 19 532 junit test methods belonging to 18 software systems a key result of our investigation is that 54 of tests that are flaky contain a test code smell that can cause the flakiness moreover we found that refactoring the test smells not only removed the design flaws but also fixed all 54 of flaky tests causally co occurring with test smells flaky tests refactoring test smells analysis of code smell to quantify the refactoring 2017 the society for reliability engineering quality and operations management sreqom india and the division of operation and maintenance lulea university of technology sweden during development process software may encounter design flaws which are referred as code smell these code smells are potential faults that can be handled using suitable refactoring approach refactoring being an expensive process is a thought provocation task and there is a need to identify the relationship between code smells and design metrics by considering expert s opinion the approach adopted in this paper ranks the design metrics according to their criticality and need using ahp this method helps to identify refactoring approach that may be used to improve the code and needs to be implemented before the execution phase the proposed approach is explained considering a case study of medium sized software ahp code smell design metrics refactoring approach weights an integrated metamodel based approach to software model refactoring 2017 springer verlag gmbh germany software refactoring is the process of changing a software system in a manner that does not alter its external behavior and yet improving its internal structure model driven architecture and the popularity of the uml enabled the application of refactoring at model level which was earlier applied to software code in this paper we propose a multi view integrated approach to model driven refactoring using uml models we selected a single model from each uml view at metamodel level to construct an integrated metamodel we selected class diagram to represent the structural view sequence diagram to represent the behavioral view and use case diagram to represent the functional view we validated the proposed approach by comparing integrated refactoring approach with refactoring applied to models individually in terms of quality improvement through uml model metrics our results indicate that more bad smell instances can be detected using the integrated approach rather than the individual refactoring approach metamodel model refactoring refactoring uml a comparison of code similarity analysers 2017 the author s copying and pasting of source code is a common activity in software engineering often the code is not copied as it is and it may be modified for various purposes e g refactoring bug fixing or even software plagiarism these code modifications could affect the performance of code similarity analysers including code clone and plagiarism detectors to some certain degree we are interested in two types of code modification in this study pervasive modifications i e transformations that may have a global effect and local modifications i e code changes that are contained in a single method or code block we evaluate 30 code similarity detection techniques and tools using five experimental scenarios for java source code these are 1 pervasively modified code created with tools for source code and bytecode obfuscation and boiler plate code 2 source code normalisation through compilation and decompilation using different decompilers 3 reuse of optimal configurations over different data sets 4 tool evaluation using ranked based measures and 5 local global code modifications our experimental results show that in the presence of pervasive modifications some of the general textual similarity measures can offer similar performance to specialised code similarity tools whilst in the presence of boiler plate code highly specialised source code similarity detection techniques and tools outperform textual similarity measures our study strongly validates the use of compilation decompilation as a normalisation technique its use reduced false classifications to zero for three of the tools moreover we demonstrate that optimal configurations are very sensitive to a specific data set after directly applying optimal configurations derived from one data set to another the tools perform poorly on the new data set the code similarity analysers are thoroughly evaluated not only based on several well known pair based and query based error measures but also on each specific type of pervasive code modification this broad thorough study is the largest in existence and potentially an invaluable guide for future users of similarity detection in source code clone detection code similarity measurement empirical study parameter optimisation plagiarism detection implementation of software systems packages in visual internal structures 2005 – ongoing jatit lls this manuscript discusses the visualization methods of software systems architecture with composition of reverse engineering tools and restoration of software systems architecture the visualization methods and analysis of dependencies in software packages are written in java to use this performance graph it needs to describe the relationships between classes inside the analyzed packages and between classes of different packages this article discusses system visualization with using matrices of incoming and outgoing packet dependencies allowing analyzing existing dependencies between classes within a package and between classes of different packages obtaining such information allows us to understand the reason for the emergence of dependencies between packages that determine architecture of the system and also if necessary refactoring systems in the manuscript also described the possibility of tools to provide the infrastructure for subsequent detection and error correction design in software systems and its refactoring dependency package reverse engineering software architecture software visualization identifying extract method refactoring opportunities based on functional relevance 1976 2012 ieee extract method is considered one of the most frequently applied and beneficial refactorings since the corresponding long method smell is among the most common and persistent ones although long method is conceptually related to the implementation of diverse functionalities within a method until now this relationship has not been utilized while identifying refactoring opportunities in this paper we introduce an approach accompanied by a tool that aims at identifying source code chunks that collaborate to provide a specific functionality and propose their extraction as separate methods the accuracy of the proposed approach has been empirically validated both in an industrial and an open source setting in the former case the approach was capable of identifying functionally related statements within two industrial long methods approx 500 loc each with a recall rate of 93 percent in the latter case based on a comparative study on open source data our approach ranks better compared to two well known techniques of the literature to assist software engineers in the prioritization of the suggested refactoring opportunities the approach ranks them based on an estimate of their fitness for extraction the provided ranking has been validated in both settings and proved to be strongly correlated with experts opinion design tools and techniques metrics measurement object oriented programming a survey on the importance of object oriented design best practices 2017 ieee to measure object oriented design quality metric based approaches have been established these have then been enhanced by identifying design smells in code while these approaches are useful for identifying hot spots that should be refactored they are still too vague to sufficiently guide software developers to implement improvements this is why our previous work focuses on measuring the compliance of source code with object oriented design best practices these design best practices were systematically derived from the literature and can be mapped to design principles which can help reveal fundamental object oriented design issues in a software product despite the successful applications of this approach in industrial and open source projects there is little accepted knowledge about the importance of various design best practices consequently this paper shows the result of an online survey aimed at identifying the importance of 49 design best practices on design quality in total 214 people participated in the survey resulting in an average of 138 opinions for each practice based on these opinions five very important 21 important 12 moderately important and 11 unimportant design best practices could be derived this information about importance helps managing design improvements in a focused way design best practices design principles design quality software quality data fusion for software remodularization 2017 ieee software refactoring aims at optimizing software modularization by improving internal software structure without altering its external behavior there exists various approaches for suggesting refactoring opportunities based on different sources of information e g structural semantic and historical in this paper we propose a data fusion model to combine different sources of information in order to identify refactoring opportunities and we instantiate it to support move class refactoring we report the results of our validation conducted on four software systems and we show that our proposal improves the modularization quality by 29 and that our tool is able to provide meaningful recommendations for move class refactoring specifically more than 70 of the recommendations were considered meaningful from the developers point of view data fusion refactoring software remodularization beter similarity coeficients to identify refactoring opportunities 2017 association for computing machinery similarity coeficients are used by several techniques to identify refactoring opportunities as an example it is expected that a method is located in a class that is structurally similar to it however the existing coeficients in literature have not been designed for the structural analysis of software systems which may not guarantee satisfactory accuracy this paper therefore proposes new coeficients based on genetic algorithms over a training set of ten systems to improve the accuracy of the identification of move class move method and extract method refactoring opportunities we conducted an empirical study comparing these proposed coeficients with other 18 coeficients in other 101 systems the results indicate in relation to the best analyzed coeficient an improvement of 10 57 for the identification of move method refactoring opportunities 3 17 for move class and 0 30 for extract method moreover we implemented a tool that relies on the proposed coefficients to recommend refactoring opportunities code refactoring extract method move class move method software architecture structural similarity acm international conference proceeding series the proceedings contain 12 papers the topics discussed include two quasi experiments on cohesion metrics and program comprehension preliminary study on the correlation of objective functions to optimize product line architectures characterizing big data software architectures a systematic mapping study aspects influencing feature oriented software comprehension better similarity coefficients to identify refactoring opportunities applying software metric thresholds for detection of bad smells revealing design problems in stinky code a mixed method study distributed quality attribute optimization of software architectures spotify characterization as a software ecosystem a structured survey on the usage of the issue tracking system provided by the github platform investigating the relationship between bad smells and bugs in software systems and investigating the variability impact on the recovery of software product line architectures an exploratory study the scent of a smell an extensive comparison between textual and structural smells ieee code smells are symptoms of poor design or implementation choices that have a negative effect on several aspects of software maintenance and evolution such as program comprehension or change and fault proneness this is why researchers have spent a lot of effort on devising methods that help developers to automatically detect them in source code almost all the techniques presented in literature are based on the analysis of structural properties extracted from source code although alternative sources of information e g textual analysis for code smell detection have also been recently investigated nevertheless some studies have indicated that code smells detected by existing tools based on the analysis of structural properties are generally ignored and thus not refactored by the developers in this paper we aim at understanding whether code smells detected using textual analysis are perceived and refactored by developers in the same or different way than code smells detected through structural analysis to this aim we set up two different experiments we have first carried out a software repository mining study to analyze how developers act on textually or structurally detected code smells subsequently we have conducted a user study with industrial developers and quality experts in order to qualitatively analyze how they perceive code smells identified using the two different sources of information results indicate that textually detected code smells are easier to identify and for this reason they are considered easier to refactor with respect to code smells detected using structural properties on the other hand the latter are often perceived as more severe but more difficult to exactly identify and remove code smells data mining detectors empirical study large scale integration maintenance engineering mining software repositories software systems tools the relationship of code churn and architectural violations in the open source software jabref 2017 acm the open source application jabref has existed since 2003 in 2015 the developers decided to make an architectural refactoring as continued development was deemed too demanding the developers also introduced static architecture conformance checking sacc to prevent violations to the intended architecture measurements mined from source code repositories such as code churn and code ownership has been linked to several problems for example fault proneness security vulnerabilities code smells and degraded maintainability the root cause of such problems can be architectural to determine the impact of the refactoring of jabref we measure the code churn and code ownership before and after the refactoring and find that large files with violations had a significantly higher code churn than large files without violations before the refactoring after the refactoring the files that had violations show a more normal code churn we find no such effect on code ownership we conclude that files that contain violations detectable by sacc methods are connected to higher than normal code churn conformance checking repository data mining software architecture finding extract method refactoring opportunities by analyzing development history 2017 ieee refactoring is an important technique to improve maintainability of software and developers often use this technique during a development process before now researchers have proposed some techniques finding refactoring opportunities for developers finding refactoring opportunities means identifying locations to be refactored however there are no specific criteria for developers to determine where they should refactor because the criteria differ from project to project and from developer to developer in this study we propose a technique to find refactoring opportunities in source code by using machine learning techniques machine learning techniques enable to flexibly find refactoring opportunities by the characteristics of target projects and developers our proposed technique learns information on the features of refactorings conducted in the past then based on this information it suggests some refactorings on given the source code to developers we investigated three research questions with five open source projects as a result we confirmed that the proposed technique was able to find refactorings with high accuracy extract method msr refactoring deduct a data dependence based concern tagger for modularity analysis 2017 ieee modularity of a software system can be assessed once responsibilities of each method and class have been determined generally developers attribute responsibilities to methods and classes manually this can be problematic given that it relies on developers judgement and effort this paper proposes an approach to automatically attribute concern tags to each instructions the approach is based on taint analysis to determine which code lines are related to each other by data dependence moreover java apis provide the tags used to mark code lines the automatic concern tagging that we bring about is used to find out how responsibilities are spread in the code and then to suggest refactoring activities in case tangling occurs concern identification data dependence modularity taint analysis rankprod 2 0 a refactored bioconductor package for detecting differentially expressed features in molecular profiling datasets the author s 2017 published by oxford university press motivation the rank product rp is a statistical technique widely used to detect differentially expressed features in molecular profiling experiments such as transcriptomics metabolomics and proteomics studies an implementation of the rp and the closely related rank sum rs statistics has been available in the rankprod bioconductor package for several years however several recent advances in the understanding of the statistical foundations of the method have made a complete refactoring of the existing package desirable results we implemented a completely refactored version of the rankprod package which provides a more principled implementation of the statistics for unpaired datasets moreover the permutation based p value estimation methods have been replaced by exact methods providing faster and more accurate results availability and implementation rankprod 2 0 is available at bioconductor https www bioconductor org packages devel bioc html rankprod html and as part of the mzmatch pipeline http www mzmatch sourceforge net contact rainer breitling manchester ac uk supplementary information supplementary data are available at bioinformatics online static analysis of model transformations 1976 2012 ieee model transformations are central to model driven engineering mde where they are used to transform models between different languages to refactor and simulate models or to generate code from models thus given their prominent role in mde practical methods helping in detecting errors in transformations and automate their verification are needed in this paper we present a method for the static analysis of atl model transformations the method aims at discovering typing and rule errors like unresolved bindings uninitialized features or rule conflicts it relies on static analysis and type inference and uses constraint solving to assert whether a source model triggering the execution of a given problematic statement can possibly exist our method is supported by a tool that integrates seamlessly with the atl development environment to evaluate the usefulness of our method we have used it to analyse a public repository of atl transformations the high number of errors discovered shows that static analysis of atl transformations is needed in practice moreover we have measured the precision and recall of the method by considering a synthetic set of transformations obtained by mutation techniques and comparing with random testing the experiment shows good overall results in terms of false positives and negatives atl model finders model transformation model driven engineering static analysis verification and testing a semi automatic coarse grained parallelization approach for loop optimization and irregular code sections 2017 science press all right reserved although the multi core processors have become the mainstream processor architectures of the time it is still hard to take advantage of the parallel computing power for many serial programs and software due to the lack of efficient parallelization manually re engineering and refactoring of these legacy software is time consuming and costly therefore the automatic parallelization techniques become the focus of attention in academia and industry in this article a novel semi automatic parallelization approach is proposed targeting on optimization for regular for loops and coarse grained parallelism for irregular code sections in general programs this approach employs a dynamic program analyzer to obtain the control and data dependences of programs the gathered dependences information is used to form the computational unit cu graphs and then the task graphs are further created from which coarse grained task parallelism of code sections can be extracted meanwhile for the for loop codes a series of optimizations are adopted for code transformations a profitable tiling model is proposed to effectively choose suitable loop codes for further optimization the model is based on a mass of statistical data on locality analysis of loop iterations and it can determine whether the loop codes should perform loop tiling by invoking a loop transformation optimizer the tile size selection tss has an important impact on the performance of tiled codes and a uniform mapping in cache based tile size selection umc tss is proposed to generate optimal tiled codes and achieve better performance during tiling the umc tss improves the method of a state of the art tss to exploit better cache utilization and loop parallelism eventually a source to source transformation frame based on the llvm frontend clang is developed to transform sequential c c codes to intel tbb parallel codes the frame is integrated with dynamic program analysis coarse grained parallelism extraction loop optimizations including the proposed profitable tiling model and umc tss and code transformations it performs high level code restructuring on the program abstract syntax tree according to the task graphs the intel tbb parallel_for and flow graph templates are used to package the for loops and irregular code sections into parallel codes respectively the code transformation is semi automatic that only a little manual effort and intervention is involved a series of experiments have been conducted to evaluate the performance of the transformed parallel codes over 18 representative benchmarks selected from 4 different kinds of benchmark suits the experiment results show that the parallel codes generated by the semi automatic approach can achieve good parallelism when compared to the parallel codes written by experts especially the codes with optimized for loops the average speedups of for loops parallelization and task parallelization are 10 95 and 4 45 respectively on an intel xeon multi core server the correctness of the profitable tiling model is validated as well in the evaluation the experiment results also show that the umc tss improves the performance of 4 on average in the tiled loop codes in comparison with a state of the art tile size selection algorithm the experiment results also show that the generated intel tbb parallel codes have good scalability when the thread number varies which demonstrates the effectiveness of the parallelization approach and the source to source transformation frame presented in this paper locality analysis loop tiling optimal tile size selection semi automatic parallelization source to source code transformation understanding the impact of refactoring on smells a longitudinal study of 23 software projects 2017 association for computing machinery code smells in a program represent indications of structural quality problems which can be addressed by software refactoring however refactoring intends to achieve different goals in practice and its application may not reduce smelly structures developers may neglect or end up creating new code smells through refactoring unfortunately little has been reported about the beneficial and harmful effects of refactoring on code smells this paper reports a longitudinal st udy intended to address this gap we analyze how often commonly used refactoring types affect the density of 13 types of code smells along the version histories of 23 projects our findings are based on the analysis of 16 566 refactorings distributed in 10 different types even though 79 4 of the refactorings touched smelly elements 57 did not reduce their occurrences surprisingly only 9 7 of refactorings removed smells while 33 3 induced the introduction of new ones more than 95 of such refactoringinduced smells were not removed in successive commits which suggest refactorings tend to more frequently introduce long living smells instead of eliminating existing ones we also characterized and quantified typical refactoring smell patterns and observed that harmful patterns are frequent including i approximately 30 of the move method and pull up method refactorings induced the emergence of god class and ii the extract superclass refactoring creates the smell speculative generality in 68 of the cases code smells refactoring structural quality mitigating the inevitable failure of knowledge representation 2017 ieee this paper is a continuation of a previous paper on self modeling systems concerning mitigation methods for the get stuck theorems which are powerful theorems about the limits of knowledge representation the first get stuck theorem says that since there are only finitely many data structures of any given size it follows that as a system tries to save more and more data information knowledge the structures necessarily get larger and eventually they are too large for effective computation the mitigations we described are behavior mining which is about building models of the system and environment behavior model deficiency analysis which is about assessing the efficacy of those models and determining how to improve them knowledge refactoring which is about restructuring the saved data for more efficient access and smaller storage and constructive forgetting which is about explicitly discarding some data that is deemed to be less critical we argue that these classes of mitigations and a couple of new ones can help a system retain effectively computable knowledge structures in a dynamic environment at higher levels of difficulty of course as the environment gets more dynamic all systems including individual biological organisms and even species eventually fail behavior mining get stuck theorems knowledge refactoring model deficiency analysis self adaptive systems self aware systems self modeling systems a genetic algorithm based approach for automated refactoring of component based software 2017 elsevier b v context during its lifecycle a software system undergoes repeated modifications to quickly fulfill new requirements but its underlying design is not properly adjusted after each update this leads to the emergence of bad smells refactoring provides a de facto behavior preserving approach to eliminate these anomalies however manually determining and performing useful refactorings is a formidable challenge as stated in the literature therefore framing object oriented automated refactoring as a search based technique has been proposed however the literature shows that search based refactoring of component based software has not yet received proper attention objective this paper presents a genetic algorithm based approach for the automated refactoring of component based software this approach consists of detecting component relevant bad smells and eliminating these bad smells by searching for the best sequence of refactorings using a genetic algorithm method our approach consists of four steps the first step includes studying the literature related to component relevant bad smells and formulating bad smell detection rules the second step involves proposing a catalog of component relevant refactorings the third step consists of constructing a source code model by extracting facts from the source code of a component based software the final step seeks to identify the best sequence of refactorings to apply to reduce the presence of bad smells in the source code model using a genetic algorithm the latter uses bad smell detection rules as a fitness function and the catalog of refactorings as a means to explore the search space results as a case study we conducted experiments on an unbiased set of four real world component based applications the results indicate that our approach is able to efficiently reduce the total number of bad smells by more than one half which is an acceptable value compared to the recent literature moreover we determined that our approach is also accurate in refactoring only components suffering from bad smells while leaving the remaining components untouched whenever possible furthermore a statistical analysis shows that our genetic algorithm outperforms random search and local search in terms of efficiency and accuracy on almost all the systems investigated in this work conclusion this paper presents a search based approach for the automated refactoring of component based software to the best of our knowledge our approach is the first to focus on component based refactoring whereas the state of the art approaches focus only on object oriented refactoring bad smells component based software engineering genetic algorithm refactoring two phase assessment approach to improve the efficiency of refactoring identification ieee to automate the refactoring identification process a large number of candidates need to be compared such an overhead can make the refactoring approach impractical if the software size is large and the computational load of a fitness function is substantial in this paper we propose a two phase assessment approach to improving the efficiency of the process for each iteration of the refactoring process refactoring candidates are preliminarily assessed using a lightweight fast delta assessment method called the delta table using multiple delta tables candidates to be evaluated with a fitness function are selected a refactoring can be selected either interactively by the developer or automatically by choosing the best refactoring and the refactorings are applied one after another in a stepwise fashion the delta table is the key concept enabling a two phase assessment approach because of its ability to quickly calculate the varying amounts of maintainability provided by each refactoring candidate our approach has been evaluated for three large scale open source projects the results convincingly show that the proposed approach is efficient because it saves a considerable time while still achieving the same amount of fitness improvement as the approach examining all possible candidates computational efficiency couplings maintainability improvement measurement open source software refactoring assessment refactoring identification symmetric matrices system analysis and design automated refactoring of legacy java software to default methods 2017 ieee java 8 default methods which allow interfaces to contain instance method implementations are useful for the skeletal implementation software design pattern however it is not easy to transform existing software to exploit default methods as it requires analyzing complex type hierarchies resolving multiple implementation inheritance issues reconciling differences between class and interface methods and analyzing tie breakers dispatch precedence with overriding class methods to preserve type correctness and confirm semantics preservation in this paper we present an efficient fully automated type constraint based refactoring approach that assists developers in taking advantage of enhanced interfaces for their legacy java software the approach features an extensive rule set that covers various corner cases where default methods cannot be used to demonstrate applicability we implemented our approach as an eclipse plug in and applied it to 19 real world java projects as well as submitted pull requests to popular github repositories the indication is that it is useful in migrating skeletal implementation methods to interfaces as default methods sheds light onto the pattern s usage and provides insight to language designers on how this new construct applies to existing software default methods interfaces java refactoring proceedings 2017 ieee acm 39th international conference on software engineering icse 2017 the proceedings contain 68 papers the topics discussed include semantically enhanced software traceability using deep learning techniques can latent topics in source code predict missing architectural tactics preventing defects the impact of traceability completeness on software quality imprecise matching of requirements specifications for software services using fuzzy logic analyzing apis documentation and code to detect directive defects detecting user story information in developer client conversations to generate extractive summaries keyword search for building service based systems clone refactoring with lambda expressions automated refactoring of legacy java software to default methods using cohesion and coupling for software remodularization is it enough recommending and localizing change requests for mobile apps based on user reviews machine learning based detection of open source license exceptions supporting change impact analysis using a recommendation system an industrial case study in a safety critical context becoming agile a grounded theory of agile transitions in practice from diversity by numbers to diversity as process supporting inclusiveness in software development teams with brainstorming and process aspects and social dynamics of contemporary code review insights from open source development and industrial practice at microsoft code smell severity classification using machine learning techniques 2017 elsevier b v several code smells detection tools have been developed providing different results because smells can be subjectively interpreted and hence detected in different ways machine learning techniques have been used for different topics in software engineering e g design pattern detection code smell detection bug prediction recommending systems in this paper we focus our attention on the classification of code smell severity through the use of machine learning techniques in different experiments the severity of code smells is an important factor to take into consideration when reporting code smell detection results since it allows the prioritization of refactoring efforts in fact code smells with high severity can be particularly large and complex and create larger issues to the maintainability of software a system in our experiments we apply several machine learning models spanning from multinomial classification to regression plus a method to apply binary classifiers for ordinal classification in fact we model code smell severity as an ordinal variable we take the baseline models from previous work where we applied binary classification models for code smell detection with good results we report and compare the performance of the models according to their accuracy and four different performance measures used for the evaluation of ordinal classification techniques from our results while the accuracy of the classification of severity is not high as in the binary classification of absence or presence of code smells the ranking correlation of the actual and predicted severity for the best models reaches 0 88–0 96 measured through spearman s ρ code smell severity code smells detection machine learning ordinal classification refactoring prioritization prioritization of smelly classes a two phase approach reducing refactoring efforts 2017 ieee frequent changes in an object oriented software system often result into a poor quality and less maintainable design and the symptoms known as code smells causing that degradation need to be corrected for which refactoring is one of the possible solutions it is not feasible to refactor restructure each and every smelly class due to various constraints such as time and cost hence it is desirable to make an efficient approach of refactoring proposed scheme aims to save time and cost of refactoring by carrying out selective refactoring for high priority smelly classes prioritization is proposed to be done according to interaction level of each class with other classes the proposed methodology works in two phases first phase detects smelly classes using structural information of source code and second phase mines change history to prioritize smelly classes this prioritization is used to carry out refactoring of more severe classes this process helps in reducing efforts of refactoring and at the same time may result in avoiding refactoring chains the proposed technique has been evaluated over a software consisting of 49 classes and results have been validated the results clearly indicate that the proposed approach performs better and can be very useful for software maintainers in effective and efficient refactoring code smells interaction among classes object oriented software maintenance refactoring generating predicate callback summaries for the android framework 2017 ieee one of the challenges of analyzing testing and debugging android apps is that the potential execution orders of callbacks are missing from the apps source code however bugs vulnerabilities and refactoring transformations have been found to be related to callback sequences existing work on control flow analysis of android apps have mainly focused on analyzing gui events gui events although being a key part of determining control flow of android apps do not offer a complete picture our observation is that orthogonal to gui events the android api calls also play an important role in determining the order of callbacks in the past such control flow information has been modeled manually this paper presents a complementary solution of constructing program paths for android apps we proposed a specification technique called predicate callback summary pcs that represents the callback control flow information including callback sequences as well as the conditions under which the callbacks are invoked in android api methods and developed static analysis techniques to automatically compute and apply such summaries to construct apps callback sequences our experiments show that by applying pcss we are able to construct android apps control flow graphs including inter callback relations and also to detect infeasible paths involving multiple callbacks such control flow information can help program analysis and testing tools to report more precise results our detailed experimental data is available at http www cs iastate edu weile toolsdata summarizeandroidframework lithium html callbacks interprocedural analysis mobile static analysis summaries discussion on digestion method of refractory high carbon alloy steel 2017 cisri boyuan publishing co ltd all right reserved the refractory high carbon alloy steel was completely digested in hydrochloric acid and nitric acid by microwave digestion the content of major alloy elements was determined by inductively coupled plasma atomic emission spectrometry icp aes the digestion method the selection and dosage of digestive reagent the effect of water dosage on digestion of high silicon sample and the microwave digestion procedures were discussed the optimal digestion conditions were finally obtained as below 0 2 g of sample was weighed and then 10 0 ml of water 5 0 ml of hydrochloric acid and 5 0 ml of nitric acid were added successively the sample was treated by microwave digestion at 180℃ for the refractory high carbon alloy steel samples containing high silicon the mass fraction of silicon was higher than 1 0 more water should be added several refactory high carbon alloy steel samples were treated according to the experimental method and the content of main alloy elements si mn ni cr mo and v was determined by icp aes the relative standard deviations rsd n 8 were between 0 23 and 4 7 four standard samples of refractory high carbon alloy steel were treated according to the experimental method the content of si mn ni cr mo and v was determined by icp aes the found results were consistent with the certified values inductively coupled plasma atomic emission spectrometry microwave digestion refractory high carbon alloy steel a context based refactoring recommendation approach using simulated annealing two industrial case studies 2017 acm refactoring is a highly valuable solution to reduce and manage the growing complexity of software systems however programmers are opportunistic when they apply refactorings since most of them are interested in improving the quality of the code fragments that they frequently update or those related to the planned activities for the next release fixing bugs adding new functionalities etc in this paper we describe a search based approach to recommend refactorings based on the analysis of the history of changes to maximize the recommended refactorings for recently modified classes classes containing incomplete refactorings detected in previous releases and buggy classes identified in the history of previous bug reports the obtained results on two industrial projects show significant improvements of the relevance of recommended refactorings as evaluated by the original developers of the systems refactoring search based software engineering software quality perils of opportunistically reusing software module copyright 2016 john wiley sons ltd opportunistic reuse is a need based sourcing of software modules without a prior reuse plan it is a common tactical approach in software development developers often reuse an external software module opportunistically to improve their productivity but studies have shown that this results in extensive refactoring and adds maintenance owes we assert this problem to the mismatches between the software under development and the reused external module caused because of their different assumptions and constraints we highlight the problems of such opportunistic reuse practices with the help of a case study in our study we found issues such as unanticipated behavior violated constraints conflict in assumption fragile structure and software bloat in this paper we like to draw attention of the research community to the wide spread opportunistic reuse practices and the lack of methods to pro actively identify and resolve the mismatches we propose the need for supporting developers in reasoning before reuse from the perspective of identifying and fixing both local and global mismatches furthermore we identify other opportunistic software development practices where similar issues can be observed and also suggest the research areas where further investigation can benefit developers in improving their productivity copyright 2016 john wiley sons ltd design decisions opportunistic practices software bloat software reuse collaborative identification of code smells a multi case study 2017 ieee code smells are anomalous program structures that may indicate software maintainability problems god classes and feature envies are examples of code smells that frequently become the target of software refactoring however smell identification might be harder than expected due to the subjectivity involved in the recognition of the apparently simple structure of each smell moreover smell identification might require the knowledge of multiple program elements which are better understood by different developers thus the use of collaboration among developers may have the potential to improve effectiveness on smell identification however current knowledge especially empirically developed and evaluated in the industry is quite scarce this paper reports an industrial case study aimed at observing how 13 developers individually and collaboratively performed smell identification in five software projects from two software development organizations our results suggest that collaboration contributes to improving effectiveness on the identification of a wide range of code smells we also analyzed the factors contributing to such effectiveness improvement case study collaboration identification of code smells qualitative analysis an automated code smell and anti pattern detection approach 2017 ieee today software maintenance is more expensive than development costs as class complexity increases it is increasingly difficult for new programmers to adapt to software projects causing the cost of the software to go up therefore it s important to produce faultless and understandable code moreover software projects are not developed by one person alone even a small scale project needs 3 or more participants working on the code at the same time producing well designed code during the development stage has a significant value because this process makes software projects more understandable and leads to higher code quality consequently the cost of software project maintenance will decrease code smells and anti patterns are symptoms of poorly designed code the aforementioned tendencies of software projects increase the possibility of poor implementations and code imperfections therefore it is necessary to detect and refactor poorly designed code this paper describes an attempt to achieve their detection anti patterns automatic detection brain method code smells data class proceedings 2017 ieee acm 39th international conference on software engineering companion icse c 2017 the proceedings contain 167 papers the topics discussed include droidbot droidbot a lightweight ui guided test input generator for android fast and flexible large scale clone detection with cloneworks studying multi threaded behavior with tsviz cheetah just in time taint analysis for android apps statistical migration of api usages surf summarizer of user reviews feedback cssdev refactoring duplication in cascading style sheets bottom up technologies for reuse automated extractive adoption of software product lines jsdeodorant class awareness for javascript programs decision making in self protecting software systems a game theoretic approach empirical investigation of correlation between rewards and crowdsource based software developers improving test execution time with improved cache locality live programming the behavioral layer of robot runtime collaborative based configuration of software product lines obsidian a safer blockchain programming language a formally verified sequentializer for lustre like concurrent synchronous data flow programs a framework to preserve confidentiality in crowdsourced software development a hierarchical architecture for distributed security control of large scale systems and a machine learning approach for determining the validity of traceability links predicate callback summaries 2017 ieee one of the challenges to analyze test and debug android apps is that the potential execution orders of callbacks are missing from the apps source code however bugs vulnerabilities and refactoring transformations have been found to be related to callback sequences existing work on control flow analysis of android apps focuses on analyzing gui behaviors our observation is that orthogonal to gui the android api methods also play an important role in determining the order of callbacks and previously the apis were modeled manually in an ad hoc way this paper presents a complementary solution of constructing program paths for android apps we proposed a specification called predicate callback summary pcs that represents the callback control flow information including callback sequences as well as the conditions the callbacks are invoked in android api methods our experiments show we can compute pcss with reasonable accuracy and scalability and use them to build inter callback control flow graphs for apps our detailed experimental data are available at http www cs iastate edu weile toolsdata summarizeandroidframework lithium html callbacks interprocedural analysis mobile static analysis summaries brazil s bolsa familia and young adult workers a parallel rdd approach to large datasets 2017 ieee regression discontinuity design is a non experimental method to estimate the impacts of social welfare programs in situations where the treatment assignment is determined by whether an observed variable running variable is above or below a known cutoff point the main idea behind rdd is that individuals whose running variable is just above or just below the cutoff are similar and so any differences in the outcome between the two groups just below and just above may be attributed to the treatment despite the existence of many recent works on the rdd subject the existing software that implements the state of the art rdd procedures is unfit to deal with very large datasets which are increasingly more common the purpose of this work is to present a parallel computing approach refactoring of a well known rdd algorithm and apply it to a dataset from bolsa familia with more than 13 million observations the objective of the rdd study is to evaluate the impact of the program on the labor choices of needy 18 year old brazilian boys and girls we verified that the parallel approach was able to process bolsa familia data in a reasonable time and that it outperformed other existing rdd implementations developer related factors in change prediction an empirical assessment 2017 ieee predicting the areas of the source code having a higher likelihood to change in the future is a crucial activity to allow developers to plan preventive maintenance operations such as refactoring or peer code reviews in the past the research community was active in devising change prediction models based on structural metrics extracted from the source code more recently elish et al showed how evolution metrics can be more efficient for predicting change prone classes in this paper we aim at making a further step ahead by investigating the role of different developer related factors which are able to capture the complexity of the development process under different perspectives in the context of change prediction we also compared such models with existing change prediction models based on evolution and code metrics our findings reveal the capabilities of developer based metrics in identifying classes of a software system more likely to be changed in the future moreover we observed interesting complementarities among the experimented prediction models that may possibly lead to the definition of new combined models exploiting developer related factors as well as product and evolution metrics change prediction empirical studies mining software repositories removing code clones from industrial systems using compiler directives 2017 ieee refactoring of code clones is an effective method for improving software maintainability existing studies have proposed automated techniques and tools for refactoring however it is difficult to apply refactoring to our industrial systems in practice because of three main reasons first we have many industrial systems written in cobol which requires a particular refactoring method compared with current techniques because type 2 clones in cobol are generated by renaming parts of identifiers second nested clones must be refactored in which an instance of a clone set is contained within an instance of another clone set they also make it difficult to estimate the reduction size by refactoring third refactoring requires testing which is time consuming and laborious to overcome these problems we developed an approach for refactoring of type 2 clones in cobol programs our approach identifies actual refactorable clone sets and includes a string comparison technique to parameterize partial differences in identifier names the clone sets are extracted as shared code fragments and transformed into the refactored code using compiler directives it is easy to confirm that refactoring using compiler directives preserves program behavior because they do not change program structure we also provide a method that makes it possible to refactor nested clones by ordering their refactoring this method enables to estimate how many lines can be reduced by refactoring we applied the approach to four industrial systems to assess how many lines can be reduced the results show that the lines could be reduced by 10 to 15 and one system was reduced by 27 we also discuss the parameter number required for our refactoring approach cobol code clones refactoring ieee international conference on program comprehension the proceedings contain 41 papers the topics discussed include software engineers information seeking behavior in change impact analysis an interview study variability through the eyes of the programmer meaningful identifier names the case of single letter variables effects of variable names on comprehension an empirical study exploiting type hints in method argument names to improve lightweight type inference binary code clone detection across architectures and compiling configurations identifying code clones having high possibilities of containing bugs smells are sensitive to developers on the efficiency of un guided customized detection on the uniqueness of code redundancies repdroid an automated tool for android application repackaging detection netdroid summarizing network behavior of android apps for network code maintenance an exploratory study on the relationship between changes and refactoring developer related factors in change prediction an empirical assessment analyzing user comments on youtube coding tutorial videos bug localization with combination of deep learning and information retrieval and bug report enrichment with application of automated fixer recommendation the discipline of preprocessor based annotations does ifdef tag n t endif matter 2017 ieee the c preprocessor is a simple effective and language independent tool developers use the preprocessor in practice to deal with portability and variability issues despite the widespread usage the c preprocessor suffers from severe criticism such as negative effects on code understandability and maintainability in particular these problems may get worse when using undisciplined annotations i e when a preprocessor directive encompasses only parts of c syntactical units nevertheless despite the criticism and guidelines found in systems like linux to avoid undisciplined annotations the results of a previous controlled experiment indicated that the discipline of annotations has no influence on program comprehension and maintenance to better understand whether developers care about the discipline of preprocessor based annotations and whether they can really influence on maintenance tasks in this paper we conduct a mixed method research involving two studies in the first one we identify undisciplined annotations in 110 open source c c systems of different domains sizes and popularity github metrics we then refactor the identified undisciplined annotations to make them disciplined right away we submit pull requests with our code changes our results show that almost two thirds of our pull requests have been accepted and are now merged in the second study we conduct a controlled experiment we have several differences with respect to the aforementioned one such as blocking of cofounding effects and more replicas we have evidences that maintaining undisciplined annotations is more time consuming and error prone representing a different result when compared to the previous experiment overall we conclude that undisciplined annotations should not be neglected arcan a tool for architectural smells detection 2017 ieee code smells are sub optimal coding circumstances such as blob classes or spaghetti code they have received much attention and tooling in recent software engineering research higher up in the abstraction level architectural smells are problems or sub optimal architectural patterns or other design level characteristics these have received significantly less attention even though they are usually considered more critical than code smells and harder to detect remove and refactor this paper describes an open source tool called arcan developed for the detection of architectural smells through an evaluation of several different architecture dependency issues the detection techniques inside arcan exploit graph database technology allowing for high scalability in smells detection and better management of large amounts of dependencies of multiple kinds in the scope of this paper we focus on the evaluation of arcan results carried out with real life software developers to check if the architectural smells detected by arcan are really perceived as problems and to get an overall usefulness evaluation of the tool architectural smells dependency graph graph database software architecture intero an interoperability model for large systems ieee interoperability is one of the key challenges in present and future software intensive systems that are large distributed and increasingly built as integration of existing and third parties components or systems of legacy parts and of newly developed parts moreover such systems evolve over time due to different reasons e g features are added changed or removed new protocols are supported standards are changed refactoring to help large companies identifying how to manage and improve interoperability among their evolving software systems our objective is to develop an interoperability model for large systems by focusing on software development our method to conceive and evaluate the model is through a tight collaboration among two universities and five large international companies the results of our work are the intero model and the intero evaluation framework they permit to analyse the specific interoperability problem to conceive strategies to enhance interoperability and finally to re evaluate the problem in order to understand whether there is an improvement in terms of software interoperability companies conferences d software software engineering d 2 software engineering d 2 12 interoperability d 2 2 design tools and techniques h information technology and systems h 1 models and principles interoperability object recognition protocols software standards specifying and identifying widely used crosscutting concerns 2017 elsevier b v to ensure quality of code in large software systems refactoring operations are the norm with this goal in mind it is helpful to direct preventive maintenance of large object oriented legacy systems towards the more advanced aspect oriented paradigm however manually identifying crosscutting concerns candidate to be rendered as aspects in large legacy systems can be an overwhelming task we propose an approach and provide a tool to identify crosscutting concerns embedded in an object oriented system our approach analyses the implementation of classes and their relationships and looks for specific user defined schemata we discuss how to build schemata and provide some general ones devised in accordance with current aspect oriented programming practices compared to existing approaches our solution is flexible and achieves higher precision in detecting crosscutting concerns moreover it provides the developer with an accurate identification of snippets of code which can be removed from classes and embedded into aspects the proposed solution has been validated by applying it to a case study i e a large extant software system suitably selected to assess the quality attained by the aspect oriented version produced with the assistance of our tool in comparison with a design performed by expert human developers aspect mining design patterns graph pattern matching refactoring investigating the effect of aspect oriented refactoring on the unit testing effort of classes an empirical evaluation 2017 world scientific publishing company this paper aims at investigating empirically the effect of aspect oriented ao refactoring on the unit testability of classes in object oriented software the unit testability of classes has been addressed from the perspective of the unit testing effort and particularly from the perspective of the unit test cases tcs construction we investigated in fact different research questions 1 the impact of ao refactoring on source code attributes size complexity coupling cohesion and inheritance attributes that are mostly related to the unit testability of classes 2 the impact of ao refactoring on unit test code attributes size assertions invocations and data creation attributes that are indicators of the effort involved to write the code of unit tcs and 3 the relationships between the variations observed after ao refactoring in both source code and unit test code attributes we used in the study different techniques correlation analysis statistical tests and linear regression we performed an empirical evaluation using data collected from three well known open source java software systems jhotdraw hsqlbd and petstore that have been refactored using ao programming aspectj results suggest that 1 overall the effort involved in the construction of unit tcs of refactored classes has been reduced 2 the variations of source code attributes have more impact on methods invocation between unit tcs and finally 3 the variations of unit test code attributes are more in uenced by the variation of the complexity of refactored classes compared to the other class attributes aspect oriented refactoring metrics source code attributes unit test case construction unit test code attributes unit testing effort estimation of torques transmitted by twin clutch of dry dual clutch transmission during vehicle s launching process 1967 2012 ieee the key to the launching control of a dual clutch transmission dct lies in the coordination control of the engine and dual clutches along with the accurate closed loop control of the torque transmitted by each clutch and the output torque of the engine the implementation feasibility and precision of the clutch torque closed loop control are completely dependent on the effective real time estimation of the clutch torque which cannot be directly measured therefore the high order sliding mode observer and unknown input observer are used to estimate the transmitted torque of the twin clutches on the basis of the self designed control strategy and estimation of the vehicle drag torque first for the launching clutch slipping phase an improved engine constant speed control is proposed based on the dynamic equations of a dry dct with dual intermediate shafts and the minimum value principle is applied to achieve the optimum launching control of the clutches meanwhile the separating conditions of the separated clutch and the torque distribution are determined to ensure approximate friction work and avoid power cycle and the target curve of the clutch transmitted torque is obtained according to different conditions then the vehicle drag torque is estimated using the recursive least square method with a double forgetting factor the angular acceleration of the engine and output shaft is refactored utilizing a high order sliding mode observer algorithm and the transmitted torque of the twin clutches are estimated using the unknown input observer then the dct launching process is simulated under different driving conditions on the matlab simulink software platform finally the bench test is conducted to verify the effectiveness of the self designed clutch torque estimation method the simulation and hardware in the loop hil test results show that the proposed methods of high order sliding mode observer and unknown input observer can effectively estimate the clutch transmitted torque and lay a solid foundation for the subsequent development of the launching control strategy for a real vehicle with a dct dual clutch starting coordinated control recursive least squares method six speed dry dual clutch transmission dct sliding mode observer str2rts refactored streamit benchmarks into statically analyzable parallel benchmarks for wcet estimation amp real time scheduling benjamin rouxel and isabelle puaut licensed under creative commons license cc by we all had quite a time to find non proprietary architecture independent exploitable parallel benchmarks for worst case execution time wcet estimation and real time scheduling however there is no consensus on a parallel benchmark suite when compared to the single core era and the mälardalen benchmark suite 11 this document bridges part of this gap by presenting a collection of benchmarks with the following good properties i easily analyzable by static wcet estimation tools written in structured c language in particular neither goto nor dynamic memory allocation containing flow information such as loop bounds ii independent from any particular run time system mpi openmp or real time operating system each benchmark is composed of the c source code of its tasks and an xml description describing the structure of the application tasks and amount of data exchanged between them when applicable each benchmark can be integrated in a full end to end empirical method validation protocol on multi core architecture this proposed collection of benchmarks is derived from the well known streamit 21 benchmark suite and will be integrated in the taclebench suite 10 in a near future all these benchmarks are available at https gitlab inria fr brouxel str2rts parallel benchmarks tasks scheduling worst case execution time estimation agos a plug and play method for the assembly of artificial gene operons into functional biosynthetic gene clusters 2017 american chemical society the generation of novel secondary metabolites by reengineering or refactoring biochemical pathways is a rewarding but also challenging goal of synthetic biology for this the development of tools for the reconstruction of secondary metabolite gene clusters as well as the challenge of understanding the obstacles in this process is of great interest the artificial gene operon assembly system agos is a plug and play method developed as a tool to consecutively assemble artificial gene operons into a destination vector and subsequently express them under the control of a de repressed promoter in a streptomyces host strain agos was designed as a set of entry plasmids for the construction of artificial gene operons and a supercos1 based destination vector into which the constructed operons can be assembled by red et mediated recombination to provide a proof of concept of this method we disassembled the well known novobiocin biosynthetic gene cluster into four gene operons encoding for the different moieties of novobiocin we then genetically reorganized these gene operons with the help of agos to finally obtain the complete novobiocin gene cluster again the production of novobiocin precursors and of novobiocin could successfully be detected by lc ms and lc ms ms furthermore we demonstrated that the omission of terminator sequences only had a minor impact on product formation in our system biosynthetic gene clusters dna assembly heterologous expression refactoring streptomyces a social network graphics segmentation algorithm based on community detection 2016 ieee today people use multiple online social networks if we can identify all the accounts which belong to the same individual across different online social networks we will get a richer understanding of social dynamics and apply it to a number of practical applications fortunately some researchers have got some satisfactory achievements many related algorithms need to be calculated the score of a pair of nodes which will take much time but some of those calculations may be redundant in this paper we come across a problem that reduces redundant calculations the graphics segmentation methods give us some enlightenment to solve the problem we can reduce redundant calculation by cutting social network graph to some small subgraphs then how to cut appears to be a challenge that how to cut considering the characteristics of the social network community we will utilize the community segmentation algorithm to split large social networks and refactor subgraphs our experiments indicate that our algorithm takes 70 time of original algorithm community detection graphics segmentation social network graph subgraph object oriented code metric based refactoring opportunities identification approaches analysis 2016 ieee this paper presents analysis of existing empirical studies of software metric based refactorings opportunities identification roi for object oriented oo software systems we carried out a comprehensive analysis on sixteen 16 primary studies to identify the state of the practice in roi focusing on their operations refactoring activities programming languages and the impact on software quality the analysis results show that roi approaches were designed for either a single refactoring activity or couple of them additionally move method and extract class refactoring were the most refactorings activities performed on oo software systems also oo metrics played an indispensable role in both opportunity detection and refactoring decisions with the obtained results we recommend the development of a generic roi approach that is capable of identifying opportunities for all refactoring activities as well as suggesting the appropriate refactoring operations to apply code identification object oriented refactoring software metrics engineering the performance of a meta modeling architecture 2017 acm the reflection architectural pattern is an elegant reusable solution to design software applications based on a metamodel that provides a self representation of the types used in the domain model this provides significant benefits in terms of adaptability maintainability self awareness and direct involvement of domain experts in the configuration stage however while virtuous in the perspective of object oriented development the meta model adds a level of indirection that may result in poor performance the complexity is further exacerbated when the object oriented domain model is mapped to a relational database we identify four performance anti patterns that may naturally occur in the design of a meta modeling architecture and for each of them we propose a refactoring intervention on the object model and on the database mapping strategy experimental results are reported to characterize the gain obtained applying the proposed refactoring techniques to a real case of data management system in order to provide a roadmap for engineering the performance of meta modeling architectures anti patterns dynamic architectures electronic health record ehr systems mapping meta modeling architecture performance reflection pattern relational database comparison of different cell type correction methods for genome scale epigenetics studies 2017 the author s background whole blood is frequently utilized in genome wide association studies of dna methylation patterns in relation to environmental exposures or clinical outcomes these associations can be confounded by cellular heterogeneity algorithms have been developed to measure or adjust for this heterogeneity and some have been compared in the literature however with new methods available it is unknown whether the findings will be consistent if not which method s perform better results methods we compared eight cell type correction methods including the method in the minfi r package the method by houseman et al the removing unwanted variation ruv approach the methods in fast lmm ewasher refactor reffreeewas and reffreecellmix r programs along with one approach utilizing surrogate variables svas we first evaluated the association of dna methylation at each cpg across the whole genome with prenatal arsenic exposure levels and with cancer status adjusted for estimated cell type information obtained from different methods we then compared cpgs showing statistical significance from different approaches for the methods implemented in minfi and proposed by houseman et al we utilized homogeneous data with composition of some blood cells available and compared them with the estimated cell compositions finally for methods not explicitly estimating cell compositions we evaluated their performance using simulated dna methylation data with a set of latent variables representing cell types results results from the sva based method overall showed the highest agreement with all other methods except for fast lmm ewasher using homogeneous data minfi provided better estimations on cell types compared to the originally proposed method by houseman et al further simulation studies on methods free of reference data revealed that sva provided good sensitivities and specificities reffreecellmix in general produced high sensitivities but specificities tended to be low when confounding is present and fast lmm ewasher gave the lowest sensitivity but highest specificity conclusions results from real data and simulations indicated that sva is recommended when the focus is on the identification of informative cpgs when appropriate reference data are available the method implemented in the minfi package is recommended however if no such reference data are available or if the focus is not on estimating cell proportions the sva method is suggested cell type composition cpg sites genome scale dna methylation surrogate variables a robust multi objective approach to balance severity and importance of refactoring opportunities 2016 springer science business media new york refactoring large systems involves several sources of uncertainty related to the severity levels of code smells to be corrected and the importance of the classes in which the smells are located both severity and importance of identified refactoring opportunities e g code smells are difficult to estimate in fact due to the dynamic nature of software development these values cannot be accurately determined in practice leading to refactoring sequences that lack robustness in addition some code fragments can contain severe quality issues but they are not playing an important role in the system to address this problem we introduced a multi objective robust model based on nsga ii for the software refactoring problem that tries to find the best trade off between three objectives to maximize quality improvements severity and importance of refactoring opportunities to be fixed we evaluated our approach using 8 open source systems and one industrial project and demonstrated that it is significantly better than state of the art refactoring approaches in terms of robustness in all the experiments based on a variety of real world scenarios our suggested refactoring solutions were found to be comparable in terms of quality to those suggested by existing approaches better prioritization of refactoring opportunities and to carry an acceptable robustness price refactoring under uncertainty robust multi objective optimization search based software engineering software quality search based detection of model level changes 2016 springer science business media new york software models defined as code abstractions are iteratively refined restructured and evolved due to many reasons such as reflecting changes in requirements or modifying a design to enhance existing features for understanding the evolution of a model a posteriori change detection approaches have been proposed for models the majority of existing approaches are successful to detect atomic changes however composite changes such as refactorings are difficult to detect due to several possible combinations of atomic changes or eventually hidden changes in intermediate model versions that may be no longer available moreover a multitude of refactoring sequences may be used to describe the same model evolution in this paper we propose a multi objective approach to detect model changes as a sequence of refactorings our approach takes as input an exhaustive list of possible types of model refactoring operations the initial model and the revised model and generates as output a list of refactoring applications representing a good compromise between the following two objectives i maximize the similarity between the expected revised model and the generated model after applying the refactoring sequence on the initial model and ii minimize the number of atomic changes used to describe the evolution in fact minimizing the number of atomic changes can important since it is maybe easier for a designer to understand and analyze a sequence of refactorings composite model changes rather than an equivalent large list of atomic changes weissgerber and diehl 2006 due to the huge number of possible refactoring sequences a metaheuristic search method is used to explore the space of possible solutions to this end we use the non dominated sorting genetic algorithm nsga ii to find the best trade off between our two objectives the paper reports on the results of an empirical study of our multi objective model changes detection technique as applied on various versions of real world models taken from open source projects and one industrial project we compared our approach to the simple deterministic greedy algori thm multi objective particle swarm optimization mopso an existing mono objective changes detection approach and two model changes detection tools not based on computational search the statistical test results provide evidence to support the claim that our proposal enables the generation of changes detection solutions with correctness higher than 85 in average using a variety of real world scenarios model changes detection multi objective optimization search based software engineering software maintenance recommendation of move method refactorings using coupling cohesion and contextual similarity 2017 ieee method placement is one of the most important design activities in any object oriented application recommendation of move method refactorings plays a significant role through grouping similar behavior of methods it is also used as a refactoring technique of feature envy code smell by placing methods into correct classes from the incorrect ones due to this code smell an application will be tightly coupled and loosely cohesive which reflect poor design and hence development and maintenance effort time and cost will be increased existing techniques mostly used only non static methods for refactoring the code smell and so these approaches are not generalized for all types of methods static and non static this paper proposes a novel approach for recommending move method refactorings to remove the code smell for both types of methods based on coupling cohesion and context the results of a preliminary empirical evaluation indicate that the proposed approach provides better results than jdeodorant a popular eclipse plugin for refactorings code smell cohesion contextual similarity coupling move method refactoring c jrefrec change based identification of move method refactoring opportunities 2017 ieee we propose in this paper a lightweight refactoring recommendation tool namely c jrefrec to identify move method refactoring opportunities based on four heuristics using static and semantic program analysis our tool aims at identiying refactoring opportunities before a code change is committed to the codebase based on current code changes whenever the developer saves compiles his code we evaluate the efficiency of our approach in detecting feature envy smells and recommending move method refactorings to fix them on three java open source systems and 30 code changes results show that our approach achieves an average precision of 0 48 and 0 73 of recall and outperforms a state of the art approach namely jdeodorant investigating the energy impact of android smells 2017 ieee android code smells are bad implementation practices within android applications or apps that may lead to poor software quality these code smells are known to degrade the performance of apps and to have an impact on energy consumption however few studies have assessed the positive impact on energy consumption when correcting code smells in this paper we therefore propose a tooled and reproducible approach called hot pepper to automatically correct code smells and evaluate their impact on energy consumption currently hot pepper is able to automatically correct three types of android specific code smells internal getter setter member ignoring method and hashmap usage hot pepper derives four versions of the apps by correcting each detected smell independently and all of them at once hot pepper is able to report on the energy consumption of each app version with a single user scenario test our empirical study on five open source android apps shows that correcting the three aforementioned android code smells effectively and significantly reduces the energy consumption of apps in particular we observed a global reduction in energy consumption by 4 83 in one app when the three code smells are corrected we also take advantage of the flexibility of hot pepper to investigate the impact of three picture smells bad picture format compression and bitmap format in sample apps we observed that the usage of optimised jpg pictures with the android default bitmap format is the most energy efficient combination in android apps we believe that developers can benefit from our approach and results to guide their refactoring and thus improve the energy consumption of their mobile apps android code smells energy consumption picture iwsc 2017 11th ieee international workshop on software clones co located with saner 2017 the proceedings contain 12 papers the topics discussed include detecting and analyzing code clones in hdl using compilation decompilation to enhance clone detection rearranging the order of program statements for code clone detection web service for finding cloned files using b bit minwise hashing codeease harnessing method clone structures for reuse software clones in scratch projects on the presence of copy and paste in computational thinking learning does cloned code increase maintenance effort refactoring patterns study in code clones during software evolution evolution of code clone ratios throughout development history of open source c and c programs a technique to detect multi grained code clones enhancing program dependency graph based clone detection using approximate subgraph matching and rethinking dependence clones the combination of an autoencoder network and single pass clustering for detection and tracking 2017 editorial board of journal of beijing university of chemical technology natural science edition all right reserved the traditional single pass clustering algorithm has some deficiencies such as having relatively low accuracy and requiring complex calculations therefore a detection and tracking method based on the combination of an autoencoder network and single pass clustering is proposed in this paper the original data is refactored by training a neural network with multiple hidden layers which can better extract the data features by virtue of establishing a better weighting factor and setting up edge articles the false detection rate is reduced and the effect of clustering is improved in addition the new method overcomes negative effects of the data sequence the experimental results show that the algorithm is more efficient than the traditional single pass algorithm autoencoder network single pass clustering topic detection investigating code quality tools in the context of software engineering education 2017 wiley periodicals inc a key issue involved with software engineering education consists of how to guarantee that adequate software engineering principles are being followed at the code level thus reinforcing that students produce high quality code reviewing and grading student projects to verify whether they followed such principles is a time consuming task since this typically involves manual code inspection in this paper we exploit code quality tools and metrics to automatically assess student projects with respect to methods with many responsibilities i e where the extract method refactoring should be applied and evaluate their effectiveness we conducted a study using two sets of student projects developed in two academic semesters our results indicate that to reduce the effort required to grade projects two traditional code metrics namely method lines of code and number of statements perform best and other metrics can be selected according to the system being implemented 2016 wiley periodicals inc comput appl eng educ 25 230–241 2017 view this article online at wileyonlinelibrary com journal cae doi 10 1002 cae 21793 code quality tools object oriented programming software engineering education a systematic review on search based refactoring 2016 context to find the best sequence of refactorings to be applied in a software artifact is an optimization problem that can be solved using search techniques in the field called search based refactoring sbr over the last years the field has gained importance and many sbr approaches have appeared arousing research interest objective the objective of this paper is to provide an overview of existing sbr approaches by presenting their common characteristics and to identify trends and research opportunities method a systematic review was conducted following a plan that includes the definition of research questions selection criteria a search string and selection of search engines 71 primary studies were selected published in the last sixteen years they were classified considering dimensions related to the main sbr elements such as addressed artifacts encoding search technique used metrics available tools and conducted evaluation results some results show that code is the most addressed artifact and evolutionary algorithms are the most employed search technique furthermore most times the generated solution is a sequence of refactorings in this respect the refactorings considered are usually the ones of the fowler s catalog some trends and opportunities for future research include the use of models as artifacts the use of many objectives the study of the bad smells effect and the use of hyper heuristics conclusions we have found many sbr approaches most of them published recently the approaches are presented analyzed and grouped following a classification scheme the paper contributes to the sbr field as we identify a range of possibilities that serve as a basis to motivate future researches evolutionary algorithms refactoring search based software engineering discovery of a phosphonoacetic acid derived natural product by pathway refactoring 2017 american chemical society the activation of silent natural product gene clusters is a synthetic biology problem of great interest as the rate at which gene clusters are identified outpaces the discovery rate of new molecules this unknown chemical space is rapidly growing as too are the rewards for developing technologies to exploit it one class of natural products that has been underrepresented is phosphonic acids which have important medical and agricultural uses hundreds of phosphonic acid biosynthetic gene clusters have been identified encoding for unknown molecules although methods exist to elicit secondary metabolite gene clusters in native hosts they require the strain to be amenable to genetic manipulation one method to circumvent this is pathway refactoring which we implemented in an effort to discover new phosphonic acids from a gene cluster from streptomyces sp strain nrrl f 525 by reengineering this cluster for expression in the production host streptomyces lividans utility of refactoring is demonstrated with the isolation of a novel phosphonic acid o phosphonoacetic acid serine and the characterization of its biosynthesis in addition a new biosynthetic branch point is identified with a phosphonoacetaldehyde dehydrogenase which was used to identify additional phosphonic acid gene clusters that share phosphonoacetic acid as an intermediate natural products pathway refactoring phosphonic acids phosphonoacetic acid a qualitative approach for refactoring of code clone opportunities using graph and tree methods 2016 ieee reusing of code has been a very common practice in software development this practice has been implemented to reduce programming time and efforts greatly this copying and pasting behavior of programmers leads to cloning of codes and therefore has a very serious impact on the maintenance of the software systems many clone detection tool has been proposed to find out the copied code however refactoring of code is still a challenging part as most of the ongoing tools depend on detection of clone rather than the ability to make decision on refactorability these tools do not guarantee whether such codes can be safely refactored or not our aim mainly lies on detecting the possibility of refactoring a code to find out whether the code clone can be securely refactored or not three methods are applied nesting structure mapping statement mapping and precondition examination in order to refactor the code we apply some techniques like pull up method and push down method in our approach we have tried to find the refactorable code using the methods and also refactored the code so as to remove the problem of code cloning clone detection code clones nesting structure mapping precondition examination refactoring statement mapping automated refactoring of super class method invocations to the template method design pattern 2016 elsevier b v context implementation inheritance i e overriding of concrete method implementations through subtyping is prone to potential class contract violations call super is a code pattern that employs implementation inheritance for extending a method s behaviour in call super the overriding method includes in its body an invocation to the overridden method template method is a design pattern that enables extensions to a multi step procedure without overriding its concrete implementation instead subclasses provide different variants of the template method s behaviour through implementation of abstract method definitions interface inheritance objective this work studies the automated refactoring of call super to template method contributing thus to replacement of implementation inheritance with interface inheritance method we introduce an algorithm for the discovery of refactoring candidates that is based on an extensive set of refactoring preconditions moreover we specify the source code transformation for refactoring a call super instance to template method an implementation of the proposed approach is evaluated on a set of open source java projects results the evaluation results highlight a the frequent occurrence of the call super pattern among method overridings b the potential provided by our method for discovery and elimination of several non trivial call super instances and c the resulting code improvement as reflected by the specialization index metric and the alignment of refactored code with the programmer s intent the application of all refactorings identified on a set of benchmark projects and the successful execution of their test suites provide empirical evidence on the soundness of the refactoring procedure runtime performance results support the scalability of the proposed method conclusion the proposed method automates the replacement of implementation inheritance with interface inheritance through refactoring call super instances to template method the empirical evaluation of the method supports its applicability soundness and runtime efficiency call super implementation inheritance interface inheritance refactoring template method design pattern identification of extract method refactoring opportunities through analysis of variable declarations and uses 2017 world scientific publishing company software development is a continuous process that usually starts with analyzing the system requirements and proceeds with design implementation testing and maintenance regardless of how good an initial design was achieved quality of source code tends to decay throughout the development process as software evolves one of the main contributing factors to this degradation of initial quality can be considered as maintenance operations for instance to enhance performance or other attributes of the system or to fix newly discovered bugs for such large software systems development process also requires reusing existing components which may have been implemented by others hence a comprehensible piece of source code e g one that conveys its message about what it is trying to do easily with understandable and modular implementation significantly reduces time and effort not only for the implementation phase of the development lifecycle but also for testing and maintenance phases in other words while software decay is inevitable software comprehension plays a determining role in the total cost and effectiveness of both implementation phase and maintenance phase therefore developers should strive to create software components with modular structure and clearer implementation to reduce the development cost in this paper we are interested in finding ways to successfully decompose long methods those with poor initial implementation and or decayed overtime into smaller more comprehensible and readable ones this decomposition process is known as extract method refactoring and helps to reduce the overall cost of development most of the existing refactoring tools require users to select the code fragments that need to be extracted we introduce a novel technique for this refactoring this technique seeks refactoring opportunities based on variable declarations and uses confining fully extractable code regions without any user intervention we implemented this technique as an analysis and visualization tool to help a user identify candidate code fragments to be extracted as separate methods with this automation tool developers do not have to manually inspect a foreign code base to select code fragments for refactoring through the visual representations we provide one can observe all suggested refactoring effectively on large scale software systems and decide whether a particular refactoring should be applied to show the effectiveness of our techniques we also provide some case studies conducted using this tool and technique both on our own project s source code and other open source projects extract method hammock graph refactoring software visualization tree map mid spatial frequency error identification of precision optical surface based on the adaptive dt cwt method 2017 editorial department of jvmd all right reserved this paper proposes an adaptive separation method based on dual tree complex wavelet transform dt cwt according to the polished spherical precision optics surface characteristics dt cwt exhibited shift invariance superiority directional selectivity and limited redundancy and we intensified its distinguishing ability by introducing the adaptive impact factor during refactoring finally we separated various surface components of the measured polishing optical surfaces effectively and characterized their parameters experiments showed that the dt cwt adaptive separation method was more effective in separation and more convenient for subsequent identification and assessment work compared with the dt cwt direct separation method adaptive separation dual tree complex wavelet transform optical components parametric characterization surface error validating requirement satisfaction through software tracking matrix model 2017 international information institute in this current time software is rapidly developed to release at time to market which is so critical to control the quality of the software in our industrial fields software developers still work on software maintenance without any design documentation and code visualization 1 thus the need of software visualization based on reverse engineering has emerged in previous papers we mentioned a procedural method for software visualization and quality improvement 2 3 and 4 but this method is difficult to validate requirement satisfaction through tracing the customer requirements we propose a requirement tracking model for requirement s verification which can visualize the actual object oriented code based on a sw visualization and improve software quality through manually refactoring based on inner structure of the visualized code the improved result can be verified through software requirement tracking model we can also check how much to achieve between the quality improvements and the customer requirement satisfaction requirement validation software quality software visualization tracking matrix model investigating the effect of design patterns on energy consumption copyright 2017 john wiley sons ltd gang of four gof patterns are well known best practices for the design of object oriented systems in this paper we aim at empirically assessing their relationship to energy consumption ie a performance indicator that has recently attracted the attention of both researchers and practitioners to achieve this goal we investigate pattern participating methods ie those that play a role within the pattern and compare their energy consumption to the consumption of functionally equivalent alternative nonpattern solutions we obtained the alternative solution by refactoring the pattern instances using well known transformations eg replace polymorphism with conditional statements the comparison is performed on 169 methods of 2 gof patterns namely state strategy and template method retrieved from 2 well known open source projects the results suggest that for the majority of cases the alternative design excels in terms of energy consumption however in some cases eg when the method is large in size or invokes many methods the pattern solution presents similar or lower energy consumption the outcome of our study can be useful to both researchers and practitioners because we 1 provide evidence on a possible negative effect of gof patterns and 2 can provide guidance on which cases the use of the pattern is not hurting energy consumption design patterns energy efficiency gof patterns state pattern strategy pattern template method pattern an empirical study of supplementary patches in open source projects 2016 springer science business media new york developers occasionally make more than one patch to fix a bug the related patches sometimes are intentionally separated but unintended omission errors require supplementary patches several change recommendation systems have been suggested based on clone analysis structural dependency and historical change coupling in order to reduce or prevent incomplete patches however very few studies have examined the reason that incomplete patches occur and how real world omission errors could be reduced this paper systematically studies a group of bugs that were fixed more than once in open source projects in order to understand the characteristics of incomplete patches our study on eclipse jdt core eclipse swt mozilla and equinox p2 showed that a significant portion of the resolved bugs require more than one attempt to fix compared to single fix bugs the multi fix bugs did not have a lower quality of bug reports but more attribute changes i e cc ed developers or title were made to the multi fix bugs than to the single fix bugs multi fix bugs are more likely to have high severity levels than single fix bugs hence more developers have participated in discussions about multi fix bugs compared to single fix bugs multi fix bugs take more time to resolve than single fix bugs do incomplete patches are longer and more scattered and they are related to more files than regular patches are our manual inspection showed that the causes of incomplete patches were diverse including missed porting updates incorrect handling of conditional statements and incomplete refactoring our investigation showed that only 7 to 17 of supplementary patches had content similar to their initial patches which implies that supplementary patch locations cannot be predicted by code clone analysis alone furthermore 16 to 46 of supplementary patches were beyond the scope of the immediate structural dependency of their initial patch locations historical co change patterns also showed low precision in predicting supplementary patch locations code clones structural dependencies and historical co change analyses predicted different supplementary patch locations and there was little overlap between them combining these analyses did not cover all supplementary patch locations the present study investigates the characteristics of incomplete patches and multi fix bugs which have not been systematically examined in previous research we reveal that predicting supplementary patch is a difficult problem that existing change recommendation approaches could not cover new type of approaches should be developed and validated on a supplementary patch data set which developers failed to make the complete patches at once in practice bug fixes empirical study patches software evolution analyzing the concept of technical debt in the context of agile software development a systematic literature review 2016 elsevier b v context technical debt td is a metaphor that is used to communicate the consequences of poor software development practices to non technical stakeholders in recent years it has gained significant attention in agile software development asd objective the purpose of this study is to analyze and synthesize the state of the art of td and its causes consequences and management strategies in the context of asd research method using a systematic literature review slr 38 primary studies out of 346 studies were identified and analyzed results we found five research areas of interest related to the literature of td in asd among those areas managing td in asd received the highest attention followed by architecture in asd and its relationship with td in addition eight categories regarding the causes and five categories regarding the consequences of incurring td in asd were identified focus on quick delivery and architectural and design issues were the most popular causes of incurring td in asd reduced productivity system degradation and increased maintenance cost were identified as significant consequences of incurring td in asd additionally we found 12 strategies for managing td in the context of asd out of which refactoring and enhancing the visibility of td were the most significant conclusion the results of this study provide a structured synthesis of td and its management in the context of asd as well as potential research areas for further investigation agile software development systematic literature review technical debt technical debt management automatic detection of bad smells from excel sheets and refactor for performance improvement 2016 ieee this paper presents the prevailing analysis as well as some of experimental findings analogous to the factual study of so called bad smells an anatomy is presented which categorize bad smells given by fowler in context of object oriented programming many research papers have been published quantifying the effect of code smells on maintenance efforts notion of bad smells can be applied to multiple areas other than software this paper intends to give a review to look for bad smells in the context of spreadsheets many authors in past years have worked on spreadsheet bad smells here in this paper a systematic review is proposed demonstrating list of bad smells for spreadsheets and related work issued in past in field of spreadsheet bad smells bad smells complexity inter worksheet smells refactoring restructuring evolving requirements to code trace links across versions of a software system 2016 ieee trace links provide critical support for numerous software engineering activities including safety analysis compliance verification test case selection and impact prediction however as the system evolves over time there is a tendency for the quality of trace links to degrade into a tangle of inaccurate and untrusted links this is especially true with the links between source code and upstream artifacts such as requirements because developers frequently refactor and change code without updating the links we present tle trace link evolver a solution for automating the evolution of trace links as changes are introduced to source code we use a set of heuristics open source tools and information retrieval methods to detect common change scenarios across different versions of software each change scenario is then associated with a set of link evolution heuristics which are used to evolve trace links we evaluate our approach through a controlled experiment and also through applying it across 27 releases of the cassandra database system results show that the trace links evolved using our approach are significantly more accurate than those generated using information retrieval alone evolution maintenance traceability achieving better requirements to code traceability which refactoring should be done first 2016 ieee during system evolution trace links among requirements and source code could get distorted due to vocabulary mismatch problem nevertheless researchers have shown that those links can be recovered by code refactoring moreover it is shown that refactoring methods like rename identifier has positive impact in supporting traceability this leads to the question that will other refactoring methods will have same impact on traceability if yes then which refactoring technique should be applied first for this investigation we used four refactoring techniques introducing parameter object pull up field inline class and decompose conditional the methods were applied on two different code bases namely itrust and etour the traceability links were generated by an automated tool named traceme from the experiment we observed that introducing parameter object improves requirements to code traceability inline class and decompose conditional show a little but positive influence pull up method shows no improvements in traceability we conclude that introducing parameter object should have high priority to achieve better traceability refactoring requirement to code traceability requirement traceability vocabulary mismatch problem refactoring object oriented applications towards a better decoupling and instantiation unanticipation modularity in object oriented oo applications has been a major concern since the early years of oo programming languages migrating existing oo applications to component based cb ones can contribute to improve modularity and therefore maintainability and reuse in this paper we propose a method for source code transformation refactoring in order to perform this migration this method enhances decoupling by considering that some dependencies between classes should be set through abstract types interfaces like in cb applications in addition some anticipated instantiations of these classes buried in the source code are extracted and replaced by declarative statements like connectors in cb applications which are processed by a dependency injection mechanism for doing so a set of bad smells i e modularity violating symptoms has been defined these are first detected in the source code then some refactoring operations are applied for their elimination an implementation of the method was successfully experimented on a set of open source java projects the results of this experimentation are reported in this paper decision structure based object oriented design principles 2017 eszterhazy karoly college all rights reserved the major part of program complexity is based on the logic of conditions but the existing refactoring methods do not detail the options of decision merging according to the cases of decision redundancies which are the main options of optimizing the decision structures by refactoring to extinguish decision redundancies in the source code we have an option to merge decisions which can be interpreted as refactoring tools by which the quality of code structures can be optimized i intend to complete the definitions of decision decision raising and introduce a novel concept decision merging based on the concept of behavioural contract according to the decision merging cases new design principles can be created the principle using inheritance to dissolve decision redundancy identifies the cases when the usage of inheritance as an object oriented tool is more reasonable than object composition the other new principle is avoid decision redundancy by which decision redundancies can be eliminated based on the decision merging rules i initiate new object oriented metrics as well giving the opportunity to determine the degree of decision redundancies in the software the properties of these metrics are analysed empirically decision merging decision raising decision redundancy design principles inheritance metrics learning to rank extract method refactoring suggestions for long methods springer international publishing ag 2017 extract method refactoring is a common way to shorten long methods in software development it improves code readability reduces complexity and is one of the most frequently used refactorings nevertheless sometimes developers refrain from applying it because identifying an appropriate set of statements that can be extracted into a new method is error prone and time consuming in a previous work we presented a method that could be used to automatically derive extract method refactoring suggestions for long java methods that generated useful suggestions for developers the approach relies on a scoring function that ranks all valid refactoring possibilities that is all candidates to identify suitable candidates for an extract method refactoring that could be suggested to developers even though the evaluation has shown that the suggestions are useful for developers there is a lack of understanding of the scoring function in this paper we present research on the single scoring features and their importance for the ranking capability in addition we evaluate the ranking capability of the suggested scoring function and derive a better and less complex one using learning to rank techniques extract method refactoring learning to rank long method refactoring suggestion evares a quality driven refactoring method for business process models copyright 2017 by scitepress science and technology publications lda the business performance of an enterprise tightly depends on the quality of its business process model bpm this dependence prompted several propositions to improve quality sub characteristics e g modifiability and reusability of a bpm through transformation operations to change the internal structure of the model while preserving its external behaviour each transformation may improve certain metrics related to one quality sub characteristic while degrading others consequently one challenge of this model transformation based quality improvement approach is how to identify the application order of the transformations to derive the best quality model this paper proposes a local optimization based heuristic method to decide on the application order of the transformations to produce the best quality bpm the method is guided by both the perspectives and the impact of each transformation on the quality metrics pertinent to the perspectives as well as the quality sub characteristics of interest to the designer the method s and an experimental evaluation are presented bpmn models perspectives quality metrics quality sub characteristics transformation rules ordering investigating the effectiveness of greedy algorithm on open source software systems for determining refactoring sequence copyright 2017 for this paper by its authors the deeper problem in the source code are the bad smells that indicates something is wrong and if they are not detected timely then they lead towards the complete deterioration of the working software causing major financial and productivity loss refactoring helps in removing these bad smells by improving internal quality attributes of the software without affecting its external behaviour however refactoring needs to be applied in a controlled manner in this study an approach has been propose for determining an optimal refactoring sequence that will maximize the source code maintainability using greedy algorithm the proposed approach selects the most optimum sequence at every step in hope of finding the global optimum solution we conduct an empirical analysis on four open source software and select those classes that have bad smells greater than or equal to four further filtration is done by selecting those classes from the group that have high value of source code lines we demonstrate the effectiveness of our approach using concrete examples of the experimental dataset and presenting summary results empirical software engineering greedy algorithm refactoring software maintainability software quality identification and refactoring of exception handling code smells in javascript avoid making bad smells is very important in writing exception handling code for dealing with unexpected runtime errors the task however is challenging and demands proficient programming skills and experience this is particularly true in developing javascript applications because javascript is very rich in features as being dynamic interpreted and object oriented with firstclass functions what further complicates the situation is the use of event driven and non blocking i o model in node js which is a runtime environment written in serverside javascript extended from our previous work on exception handling code smells in java this study aims at identifying exception handling code smells that can occur in a javascript application at either the client side or the server side the impact to software quality that each smell has is demonstrated with examples refactorings corresponding to the identified smells are proposed their effects to the application including the robustness level achieved and other benefits gained are illustrated the work is intended to serve as a guide in helping javascript developers avoid or discover exception handling code smells code smells exception handling javascript node js refactoring towards a severity and activity based assessment of code smells 2017 the authors published by elsevier b v code smells are the structural weaknesses which reside in a software system they evolve negatively over time reducing the system quality i e maintainability understandability etc therefore they should be detected and prioritized based on criticality in order to be refactored most of the existing approaches are based on severity score but little works have been done to include the information from changes history thus we introduce a harmfulness model that integrates both information severity and changes history i e code smells activity this study characterizes a god class activity based on its severity and change frequency of the jhotdraw open source system the result indicates that there are two main activities of god class that can be assessed as active and passive smells in fact an active god class can be differentiated as strong stable and ameliorate smells while a passive god class has one type called dormant besides that from severity and activity information the model can compute the harmfulness score and also indicate the degree of harmfulness level the harmfulness level may be useful to improve change likelihood estimation and refactoring candidates prioritization change likelihood code smell activity code smell impact evolution harmful code smell 16th international conference on software reuse icsr 2017 the proceedings contain 16 papers the special focus in this conference is on software reuse the topics include a developer recommendation system for open source repositories a preliminary assessment of variability implementation mechanisms in service oriented computing anomaly agglomeration as sign of product line instabilities an approach to modeling non functional properties in dynamic software product lines clustering variation points in matlab simulink models using reverse signal propagation analysis discovering software architectures with search based merge of uml model variants tracing imperfectly modular variability in software product line implementation composition of verification assets for software product lines of cyber physical systems engineering and employing reusable software components for modular verification refactoring legacy javascript code to use classes modeling non functional properties and multiple context adaptation scenarios in software product lines identification and prioritization of reuse opportunities with jreuse architecting cross platform software ecosystem applications investigating the recovery of product line architectures towards a guideline based approach to govern developers in mobile software ecosystems building safety critical systems through architecture based systematic reuse reusable use case and test case specification modeling a methodology for the semantic and structural restructuring of bpmn models 2017 emerald publishing limited purpose restructuring a business process bp model may enhance the bp performance and improve its understandability so far proposed restructuring methods use either refactoring which focuses on structural aspects social network discovery which uses semantic information to guide the affiliation process during its analysis or social network rediscovery which uses structural information to identify clusters of actors according to their relationships the purpose of this paper is to propose a hybrid method that exploits both the semantic and structural aspects of a bp model design methodology approach the proposed method first generates a social network from the bp model second it applies hierarchical clustering to determine the performers partitions this step uses the social context which specifies features related to performers and two new distances that account for semantic and structural information finally it applies a set of behavioral and organizational restructuring rules adapted from the graph optimization domain each rule uses the identified performers partitions and the business context to reduce particular quality metrics findings the efficiency of the proposed method is illustrated through well established complexity metrics the illustration is made through the development of a tool that fully supports the proposed method and proposes a strategy for the application of the restructuring rules originality value the proposed method has the merit of combining the semantic and structural aspects of a business process modeling notation model to identify restructuring operations whose ordered application reduces the complexity of the initial model bpmn model restructuring clustering metrics rules social network structural and semantic aspects refactoring carbonate reservoir architecture through real time lwd measurement 2017 society of petroleum engineers x field is a carbonate platform setting in central luconia malaysia the field faced declining trend of gas production due to early water rise seismic attribute shows that the rising water was assumed to be related to the water being drained through crossflow into the possible karst feature which may have acted as conduit located near the existing production well bore two horizontal infill wells were planned in this field with the objectives to accelerate the gas production and to investigate the uncertainty on the current gas water contact gwc movement karst feature and fracture identification in single run lwd the horizontal well placement strategies were set in different workflows as some key reservoir parameters are still uncertain several scenarios were made based on real time reservoir characterization and observation then they were translated into different production performance profiles to achieve those well objectives a new technology approach was proposed that consisted of the latest reservoir mapping while drilling technology with the capability to map the reservoir structure and fluid contact within 35m depth of investigation this was combined with the full suites of log measurement including neutron density and sonic data for secondary porosity measurement to support the real time petrophysical and well placement decision making the two horizontal infill wells were planned to stay close to the top of carbonate and to avoid the water contact as much as possible in order to optimize the gas production the second well would depend on the first well reservoir observation result on this case study the application of reservoir mapping technology while drilling has successfully demonstrated the well placement as close as 7m tvd below the reservoir roof and mapping the gas water contact at 30m tvd below the trajectory the actual gwc was detected 25m shallower than prognosed so the finding of this first well has led to the decision to eliminate the drilling of the second well which resulted in a cost saving of more than usd 20 million other than that the qualitative result from reservoir mapping tool provided a new understanding of carbonate reservoir modeling which confirmed the interpretation current gwc and reservoir heterogeneity characterization both vertically and laterally this strategy could be replicated in other carbonate reservoirs to delineate current gas water contact without physically penetrating it karst and secondary porosity interpretation were used for completion optimization and to maximize the production ceur workshop proceedings the proceedings contain 10 papers the topics discussed include pitfalls and countermeasures in software quality measurements and evaluations static and dynamic architecture conformance checking a systematic case study based analysis on tradeoffs and synergies towards a quality framework for enterprise architecture models multi level compliance measurements for software process appraisal towards the reengineering of readiness review process with r2p2 life cycle model a web application to manage and improve software development projects by semat essence investigating the effectiveness of greedy algorithm on open source software systems for determining refactoring sequence automatically identifying dead fields in test code by resolving method call and field dependency detecting technical debt through issue trackers and estimating web service quality of service parameters using source code metrics and lssvm performance optimization of a multiblock turbomachinery multidisciplinary code on heterogeneous computing systems 2017 american institute of aeronautics and astronautics inc aiaa all rights reserved hierarchical parallel computing is rapidly becoming ubiquitous in high performance computing hpc systems programming models used commonly in turbomachinery and other engineering simulation codes have traditionally relied upon distributed memory parallelism with mpi and have ignored thread and data parallelism this paper presents methods for refactoring multi block simulation codes for modern heterogenous multi core nodes and many core hpc co processors such as the intel xeon phi and nvidia cuda gpu portable and standardized methods are given to expose data and thread parallelism within the hybrid shared and distributed memory simulation system preliminary results indicate that more than 2x overall speed up is possible on each host cpu core by restructuring memory access patterns and exploiting data parallelism the speed up exceeds 4x per core on the many core co processor multi threaded parallelism is also shown to improve the strong scaling potential of multi block codes test coverage of impacted code elements for detecting refactoring faults an exploratory study 2016 elsevier inc refactoring validation by testing is critical for quality in agile development however this activity may be misleading when a test suite is insufficiently robust for revealing faults particularly refactoring faults can be tricky and difficult to detect coverage analysis is a standard practice to evaluate fault detection capability of test suites however there is usually a low correlation between coverage and fault detection in this paper we present an exploratory study on the use of coverage data of mostly impacted code elements to identify shortcomings in a test suite we consider three real open source projects and their original test suites the results show that a test suite not directly calling the refactored method and or its callers increases the chance of missing the fault additional analysis of branch coverage on test cases shows that there are higher chances of detecting a refactoring fault when branch coverage is high these results give evidence that a combination of impact analysis with branch coverage could be highly effective in detecting faults introduced by refactoring edits furthermore we propose a statistic model that evidences the correlation of coverage over certain code elements and the suite s capability of revealing refactoring faults coverage refactoring testing refactoring a cs0 course for engineering students to use active learning 2017 emerald publishing limited purpose the purpose of this paper was to determine whether applying e learning material to a course leads to consistently improved student performance design methodology approach this paper analyzes grade data from seven instances of the course the first three instances were performed traditionally after an intervention in the form of applying e learning methodologies more data were collected from four course instances these data are then analyzed and compared findings the main finding of this paper is that the application of e learning improved the overall grades and decreased the fail rates of students who took this course originality value this paper demonstrates the efficacy of applying e learning methods to an undergraduate course this paper is of special interest to educators who wish to improve and enhance their teaching active learning assessment automatic assessment course redesign e learning students teaching methods undergraduates 5th international conference on context aware systems and applications iccasa 2016 the proceedings contain 20 papers the special focus in this conference is on context aware systems and applications the topics include modelling and reasoning about context aware agents over heterogeneous knowledge sources context based project management organisational knowledge sharing using social networking sites context adaptive business networks context aware hand pose classifying algorithm based on combination of viola jones method wavelet transform pca and neural networks a load balancing game approach for vm provision cloud computing based on ant colony optimization optimizing the algorithm localization mobile robot using triangulation map enhanced human activity recognition on smartphone by using linear discrimination analysis recursive feature elimination algorithm lcd based on probability in content centric networking multivariate cube for representing multivariable data in visual analytics an approach to analyzing execution preservation in java program refactoring a new method to analyze graphical user interfaces of android applications an efficient method for time series join on subsequence correlation using longest common substring algorithm an orm based context model for context aware computing a conceptual framework for is project success notes on recognizing echinocyte by the top hat transform personalized email user action prediction based on spamassassin enhance performance of action evaluation functions with stochastic optimization algorithms and a method for mobility management in cellular networks using data mining implementation of a variable step integration technique for nonlinear structural dynamic analysis the paper presents the implementation of a recently developed unconditionally stable implicit time integration method into a production computer code for the transient response analysis of nonlinear structural dynamic systems the time integrator is packaged with two significant features a variable step size that is automatically determined and this is accomplished without additional matrix refactorizations the equations of motion solved by the time integrator must be cast in the pseudo force form and this provides the mechanism for controlling the step size step size control is accomplished by extrapolating the pseudo force to the next time the predicted pseudo force then performing the integration step and then recomputing the pseudo force based on the current solution the correct pseudo force from this data an error norm is constructed the value of which determines the step size for the next step to avoid refactoring the required matrix with each step size change a matrix scaling technique is employed which allows step sizes to change by a factor of 100 without refactoring 6 refs lessons learned from the prodebt research project on planning technical debt strategically springer international publishing ag 2017 due to cost and time constraints software quality is often neglected in the evolution and adaptation of software thus maintainability suffers maintenance costs rise and the development takes longer these effects are referred to as technical debt the challenge for project managers is to find a balance when using the given budget and schedule either by reducing technical debt or by adding technical features this balance is needed to keep time to market for current product releases short and future maintenance costs at an acceptable level method the project prodebt aimed at developing an innovative methodology and a software tool to support the strategic planning of technical debt in the context of agile software development in this project we created quality models and collected corresponding measurement data for two case studies in two different companies altogether the two case studies contributed 5–6 years of data from the end of 2011 resp mid 2012 until today using measurement and effort data we trained a machine learning model to predict productivity based on measurement data—representing the technical debt of a file at a given point in time result we developed a prototype and a prediction model for forecasting potential savings based on proposed refactorings of key drivers of technical debt identified by the model in this paper we present the approach and the experiences made during model development agile software development quality management technical debt two dimensional visualization of software metrics copyright 2017 by the paper s authors successful software systems are under continuous change bug fixing adding new features modify or extend additional code to the existing code base under these activities we must be aware of software quality avoid its degradation and alert when a major code refactoring seems to be inevitable for this purpose we must continuously collect quality related data from the software static analysis results software metrics and other statistics however data have to be analyzed and presented in a way that the architects and designers could comprehend the information in various context e g related to the number of changes on the code with the relative distribution of the issues and in connection with the complexity of the given module in this paper we show how to collect some of these key quality indicators and how to present them in a clear manner so architects and developers can overview the quality factors organized by nested components of the program in a multidimensional way this method allows programmers to reason about correctness of the architecture identify critical components and decide about necessary actions like refactoring the architecture software complexity two dimensional visualization applying design patterns to remove software performance antipatterns a preliminary approach 2017 the authors published by elsevier b v patterns and antipatterns represent powerful instruments in the hands of software designers for improving the quality of software systems a large variety of design patterns arose since decades as well as several performance antipatterns have been defined in this paper we propose a preliminary approach for antipattern based refactoring of software systems driven by design patterns application the approach is focused on refactoring software artifacts i e models code by applying design patterns with the aim of removing possible performance antipatterns occurring on such artifacts based on our approach design patterns are ranked in order to drive the refactoring choice we also provide an illustrative example as a preliminary validation of our approach showing how the ranking method works over three design patterns for removing the empty semi trucks performance antipattern and we finally identify future research directions of our work design patterns performance antipatterns software performance engineering software refactoring delaydroid an instrumented approach to reducing tail time energy of android apps 2016 science china press and springer verlag berlin heidelberg mobile devices with 3g 4g networking often waste energy in the so called tail time during which the radio is kept on even though no communication is occurring prior work has proposed policies to reduce this energy waste by batching network requests however this work is challenging to apply in practice due to a lack of mechanisms in response we have developed delaydroid a framework that allows a developer to add the needed policy to existing unmodified android applications apps with no human effort as well as no sdk os changes this allows such prior work as well as our own policies to be readily deployed and evaluated the delaydroid compile time uses static analysis and bytecode refactoring to identify method calls that send network requests and modify such calls to detour them to the delaydroid run time the run time then applies a policy to batch them avoiding the tail time energy waste delaydroid also includes a cross app communication mechanism that supports policies that optimize across multiple apps running together and we propose a policy that does so we evaluated the correctness and universality of the delaydroid mechanisms on 14 popular android apps chosen from the google app store to evaluate our proposed policy we studied three delaydroid enabled apps weather forecasting email client and news client running together finding that the delaydroid mechanisms combined with our policy can reduce 3g 4g tail time energy waste by 36 android energy network scheduling optimization refactor what do you do when you know that you don t know 2016 ieee real world biometrics recognition problems often have two unknowns the person be recognized as well as a hidden unknown missing data if we choose to ignore data that is occasionally missing we sacrifice accuracy in this paper we present a novel technique to address the problem of handling missing data in biometrics systems without having to make implicit assumptions on the distribution of the underlying data we introduce the concept of operational adaptation for biometric systems and formalize the problem we present a solution for handling missing data based on refactoring on support vector machines for large scale face recognition tasks we also develop a general approach to estimating svm refactoring risk we present experiments on large scale face recognition based on describable visual attributes on lfw dataset our approach consistently outperforms state of the art methods designed to handle missing data a lightweight remodularization process based on structural similarity 2016 ieee erosion process when neglected over long periods may reduce the concrete architecture to a small set of strongly coupled and weakly cohesive components this nullifies the benefits provided by an architectural design such as maintainability scalability portability etc in this scenario the solution might be only achieved through a complete remodularization process however most remodularization approaches are heavyweight and lack tool support this paper therefore proposes a lightweight and tool supported remodularization process based on structural similarity the process is centered on the observation that the remodularization of a software system can be achieved by successive applications of move class move method and extract method refactorings we evaluate the process in a modified version of an open source software achieving a recall of 100 and a precision of 50 the design decisions of the proposed process such as the use of structural similarity non implementation of preconditions and identification of the target entity on demand were also evaluated obtaining outcome results refactoring remodularization structural similarity detecting code smells in python programs 2016 ieee as a traditional dynamic language python is increasingly used in various software engineering tasks however due to its flexibility and dynamism python is a particularly challenging language to write code in and maintain consequently python programs contain code smells which indicate potential comprehension and maintenance problems with the aim of supporting refactoring strategies to enhance maintainability this paper describes how to detect code smells in python programs we introduce 11 python smells and describe the detection strategy we also implement a smell detection tool named pysmell and use it to identify code smells in five real world python systems the results show that pysmell can detect 285 code smell instances in total with the average precision of 97 7 it reveals that large class and large method are most prevalent our experiment also implies python programs may be suffering code smells further code smells program maintenance python refactoring a novel approach to super quality software development using workflows 2016 ieee this paper proposes a novel approach to develop super quality software s using workflows that improves the software code quality by reducing occurrence of software maintenance problems to minimum it motivates the software development companies to use a static code analysis tool with our proposed modifications therefore the static code analysis sca exposes critical areas at early stages to be comprehensively tracked and fixed in less time and effort to improve the software quality significantly the improved sca presents quantitative listing of detected code smells of implemented workflows with activities suggested refactoring methods to eliminate the identified code smells and their criticality ratios code refactoring software quality static code analysis workflow foundation research on the multi channel wavelet segmentation method of faint cotton foreign fibers 2016 science press all right reserved for the faint foreign fibers that were produced in the process of the rapid detection of the lint cotton foreign fibers the segmentation method was presented based on multi channel color components wavelet decomposition and reconstruction first of all the original foreign fiber image was divided into three single channel image secondly each piece of the single channel image was decomposed by wavelet transform and do subtraction processing between each two wavelet images which were decomposed by wavelet finally the images obtained by the subtraction processing were refactored by inverse wavelet transform the experimental results show that the faint foreign fibers can be accurately segmented using this method so as to solve the problem that the faint foreign fibers can t be segmented using existing segmentation method directly foreign fibers lint cotton multi channel segmentation wavelet decomposition technology development for natural product biosynthesis in saccharomyces cerevisiae 2016 elsevier ltd all rights reserved the explosion of genomic sequence data and the significant advancements in synthetic biology have led to the development of new technologies for natural products discovery and production using powerful genetic tools the yeast saccharomyces cerevisiae has been engineered as a production host for natural product pathways from bacterial fungal and plant species with an expanding library of characterized genetic parts biosynthetic pathways can be refactored for optimized expression in yeast new engineering strategies have enabled the increased production of valuable secondary metabolites by tuning metabolic pathways improvements in high throughput screening methods have facilitated the rapid identification of variants with improved biosynthetic capabilities in this review we focus on the molecular tools and engineering strategies that have recently empowered heterologous natural product biosynthesis a comparative study on the intensity and harmfulness of late propagation in near miss code clones 2016 springer science business media new york exact or nearly similar code fragments in a software system s source code are referred to as code clones it is often the case that updates i e changes to a code clone will need to be propagated to its related code clones to preserve their similarity and to maintain source code consistency when there is a delay in propagating the changes possibly because the developer is unaware of the related cloned code the system might behave incorrectly a delay in propagating a change is referred to as ‘late propagation and a number of studies have investigated this phenomenon however these studies did not investigate the intensity of late propagation nor how late propagation differs by clone type in this research we investigate late propagation separately for each of the three clone types type 1 type 2 and type 3 according to our experimental results on thousands of revisions of eight diverse subject systems written in two programming languages late propagation occurs more frequently in type 3 clones compared with the other two clone types more importantly there is a higher probability that type 3 clones will experience buggy late propagations compared with the other two clone types also we discovered that block clones are more involved in late propagation than method clones refactoring and tracking of similarity preserving change pattern spcp clones i e the clone fragments that evolve following a spcp can help us minimize the occurrences of late propagation in clones clone genealogy code clones late propagation near miss clones code refactoring techniques for reducing energy consumption in embedded computing environment 2016 springer science business media new york code refactoring is the process of restructuring existing computer code without changing its external behavior to enhance reusability and maintainability of software components through improving nonfunctional attributes of the software however when we refactor source codes using existing refactoring techniques those techniques do not consider energy consumption as one of the nonfunctional attributes reducing energy consumption is one of the important factors to develop embedded and or mobile software because it is difficult to provide sustainable services based on limited power resources this paper suggests new refactoring techniques for reducing energy consumption to support the restructuring of existing source codes especially we define energy consuming constructs as suspicious codes that are predicted to consume a lot of energy and then develop the techniques to remove these constructs our techniques can improve the performance as well as the energy efficiency of legacy codes code refactoring embedded software energy consuming constructs energy consumption energy efficient constructs analyzing students software redesign strategies 2016 acm the design of software is known to be difficult for novice computer scientists in this paper we focus on software redesign and on the refactoring necessary to implement a redesign redesigning an application aims to improve nonfunctional aspects such as extensibility without changing the functionality redesign is a complex task involving knowledge and skills from software design in general and the use of design patterns in particular this study is part of an educational design research project aiming at developing scaffolding for students software redesign activities in the form of procedural guidance we investigated students strategies and usage of concepts during a software redesign assignment using students reports and team colllaboration recordings as data sources thus focusing on the process instead of on the design results in contrast with existing studies we identified several difficulties that can serve as starting points for procedural guidance for instance students seem to avoid using a structured analysis method our findings indicate that students activities were mainly directed towards the code rather than the design problem design patterns education procedural guidelines redesign refactoring a method of program refactoring based on code clone detection and impact analysis 2016 the society of instrument and control engineers sice this paper proposes a method that aggregates similar portions in a program into one common portion and redesigns current program structure to appropriate program structure when a new function is added to an existing program the function tends to be developed by copying pasting a portion in the program and modifying its portion as a result it becomes to exist many similar portions in the program in the case that error modifications or changes occurs in the similar portion appropriate modifications are required to the all similar portions it would be considered that the quality and efficiency of those tasks are decreased so that this paper proposes a method that detect similar portions with minor modifications and a method that aggregates those similar portions to one appropriate common portion with well defined program structure as a result current program becomes to be refined to the program that can accommodate future modification or changes properly code clone impact analysis refactoring case study an analysis of accidental complexity in a state of the art hyper heuristic for hyflex 2016 ieee while simplicity is an important factor affecting algorithm re usability it is often overlooked in algorithm design which has a tendency to produce overly complex methods in this paper we demonstrate accidental complexity analysis aca a research practice targeted at detecting and eliminating accidental complexity without loss of performance c f refactoring in software engineering using it to analyze the presence of accidental complexity in gihh a state of the art selection hyper heuristic for hyflex we identify various algorithmic sub mechanisms contributing little to gihh s overall performance and validate many other as an outcome we present lean gihh a simplified re implementation of gihh smells in block based programming languages 2016 ieee code smells were originally designed for object oriented code but in recent years have been applied to end user languages including spreadsheets and yahoo pipes in this paper we explore code smells in block based end user programming languages aimed at education specifically we explore the occurrence of smells in two educational languages not previously targeted by smell detection and refactoring research lego mindstorms ev3 and microsoft s kodu the results of this exploration show that object oriented inspired smells indeed occur in educational end user languages and are present in 88 and 93 of the ev3 and kodu programs respectively most commonly we find that programs are plagued with lazy class duplication and dead code smells with duplication smells being present in nearly two thirds of programs in both languages developing usable apis with xp and cognitive dimensions 2016 ieee developing a usable application programming interface api is a complex and expensive task two major factors play important roles on the usability of an api the design and resources e g documentation tutorials api developers typically evaluate the usability of an api after implementation that results in refactoring tasks if an api lacks usability after development this refactoring could be avoided if evaluation were continuously conducted while development this paper explores a new combined process for building usable apis that combines concepts from a usability evaluation method cognitive dimensions framework and an agile development methodology extreme programming we explored the effectiveness of this combined process by implementing a web based api and conducting a user study the findings from our evaluation indicated that the new process helped in designing and building a usable api but ignored some concerns related to resources apis cognitive dimension framework usability xp sequencing of refactoring techniques by greedy algorithm for maximizing maintainability 2016 ieee software maintainability is the ease with which a software system can be modified to correct faults improve performance or other attributes of the source code bad smells are symptoms of deeper problem that indicates the need for refactoring which is the process of changing internal structure of the software without affecting its external attributes applying different refactoring techniques in different parts of a code results in changed maintainability value every time therefore sequence in which refactoring should be applied is important so that optimal results can be obtained in this study we have proposed an approach for evaluating sequence of refactoring by with the help of greedy algorithm the algorithm selects locally optimal solution at each stage with the hope of finding global optimal solution different sequences are generated and applied to the source code to calculate sum of software maintainability values greedy algorithm helps in finding the optimal sequence out of all the search space we have evaluated the approach with source code having god class long method feature envy long parameter list data clumps data class class hierarchy problem empty catch block exception thrown in finally block and nested try statement bad smells which are detected manually hence our approach is able to identify sequence for refactoring as well as best refactoring which will increase maintainability and enhance software quality greedy algorithm quality refactoring sequence software maintainability software metrics an empirical study to assess the effects of refactoring on software maintainability 2016 ieee maintenance is the most expensive phase of software and during this process refactoring is performed to improve the code without affecting its external behaviour this study examines the effects of refactoring on maintainability using five proprietary software systems internal quality attributes were measured using design metrics suite whereas external quality attributes such as the level of abstraction understandability modifiability extensibility and reusability were measured through expert opinion the original versions of software are compared with refactored versions and the changes in quality attributes were mapped to maintainability the results reveal that refactoring significantly improves the software quality and enhances software life it was also found that even though refactoring is very tedious and might introduce errors if not implemented with utmost care it is still advisable to frequently refactor the code to increase maintainability results of this study are useful to project managers in identifying the opportunities of refactoring while maintaining a perfect balance between reengineering and over engineering empirical validation external quality attributes internal quality attributes refactoring software maintainability why we refactor confessions of github contributors refactoring is a widespread practice that helps developers to improve the maintainability and readability of their code however there is a limited number of studies empirically investigating the actual motivations behind specific refac toring operations applied by developers to fill this gap we monitored java projects hosted on github to detect re cently applied refactorings and asked the developers to ex plain the reasons behind their decision to refactor the code by applying thematic analysis on the collected responses we compiled a catalogue of 44 distinct motivations for 12 well known refactoring types we found that refactoring ac tivity is mainly driven by changes in the requirements and much less by code smells extract method is the most versatile refactoring operation serving 11 different purposes finally we found evidence that the ide used by the devel opers affects the adoption of automated refactoring tools code smells github refactoring software evolution a review on quality models to analyse the impact of refactored code on maintainability with reference to software product line 2016 ieee code cloning is a major problem in object oriented methodology and advanced software methodologies like software product line methodology spl spl maintainability is a critical quality factor which is influenced by code cloning detection and correction there are quality models to study and analyze such impacts but existing quality models fall short in assessing the impact of code clones on them since spl maintainability is one of the key factors when considering software quality our study revolves around it also the fact that not much experiments have been performed to assess and measure the impact of refactored code on spl maintainability we wish to divulge in that particular area a review has been done which validates the need to quantify spl maintainability before and after it has been refactored code clones maintainability refactoring software produetlines spl estimating and quantifying the benefits of refactoring to improve a component modularity a case study 2016 ieee in recent years research and industry s attention has been focused on maintaining a system that would both decrease time to market in the short term and assure a sustainable feature output and smooth maintenance operations in the long run a related phenomenon has been identified in architectural technical debt if the system architecture is sub optimal for long term business goals it needs to be refactored a key property of the system assuring long term goals consists on modularity or else the ability to decouple different components such property allows the product to be evolved without costly changes pervading the whole system however understanding the business benefits of refactoring to achieve modularity is not trivial especially for large refactorings involving substantial architectural changes we have conducted a case study in a large company analyzing a case of refactoring a component to achieve modularity we report a comparative study of a refactored against a non refactored component we found that the modularization would be repaid in several months of development and maintenance we present a method to calculate the effort saved by the modularization and an equation for calculating and quantifying the development and maintenance benefits of refactoring estimation modularization refactoring software architecture software management technical debt proceedings 42nd euromicro conference on software engineering and advanced applications seaa 2016 the proceedings contain 53 papers the topics discussed include supporting feature estimation with risk and effort annotations towards guidelines for preventing critical requirements engineering problems busting software architecture beliefs a survey on success factors in architecture decision making technical debt management with genetic algorithms evidence based timelines for user experience software process improvement retrospectives identifying developers expertise in social coding platforms continuous lean and wasteless minimizing lead time from development done to production use implementing continuous customer care first hand experiences from an industrial setting estimating and quantifying the benefits of refactoring to improve a component modularity a case study a case study on the utilization of problem and solution domain measures for software size estimation mvp explained a systematic mapping study on the definitions of minimal viable product product innovation through internal startup in large software companies a case study systematic mapping study of dealing with error in software development effort estimation bayesian synthesis for knowledge translation in software engineering method and illustration a property model ontology handling uncertainty in automatically generated implementation models in the automotive domain and literature review of empirical research studies within the domain of acceptance testing software evolution information driven service oriented software clustering 2016 ieee service oriented software in business is often programmed using java language for purpose of making software evolvable and maintainable the technology of software clustering is often used to make the software modularized however traditional software clustering methods have not considered the potential relation between software elements which cannot be identified by using the static analysis method so it can make the software not satisfy the principle of high cohesion low coupling in the area of software engineering for solving the problem this paper proposes a method by introducing the software evolution information into the software clustering process based on that we construct an extended software dependency model and use agglomerative hierarchical clustering ahc algorithm to cluster software experiments on two open source project show that this method can improve the accuracy of software clustering and aid the maintainer refactoring business software high cohesion low coupling software clustering software evolution software reconsturcture sustained production of multidecadal climate records lessons from the noaa climate data record program the national oceanic and atmospheric administration noaa initially worked with the national research council to define climate data records cdrs and associated elements needed for their successful generation the cdr program has been implemented by establishing a maturity model for rigorously assessing the level of process maturity in data management software management and application of the climate records in research and applications similar to other methods for quantifying software and data management maturity it serves as a measurement instrument to help evaluate how scientists are doing in these process areas and identifying what should be done next to achieve operational capabilities the cdr maturity model is one way of achieving best practices for the production preservation and use of cdrs the transition of a cdr from research to operations also facilitates additional use inspired applications of cdrs for near real time monitoring as well as tailored use in sectors a major challenge for the transition of cdrs to full operational capability has been the design architecture and portability of the software the cdr program has begun to rigorously address this challenge and has piloted the oisst software through refactoring code and script modifications an empirical study on the effect of the order of applying software refactoring 2016 ieee refactoring has been widely used to improve software design refactoring is applied when a bad smell is detected several bad smells might be present in the code in this paper we conduct an empirical study to find if the order of applying refactoring has any impact on the quality of the final code we run six experiments by applying three refactoring methods in different orders and evaluate the quality of the code using software metrics at the end of each refactoring sequence our experiments results show that that applying refactoring in different order provides different impact on the final code bad smells code quality empirical study refactoring refactoring refactoring cost estimation rce model for object oriented system 2016 ieee successful software systems must be developedto evolve or die although object oriented softwaresystems are to be built to last over the time but they willdegrade as much as any legacy software system as aconsequence one may identify various reengineeringpatterns which capture best practice in reverse and re engineering object oriented legacy systems software reengineeringbasically focuses on re implementing oldersystems to improve or make it more maintainable refactoring is on kind of re engineering with in an object oriented context in this paper with the given object oriented refactoring opportunities the cost ofrefactoring is resembled using rce the opportunities areclass misuse violation of the principle of encapsulation lack of use of inheritance concept misuse of inheritance misplaced polymorphism rce model refactoring refactoring cost major motivations for extract method refactorings analysis based on interviews and change histories 2016 higher education press and springer verlag berlin heidelberg extract method is one of the most popular software refactorings however little work has been done to investigate or validate the major motivations for such refactorings digging into this issue might help researchers to improve tool support for extract method refactorings e g proposing better tools to recommend refactoring opportunities and to select fragments to be extracted to this end we conducted an interview with 25 developers and our results suggest that current reuse decomposition of long methods clone resolution and future reuse are the major motivations for extract method refactorings we also validated the results by analyzing the refactoring history of seven open source applications analysis results suggest that current reuse was the primary motivation for 56 of extract method refactorings decomposition of methods was the primary motivation for 28 of extract method refactorings and clone resolution was the primary motivation for 16 of extract method refactorings these findings might suggest that recommending extract method opportunities by analyzing only the inner structure e g complexity and length of methods alone would miss many extract method opportunities these findings also suggest that extract method refactorings are often driven by current and immediate reuse consequently how to recognize or predict reuse requirements timely during software evolution may play a key role in the recommendation and automation of extract method refactorings we also investigated the likelihood for the extracted methods to be reused in future and our results suggest that such methods have a small chance received april 2 2015 accepted november 10 2015 e mail liuhui08 bit edu cn 12 to be reused in future unless the extracted fragment could be reused immediately in software evolution and extracting such a fragment can resolve existing clones at the same time data mining extract method motivation software quality software refactoring prioritizing test cases for early detection of refactoring faults copyright â 2016 john wiley sons ltd refactoring edits are error prone requiring cost effective testing regression test suites are often used as a safety net for decreasing the chances of behavioural changes because of the high costs related to handling massive test suites prioritization techniques can be applied to reorder test case execution fostering early fault detection however traditional prioritization techniques are not specifically designed for detecting refactoring related faults this article proposes refactoring based approach rba a refactoring aware strategy for prioritizing regression test cases rba reorders an existing test sequence using a set of proposed refactoring fault models that define the refactoring s impact on program methods refactoring based approach s evaluation shows that it promotes early detection of refactoring faults and outperforms well known prioritization techniques in 71 of the cases moreover it prioritizes fault revealing test cases close to one another in 73 of the cases which can be useful for fault localization those findings show that rba can considerably improve prioritization of test cases during perfective evolution both by increasing fault detection rates as well as by helping to pinpoint defects introduced by an incorrect refactoring copyright â 2016 john wiley sons ltd automated software testing refactoring test case prioritization exploiting antipheromone in ant colony optimisation for interactive search based software design and refactoring 2016 copyright held by the owner author s preventing user fatigue in interactive meta heuristic search places as great an emphasis on efficiency as it does on effectiveness engagement may also be boosted if the system provides a sense of responsiveness for example avoiding unpopular solutions as well as exploiting preferred ones in this paper we explore one possible way of achieving these goals using the concept of anti pheromones in different forms of ant colony optimisation taking search based software design and refactoring as a case study we use extensive offline experiments to investigate differences of timescale and method for applying anti pheromones results confirm our predictions that most combinations are in fact counter productive however applying high levels of anti pheromone only in the initial stages of a run can rapidly steer the search away from unproductive regions reducing the number of evaluations required by up to 20 without compromising solution fitness ant colony optimisation antipheromone search based software engineering a case study in object oriented patterns identified during manual refactoring 2016 ieee software design patterns are often repeated implementations that have been identified and cataloged these are commonly seen as useful and good patterns to implement occasionally the term anti pattern has been used to identify less useful patterns that also appear regularly the exact definition of an anti pattern is somewhat subjective and the term has even been applied to some recognized design patterns this paper discusses four manual refactoring case studies where patterns were discovered and cataloged evidence observed in the source code is used to infer how these patterns evolved based on these findings preventive development practices are suggested potential improvements to development tools and a new method for pattern classification are suggested as subjects for future work anti patterns design patterns refactoring reverse engineering software aging software evolution software quality on method ordering 2016 ieee as the order of methods in a java class has no effect on its semantics an engineer can choose any order she prefers which code conventions regarding methods ordering are common in practice if any are some orders better than others in making the code easier to understand can good orders be computed and applied automatically in this work we address these questions first we present a study of method orders in a large body of open source projects where we identify existing common practices second we present four method ordering strategies which we automate and provide in an eclipse plugin as a form of refactoring finally we present the results of a user study which evaluates the effect of our methods ordering strategies on engineers code comprehension in terms of correctness and time spent on answering identifying functionally similar code in complex codebases 2016 ieee identifying similar code in software systems can assist many software engineering tasks such as program understanding and software refactoring while most approaches focus on identifying code that looks alike some techniques aim at detecting code that functions alike detecting these functional clones code that functions alike in object oriented languages remains an open question because of the difficulty in exposing and comparing programs functionality effectively we propose a novel technique in vivo clone detection that detects functional clones in arbitrary programs by identifying and mining their inputs and outputs the key insight is to use existing workloads to execute programs and then measure functional similarities between programs based on their inputs and outputs which mitigates the problems in object oriented languages reported by prior work we implement such technique in our system hitoshiio which is open source and freely available our experimental results show that hitoshiio detects more than 800 functional clones across a corpus of 118 projects in a random sample of the detected clones hitoshiio achieves 68 true positive rate with only 15 false positive rate code clone detection data flow analysis dynamic analysis i o behavior patterns on fuzzy repetitions detection in documentation reuse 2016 pleiades publishing ltd increasing complexity of software documentation calls for additional requirements of document maintenance documentation reuse can make a considerable contribution to solve this problem this paper presents a method for fuzzy repetitions search in software documentation that is based on software clone detection the search results are used for document refactoring this paper also presents documentation refactoring toolkit implementing the proposed method and integrated with the docline project the proposed approach is evaluated on documentation packages for a number of open source projects linux kernel zend framework subversion and docbook fuel representing function structure and function dependencies with a uml profile for function modeling 2016 ios press and the authors modeling functions is a key aspect of artifact design including software engineering and business systems modeling but it is likewise of fundamental importance in natural systems modeling for example in modeling biological organisms the unified modeling language uml which originated from object oriented software engineering is nowadays a de facto standard for conceptual modeling and its current applications go far beyond software engineering the paper investigates first to what extent uml is suited for modeling functions we survey various approaches to function modeling with uml and identify their limitations based on the conducted analysis we introduce a uml profile for function modeling called the function modeling language fuel fuel enables the modeling of the structure of functions of relations between functions such as function decomposition as well as of function ascription i e of relations linking functions with other types of entities the main application field that we considered while developing fuel is bioinformatics nonetheless the presented profile is domain independent and is capable of modeling cross domain systems the profile has been tested on fragments of the molecular function ontology a sub ontology of the gene ontology in this connection the paper further demonstrates that the applications of fuel transcend the construction of new models by showing how the profile aids restructuring and refactoring existing models function modeling gene ontology unified modeling language a systematic literature review refactoring for disclosing code smells in object oriented software 2017 context reusing a design pattern is not always in the favor of developers thus the code starts smelling the presence of code smells leads to more difficulties for the developers this racket of code smells is sometimes called anti patterns objective the paper aimed at a systematic literature review of refactoring with respect to code smells however the review of refactoring is done in general and the identification of code smells and anti patterns is performed in depth method a systematic literature survey has been performed on 238 research items that includes articles from leading conferences workshops and premier journals theses of researchers and book chapters results several data sets and tools for performing refactoring have been revealed under the specified research questions conclusion the work done in the paper is an addition to prior systematic literature surveys with the study of paper the attentiveness of readers about code smells and anti patterns will be enhanced anti patterns code smells refactoring 2016 international conference on information technology for organizations development it4od 2016 the proceedings contain 79 papers the topics discussed include modeling and generating graphical user interface for mvc rich internet application using a model driven approach operator based coordination between heterogeneous dsls case of telecommunication network supervision model transformations generation a survey of the state of the art abstract review of composition approaches invalid input data and conformity testing for an object oriented specification the anticipated test design and its use in legacy code refactoring lessons learned from a real experiment selection algorithm of contextual software entities for composing adaptive mobile applications prediction of costumers needs an approach based on similarity search in transactions databases and survey on information system security risk management alignment a genetic algorithm for automated refactoring of component based software 2016 icst nowadays a software undergoes modifications done by dif ferent people to quickly fulfill new requirements but its underlying design is not adjusted properly after each up date this leads to the emergence of bad smells refactoring provides a de facto behavior preserving means to elim inate these anomalies however manually determining and performing useful refactorings is known as an np complete problem as stated by harman et al 9 because seemingly useful refactorings can improve some aspect of a software while making another aspect worse therefore it has been proposed to view object oriented automated refactoring as a search based technique however the review of the litterature shows that automated refactoring of component based software has not been investigated yet recently a catalogue of component relevant bad smells has been pro posed in the literature but there is a lack of component relevant refactorings in this paper we propose a catalogue of component relevant refactoring as well as detections rules for component relevant bad smells then we rely on these two ingredients to propose a genetic algorithm for automated refactoring of component based software systems bad smells component based software engineering genetic algorithm refactoring ad room a tool for automatic detection of refactorings in object oriented models 2016 acm detecting refactorings in object oriented models oom is essential to automate the repair maintenance and migration of oom related products however detecting refactorings is challenging since multiple sequences of atomic changes may define a single user intention and refactorings may overlap over the atomic change trace in this paper we present ad room an eclipse based tool to automatically detect refactorings during evolution of oom in contrast to existing tools ad room is designed to reach 100 recall that is confirmed in our eight case studies we allow user confirmation and we support the user with three heuristics that help to improve the precision of ad room see the demonstration video https youtu be 4oj8zhtfnq8 an empirically developed method to aid decisions on architectural technical debt refactoring anacondebt 2016 acm architectural technical debt is regarded as sub optimal architectural solutions that need to be refactored in order to avoid the payment of a costly interest in the future however decisions on if and when to refactor architecture are extremely important and difficult to take since changing software at the architectural level is quite expensive therefore it is important for software organizations to have methods and tools that aid architects and managers to understand if architecture technical debt will generate a costly and growing interest to be paid or not current knowledge especially empirically developed and evaluated is quite scarce in this paper we developed and evaluated a method anacondebt by analyzing together with several practitioners 12 existing cases of architecture debt in 6 companies the method has been refined several times in order to be useful and effective in practice we also report the evaluation of the method with a final case for which we present anonymized results and subsequent refactoring decisions the method consists of several components that need to be analyzed combining the theoretical technical debt framework and the practical experience of the practitioners in order to identify the key factors involved in the growth of interest the output of the method shows summarized indicators that visualizes the factors in a useful way for the stakeholders this analysis aids the practitioners in deciding on if and when to refactor architectural technical debt items the method has been evaluated and has been proven useful to support the architects into systematically analyze and decide upon a case architectural technical debt decision making design research empirical study estimation method refactoring proceedings international conference on software engineering the proceedings contain 156 papers the topics discussed include investing in the impending digital quake 80 jobs companies research disrupted an empirically developed method to aid decisions on architectural technical debt refactoring anacondebt practical programming validation and verification with finite state machines a library and its industrial application battles with false positives in static analysis of javascript web applications in the wild detecting problems in the database access code of large scale systems an industrial experience report engineering the servo web browser engine using rust the bones of the system a case study of logging and telemetry at microsoft log clustering based problem identification for online service systems assessing the usefulness of a requirements monitoring tool a study involving industrial software engineers lessons learned in aligning data and model evolution in collaborative information systems venron a versioned spreadsheet corpus and related evolution analysis enhancing test case prioritization in an industrial setting with resource awareness and multi objective search integrating automatic backward error recovery in asynchronous rich clients a study of the quality impacting practices of modern code review at sony mobile and correct code reviewer recommendation in github based on cross project and technology experience an empirical study of the performance impacts of android code smells 2016 acm android code smells are bad implementation practices within android applications or apps that may lead to poor software quality in particular in terms of performance yet performance is a main software quality concern in the development of mobile apps correcting android code smells is thus an important activity to increase the performance of mobile apps and to provide the best experience to mobile end users while considering the limited constraints of mobile devices e g cpu memory battery however no empirical study has assessed the positive performance impacts of correcting mobile code smells in this paper we therefore conduct an empirical study focusing on the individual and combined performance impacts of three android performance code smells namely internal getter setter member ignoring method and hashmap usage on two open source android apps to perform this study we use the paprika toolkit to detect these three code smells in the analyzed apps and we derive four versions of the apps by correcting each detected smell independently and all of them then we evaluate the performance of each version on a common user scenario test in particular we evaluate the ui and memory performance using the following metrics frame time number of delayed frames memory usage and number of garbage collection calls our results show that correcting these android code smells effectively improve the ui and memory performance in particular we observe an improvement up to 12 4 on ui metrics when correcting member ignoring method and up to 3 6 on memory related metrics when correcting the three android code smells we believe that developers can benefit from these results to guide their refactoring and thus improve the quality of their mobile apps android code smells metrics mobile computing performance generating hierarchical reference process model using fragments clustering 2015 ieee process models are becoming more and more widespread in contemporary organizations for the purpose of reducing cost and improve model quality the ability to rapidly tailor a reference process to satisfy the changing of business requirements is necessary for organizations in this context how to provide a suitable reference process model for a specific domain becomes a challenging question this paper proposes a method to automatically generate a hierarchical reference process model using fragments clustering from existing process variants similar fragments in process variants are detected and clustered firstly then an improved reference sub process is discovered for each cluster of fragments based on a heuristic search after fragments are replaced by reference sub processes hierarchically the refactored process variants are merged into the final reference process model the quality and usability of the generated reference model are demonstrated by a case study and user experiment from a real industry scenario clustering process fragment process model process similarity process variants reference model power quality disturbance analysis based on wavelet transform and improved prony method 2016 power system protection and control press all right reserved the traditional analysis method for power quality only analyzes one kind of specific problems in order to effectively distinguish and identify common power disturbance signal an algorithm combining wavelet analysis with prony method is proposed firstly the wavelet multi resolution analysis is introduced the appropriate wavelet function is proposed to decompose the disturbance signal and whether the decomposed signal modulus maxima exist is judged thus the steady state and transient state power quality disturbance problems are distinguished for the transient disturbance problem mallat refactoring layer is optimized the transient disturbance waveform are extracted and the type of disturbance is distinguished for the steady disturbance problem the process of estimating system order by prony method and the accuracy of parameter identification are improved finally mixed disturbance signals are analyzed and the simulation and experimental verification are performed by matlab results of simulation and experiments show that the proposed method algorithm can accurately identify the various types of power quality disturbance signal mallat reconstruction parameter identification power quality prony method wavelet analysis mining static and dynamic crosscutting concerns a role based approach copyright â 2016 john wiley sons ltd the implementation of crosscutting concerns in object oriented oo systems entails scattering and tangling of code across several components increasing code duplication and making the system harder to comprehend maintain evolve and reuse therefore identification of crosscutting concerns drives the re engineering or refactoring tasks in order to improve modularization of an existing system and increasing its overall internal quality this paper proposes an approach to identify and analyse the components implementing the static and dynamic crosscutting in oo systems the approach defines a meta model representing the structure of an oo system in terms of its components a static analysis of an oo software system is performed to create an instance of this meta model such meta model is finally analysed to find static and dynamic crosscutting among concerns the effectiveness and efficiency of the proposed approach have been validated in an empirical assessment where it was applied to some oo java systems the obtained results show a good level of effectiveness for the crosscutting analysis aspect mining aspect oriented programming mof reverse engineering software evolution sparse pca corrects for cell type heterogeneity in epigenome wide association studies 2016 nature america inc all rights reserved in epigenome wide association studies ewas different methylation profiles of distinct cell types may lead to false discoveries we introduce refactor a method based on principal component analysis pca and designed for the correction of cell type heterogeneity in ewas refactor does not require knowledge of cell counts and it provides improved estimates of cell type composition resulting in improved power and control for false positives in ewas development of a modeling method for monitoring tunnel deformation based on active panoramic vision technology 2015 ieee a new approach is introduced to measure tunnel deformation by active panorama vision technology aiming at the long distance tunnel long maintenance intervals limited repairing time a little of deformation change of the tunnel in order to monitor the tunnel deformation information firstly the panoramic scanning image of tunnel section can be directly received when the active stereo omni directional vision sensors asodvs in the tunnel detection device is going through the tunnel to make a panoramic scanning then the geometry information of target surface can be analyzed through extracting the reflected laser image from the picture captured after that the tunnel is reconstructed using spatial point cloud data finally the refactoring tunnel model precision is analyzed the experimental research shows that the system has the advantages of high speed acquisition more real time more detailed data high visualization it can meet the needs of the rapid qualitative and quantitative analysis active panorama vision panorama laser scanning tunnel 3d reconstruction tunnel cross section tunnel deformation monitoring bernstein neural network chaotic sequence prediction based on phase space reconstruction 2016 the editorial board of journal of system simulation all right reserved in view of the low prediction accuracy and the complex structure of traditional bp neural network rbf neural network and ar model a new prediction method with the combination of phase space reconstruction and bernstein neural network was proposed and pso algorithm was used for parameters optimization of combination forecast model taking sprott j chaotic system and traffic flow system as models respectively the combination of autocorrelation and cao method was used to reconstruct phase space of chaotic time sequence the refactoring phasor of time delay and bernstein neural network were used to establish the prediction model and do comparative analysis with traditional bp neural network rbf neural network and ar models the simulation results show that the combination prediction of phase space reconstruction and bernstein neural network has a simple structure and can get more preferable simulation effect and higher prediction accuracy bernstein neural network chaotic time sequence prediction phase space reconstruction pso algorithm a systematic mapping study on mining software repositories 2016 acm background software repositories provide large amount of data encompassing software changes throughout its evolution those repositories can be effectively used to extract and analyze pertinent information and derive conclusions related to the software history or its current snapshot objective this work aims to investigate recent studies on mining software repositories msr approaches collecting evidences about software analysis goals purpose focus and object of analysis data sources evaluation methods tools and how the area is evolving method a systematic mapping study was performed to identify and analyze research on mining software repositories by analyzing five editions of working conference on mining software repositories the main conference on this area results msr approaches have been used for many different goals mainly for comprehension of defects analysis of the contribution and behavior of developers and software evolution comprehension besides some gaps were identified with respect to their goals focus and data source type e g lack of usage of comments to identify smells refactoring and issues of software quality regarding the evaluation method our analysis pointed out to an extensive usage of some types of empirical evaluation conclusion studies of the msr have focused on different goals however there are still many research opportunities to be explored and issues associated with msr that should be considered empirical software engineering mining software repository secondary study systematic mapping study students and professionals perceptions of test driven development a focus group study 2016 acm we have conducted a qualitative investigation on test driven development tdd with focus groups to develop insights on the opinions of developers using tdd regarding the unintuitive process involved its claimed effects as well as the context factors that can facilitate or hinder its application in particular we conducted two focus group sessions one with professionals and another with master students in computer science we used thematic analysis template tat method for identifying patterns themes and interpretations in gathered data we obtained a number of results that can be summarized as follows i applying tdd without knowing advanced unit testing techniques can be difficult ii refactoring one of the phases of tdd is not done as often as the process requires iii there is a need for live feedback to let developers understand if tdd is being applied correctly and iv the usefulness of tdd hinges on task and domain to which it is applied to focus group qualitative study test driven development understanding and addressing exhibitionism in java empirical research about method accessibility 2015 springer science business media new york information hiding is a positive consequence of properly defining component interfaces unfortunately determining what should constitute a public interface remains difficult we have analyzed over 3 6 million lines of java open source code and found that on the average at least 20 of defined methods are over exposed thus threatening public interfaces to unnecessary exposure such over exposed methods may have their accessibility reduced to exactly reflect the method usage we have identified three patterns in the source code to identify over exposed methods we also propose an eclipse plugin to guide practitioners in identifying over exposed methods and refactoring their applications our plugin has been successfully used to refactor a non trivial application information hiding method accessibility jet shapes in dijet events at the lhc in scet 2016 the author s abstract we consider the class of jet shapes known as angularities in dijet production at hadron colliders these angularities are modified from the original definitions in e e − collisions to be boost invariant along the beam axis these shapes apply to the constituents of jets defined with respect to either k t type anti k t c a and k t algorithms and cone type algorithms we present an scet factorization formula and calculate the ingredients needed to achieve next to leading log nll accuracy in kinematic regions where non global logarithms are not large the factorization formula involves previously unstudied unmeasured beam functions which are present for finite rapidity cuts around the beams we derive relations between the jet functions and the shape dependent part of the soft function that appear in the factorized cross section and those previously calculated for e e − collisions and present the calculation of the non trivial color connected part of the soft function to formula presented this latter part of the soft function is universal in the sense that it applies to any experimental setup with an out of jet p t veto and rapidity cuts together with two identified jets and it is independent of the choice of jet sub structure measurement in addition we implement the recently introduced soft collinear refactorization to resum logarithms of the jet size valid in the region of non enhanced non global logarithm effects while our results are valid for all 2 → 2 channels we compute explicitly for the qq′ → qq′ channel the color flow matrices and plot the nll resummed differential dijet cross section as an explicit example which shows that the normalization and scale uncertainty is reduced when the soft function is refactorized for this channel we also plot the jet size r dependence the p t cut dependence and the dependence on the angularity parameter a jets qcd phenomenology rationally reduced libraries for combinatorial pathway optimization minimizing experimental effort rational flux design in metabolic engineering approaches remains difficult since important pathway information is frequently not available therefore empirical methods are applied that randomly change absolute and relative pathway enzyme levels and subsequently screen for variants with improved performance however screening is often limited on the analytical side generating a strong incentive to construct small but smart libraries here we introduce redlibs reduced libraries an algorithm that allows for the rational design of smart combinatorial libraries for pathway optimization thereby minimizing the use of experimental resources we demonstrate the utility of redlibs for the design of ribosome binding site libraries by in silico and in vivo screening with fluorescent proteins and perform a simple two step optimization of the product selectivity in the branched multistep pathway for violacein biosynthesis indicating a general applicability for the algorithm and the proposed heuristics we expect that redlibs will substantially simplify the refactoring of synthetic metabolic pathways crosscutting concerns refactoring in agent framework 2015 ieee agent framework such as aglets has crosscutting concern ccc that is legacy from object oriented oo programming refactoring is needed to make a clean agent framework from the problems aspect mining and aspect identification is an important process that has to be conducted in refactoring process aspect implementation can be conducted after aspect mining have been succeeded to identify ccc this paper presents an experience to analyze and identify ccc in agent framework two techniques tried to be combined to conduct aspect mining those techniques are search based technique and diff algorithm aglets framework become a case study to perform the aspect mining step by step of the technique will be explained to get aspect mining is more clear agent framework aspect mining aspect oriented programming crosscutting concerns refactoring modeling design flaw evolution using complex systems 2015 ieee by modelling a software project as a complex system its internal structure can be analyzed in order to asses its design quality as a software system is being developed the quality of its internal structure is evolving too not always for the better flaws in the internal structure are usually indicators of code that is hard to understand maintain and in many cases they are pointers of accumulated technical debt while there are already methods and tools that enable design flaw detection they only look at a snapshot of the code they do not analyze how the design flaw evolved over time we propose an approach which enhances design flaw detection with history information in order to i find patterns in the evolution of a design flaw which could then be used to predict future activity ii improve detection by eliminating false negatives iii improve the recommendation system to provide better refactoring advices and a better ranking of design flaws in order to address the most critical first neural network based refactoring area identification in software system with object oriented metrics objectives of the study a to study previously designed models for identification of refactoring area in object oriented software systems b to design a general framework or model that helps to easily identify the software code smells for a good quality of coding c to identify the bad smells in the code with a design of neural network based model with the help of object oriented metrics and further to predict the performance of the proposed model using various evaluation parameters of confusion matrix analysis methods in this study two different versions of rhino 1 7r1 and 1 7r2 were taken as dataset object oriented metrics were taken as input data and the probability factor occurrence or non occurrence of a bad smell as output presence of a bad smell was considered as 1 and 0 means absence of bad smell if there was at least one bad smell present in the code in a class it was marked as smelly class the tool used to extract the databases for collected object oriented metrics and bad smells of these rhino versions is ptidej further the data was tested on neural networks for different epochs to predict their performance findings a bad smell analysis twelve design smells were considered to detect the presence of bad smell in code if there was at least one bad smell present in the code in a class it was marked as smelly class b neural network model table weight and bias factor for various predictors were calculated for different epochs 500 1000 and 2000 it shows the weights assigned from input layer to hidden layer and from hidden layer to output neurons layer after the training the weights were tested on various datasets c performance tables and graphs in this the neural network proposed model was trained using different number of epochs to examine if the number of epochs used in training has any impact on the results or not further the results for the accuracy of these models were shown novelty improvement when the data was highly trained then the results were better when the data was trained with 500 epochs it was suitable for only with in company projects but when the data was more trained than the model was also appropriate for cross projects it was seen that when the data was trained with 1000 and 2000 epochs the results of the proposed model were improved artificial neural networks ann bad smells logistic regression object oriented metrics refactoring software maintainability co changing code volume prediction through association rule mining and linear regression model 2015 elsevier ltd all rights reserved code smells are symptoms in the source code that indicate possible deeper problems and may serve as drivers for code refactoring although effort has been made on identifying divergent changes and shotgun surgeries little emphasis has been put on predicting the volume of co changing code that appears in the code smells more specifically when a software developer intends to perform a particular modification task on a method a predicted volume of code that will potentially be co changed with the method could be considered as significant information for estimating the modification effort in this paper we propose an approach to predicting volume of co changing code affected by a method to be modified the approach has the following key features co changing methods can be identified for detecting divergent changes and shotgun surgeries based on association rules mined from change histories and volume of co changing code affected by a method to be modified can be predicted through a derived fitted regression line with t test based on the co changing methods identification results the experimental results show that the success rate of co changing methods identification is 82 with a suggested threshold and the numbers of correct identifications would not be influenced by the increasing number of commits as a project continuously evolves additionally the mean absolute error of co changing code volume predictions is 133 lines of code which is 95 3 less than the one of a naive approach co changing code volume prediction co changing methods identification technology of target inspection by diffraction interferometer based on sub aperture stitching ï¿½ 2016 editorial office of high power laser and particle beams all right reserved in order to inspect the surface topography of spherical target accurately efficiently and exhaustively which is the core component in inertial confinement fusion experiment a shape detection system is founded based on the technologies of sub aperture stitching and diffraction interferometry the basic testing principle and the calculation method of lateral resolution in once single measurement are provided the configuration of sub aperture is planned for the rotation scanning of the target in order to solve the problem that the matching algorithm shows a slow convergence rate or even misconvergence caused by the overlarge lateral distance between cloud data points a method of data points transverse compression is proposed which replaces the actual radius of curvature by a virtual tiny radius this method can improve the matching rate and the accuracy of the algorithm with the topography feature remaining unchanged at last a gold coated target with a diameter of 1mm is measured actually and the pv value and rms value of the relative topography errors after stitched are 1 332λ and 0 479λ respectively the macroscopic fluctuation characteristics and the partial topography detail can be obtained and the refactored target surface has a good visual quality phase shifting diffraction interferometry sub aperture stitching surface topography target clone merge an eclipse plugin to abstract near clone c methods 2015 ieee software clones are prevalent in the work of laguë et al 2 they observe that 6 4 and 7 5 of the source code in different versions of a large mature code base are clones the work of baxter et al 1 reports even higher numbers sometimes exceeding 25 we consider the prevalence of such near miss clones to be strong indicators that copy paste modify is a wide spread development methodology even though clones are prevalent they are a significant development headache specially if bugs arise in one of the clones they need to be fixed in all of the clones this problem is acknowledged in the work of juergens et al 4 who say in their work that cloning can be a substantial problem during development and maintenance since inconsistent clones constitute a major source of faults a similar concern is raised in practitioner literature 3 suggesting that clones should be removed in some form or the other we present a tool that can be installed as a plugin to eclipse cdt the development environment for c c the research prototype comes with a refactoring option called copy paste merge refactoring which is available as a menu option in the modified version of the eclipse cdt abstraction cdt clone eclipse evolution refactoring tracking the software quality of android applications along their evolution 2015 ieee mobile apps are becoming complex software systems that must be developed quickly and evolve continuously to fit new user requirements and execution contexts however addressing these requirements may result in poor design choices also known as antipatterns which may incidentally degrade software quality and performance thus the automatic detection and tracking of antipatterns in this apps are important activities in order to ease both maintenance and evolution moreover they guide developers to refactor their applications and thus to improve their quality while antipatterns are well known in object oriented applications their study in mobile applications is still in its infancy in this paper we analyze the evolution of mobile apps quality on 3 568 versions of 106 popular android applications downloaded from the google play store for this purpose we use a tooled approach called paprika to identify 3 object oriented and 4 android specific antipatterns from binaries of mobile apps and to analyze their quality along evolutions android antipattern mobile app software quality minimizing refactoring effort through prioritization of classes based on historical architectural and code smell information 2016 ceur ws all rights reserved improving a software system s internal structure through regular refactoring is considered vital for its long and healthy life however despite its amenities refactoring is not readily adopted by software development teams in industry mainly due to strict project deadlines and limited resources hence they look for optimal refactoring recommendations that would incur minimal effort overhead while outputting decent benefits in terms of enhanced software quality to this end we propose an approach for identifying and prioritizing object oriented software classes in need of refactoring our approach first identifies the most refactoring prone as well as architecturally relevant classes and then generates class ranks based on the code smell information in addition to locating classes with the most significant incremental refactoring opportunities this work contributes through suggesting developers on estimating maximum code smell correction paying off maximum technical debt with minimum refactoring effort we evaluated the proposed approach on a sample of 1621 classes and 2358 code smell instances distributed over 28 versions of four open source java systems class prioritization code smell refactoring effort software refactoring technical debt 12th international conference on integrated formal methods ifm 2016 the proceedings contain 33 papers the special focus in this conference is on program verification and probabilistic systems the topics include symbolic computation and automated reasoning for program analysis perspectives of model transformation reuse on type checking delta oriented product lines modelling and verifying a priority scheduler for an scj runtime environment translating between intermediate verification languages statistical approximation of optimal schedulers for probabilistic timed automata probabilistic formal analysis of app usage to inform redesign extension of prism by synthesis of optimal timeouts in fixed delay ctmc monitoring multi threaded component based systems a generalised theory of interface automata component compatibility and error on implementing a monitor oriented programming framework for actor systems towards a thread local proof technique for starvation freedom reasoning about inheritance and unrestricted reuse in object oriented concurrent systems a formal model of the safety critical java level 2 paradigm deciding monadic second order logic over x words by specialized finite automata property preservation for extension patterns of state transition diagrams symbolic reachability analysis of b through prob and ltsmin enhancing automata learning by log based metrics refactoring of legacy software using model learning and equivalence checking efficient deadlock freedom checking using local analysis and sat solving smt solvers for validation of b and event b models avoiding medication conflicts for patients with multimorbidities temporal random testing for spark streaming and combining static analysis and testing for deadlock detection deriving extract method refactoring suggestions for long methods springer international publishing switzerland 2016 the extract method is a common way to shorten long methods in software development before developers can use tools that support the extract method they need to invest time in identifying a suitable refactoring candidate this paper addresses the problem of finding the most appropriate refactoring candidate for long methods written in java the approach determines valid refactoring candidates and ranks them using a scoring function that aims to improve readability and reduce code complexity we use length and nesting reduction as complexity indicators the number of parameters needed by the candidate influences the score to suggest candidates that are consistent with the structure of the code information such as comments and blank lines are also considered by the scoring function we evaluate our approach to three open source systems using a user study with ten experienced developers our results show that they would actually apply 86 of suggestions for an extract method refactoring extract method long method refactoring suggestion ceur workshop proceedings the proceedings contain 11 papers the topics discussed include high performance median filtering algorithm based on nvidia gpu computing refactoring design patterns from object oriented to aspect oriented in eclipse simulating peer to peer networks using gpu high performance support parallel computing solutions for linear combination of filters performances of a parallel cuda program for a biorthogonal wavelet filter performance evaluation of multimodal biometric systems based on mathematical models and probabilistic neural networks adaptive vpn bonding technique for enhancing dual sim mobile internet access performance analysis of roberts edge detection using cuda and opengl designing mazes for 2d games by artificial ant colony algorithm and on an improvement of the numerical application for cardano s formula in mathematica software energy implications of common operations in resource intensive java based scientific applications springer international publishing switzerland 2016 today s scientific applications usually take considerable time to run and hence parallel computing environments such as grids and data centers clouds have emerged indeed traditionally much research in high performance computing has been conducted with the goal of executing such applications as fast as possible however energy has recently been recognized as another crucial goal to consider because of its negative economic and ecological implications energy driven solutions in these environments are mostly focused on the hardware and middleware layers but little efforts target the application level we revisit a catalog of primitives commonly used in object oriented based scientific programming or micro benchmarks to identify energy friendly variants of the same primitive based on this we refactor three existing scientific applications resulting in energy improvements ranging from 2 58 to 96 74 energy java micro benchmarks scientific application automatic refactoring of component based software by detecting and eliminating bad smells a search based approach copyright 2016 by scitepress science and technology publications lda all rights reserved refactoring has been proposed as a de facto behavior preserving mean to eliminate bad smells however manually determining and performing useful refactorings is a though challenge because seemingly useful refactorings can improve some aspect of a software while making another aspect worse therefore it has been proposed to view object oriented automated refactoring as a search based technique nevertheless the review of the literature shows that automated refactoring of component based software has not been investigated yet recently a catalogue of component relevant bad smells has been proposed in the literature but there is a lack of component relevant refactorings in this paper we propose detection rules for component relevant bad smells as well as a catalogue of component relevant refactorings then we rely on these two elements to propose a search based approach for automated refactoring of component based software systems by detecting and eliminating bad smells finally we experiment our approach on a medium sized component based software and we assess the efficieny and accuracy of our approach automatic refactoring bad smells component based software engineering genetic algorithm search based software engineering towards rule based detection of design patterns in model transformations springer international publishing ag 2016 model transformations are at the very heart of the model driven engineering paradigm as modern programs they are complex difficult to write and test and overall difficult to understand maintain and reuse in other paradigms such as object oriented programming design patterns play an important role for understanding and reusing code many works have been proposed to detect complete design pattern instances for understanding and documentation purposes but also partial design pattern instances for quality assessment and refactoring purposes recently a catalog of design patterns has been proposed for model transformations in this paper we propose to detect these design patterns in declarative model transformation programs our approach first detects the rules that may play a role in a design pattern then it ensures that the control flow over these rules corresponds to the scheduling scheme in the design pattern our preliminary evaluation shows that our detection mechanism is effective for both complete and partial instances of design patterns ceur workshop proceedings the proceedings contain 15 papers the topics discussed include local variables with compound names and comments as signs of fault prone java methods sustainability profiling of long living software systems towards improved adoption effectiveness of research tools in the real world predicting quality of service qos parameters using extreme learning machines with various kernel methods improving recall in code search by indexing similar codes under proper terms code coverage analysis of combinatorial testing trying to increase the mature use of agile practices by group development psychology training an experiment when why and for whom do practitioners detect technical debt an experience report using analytics to quantify interest of self admitted technical debt rework effort estimation of self admitted technical debt minimizing refactoring effort through prioritization of classes based on historical architectural and code smell information co existence of the technical debt and software legacy concepts and perspectives on managing technical debt a transition point and roadmap from dagstuhl 11th international workshop on data privacy management and security assurance dpm 2016 and 5th international workshop on quantitative aspects in security assurance qasa 2016 the proceedings contain 17 papers the special focus in this conference is on quantitative aspects in security assurance privacy protection identification authentication authorization security and secure applications the topics include metrics for transparency understanding bifurcation of slow versus fast cyber attackers decomposing global quantitative properties into local ones efficient sat based pre image enumeration for quantitative information flow in programs controlled management of confidentiality preserving relational interactions privacy preserving abuse detection in future decentralised online social networks searchable encryption for biometric identification revisited investigating the animation of application permission dialogs a case study of facebook isabelle modelchecking for insider threats managing and presenting user attributes over a decentralized secure name system a privacy risk analysis methodology a study from the data anonymization competition pwscup 2015 and refactoring preserves security improving the performance of many objective software refactoring technique using dimensionality reduction springer international publishing ag 2016 software quality assessment involves the measurement of a large number of software attributes referred to as quality metrics in most searchedbased software engineering processes an optimization algorithm is used to evaluate a certain number of maintenance operations by minimizing or maximizing these quality metrics one such process is software refactoring when the solution to the problem includes a large number of objectives various difficulties arise including the determination of the pareto optimal front and the visualization of the solutions however in some refactoring problem there may be redundancies among any two or more objectives in this paper we propose a new software refactoring approach named pca nsga ii many objective refactoring this approach is based on the pca nsga ii evolutionary multi objective algorithm and can overcome the curse of dimensionality by removing redundancies to retain conflicting objectives for further analysis improved statistical static timing analysis using refactored timing graphs 2016 american scientific publishers all rights reserved timing analysis is an important aspect in chip design which has the major attributes as speed and accuracy static timing analysis sta and statistical static timing analysis ssta are the two existing timing engines to serve this task the data handling in ssta is a crucial task as it determines the speed or arrival time calculation circuits are converted as timing graphs and refactoring technique is applied to reduce the accuracy reduction caused by the replicated literals we have developed a new methodology which uses refactoring technique with a view to speed up the computation parallel processing reduces the execution time certain nodes of the graph require serial processing hence an efficient data handling methodology was adopted on timing graphs the proposed model was tested on iscas 85 benchmark and an increase in speed was obtained a speed of 2 × was achieved for parallel processing and this idea can be further used in criticality computation data processing graphs kernel reconvergent paths statistical static timing analysis a framework to reduce redundancy in android test suite using refactoring objective test cases tend to be large in number as redundant test cases are generated due to the presence of code smells hence the need to reduce these smells methods statistical analysis this research adopts a proactive approach of reducing test cases by detecting the lazy class code smells based on the cohesion and dependency of the code and applying the inline class refactoring practices before test case generation thereby significantly avoiding redundant test cases from being generated findings the test cases generated from the original source code is compared to test cases from the refactored code test cases from the refactored code show a reduction of up to 33 3 in cyclomatic complexity compared to the original source code there was 8 2 improvement in the branch coverage of the generated test cases indicating the efficiency of the refactored code applications improvements from the results refactoring is an effective technique that can reduce redundant test cases while the focus is on test case reduction it also improves the quality of generated test cases in terms of its branch coverage android test suite code smell refactoring test case redundancy test cases identification of high conditional complexity in source code based on statistical analysis in order to identify the high conditional complexity in source code a novel approach based on statistical analysis is proposed according to the statistical analysis of two software metrics which are method mccabe s cyclomatic complexity mmcc and method average mccabe s cyclomatic complexity per code line mamcc in a large number of projects the probability density functions and cumulative distribution functions for describing distributions of these two metrics are obtained moreover a model for identifying high conditional complexity is built by choosing reasonable threshold of these metrics and this model can be used for preliminary screening the methods which have high mmcc and high mamcc the experimental results show that the proposed approach can identify some candidate methods which need to be refactored accurately conditional complexity cyclomatic complexity identification of refactoring opportunities software metrics statistical analysis maintaining unit tests during refactoring 2016 acm the meaning of source code is often described by unit tests as is for example the case in test driven software development test driven development is a principle in software engineering that requires developers to write tests for each method before implementing the method itself this ensures that for at least all public methods tests exist when performing a refactoring existing code is changed or restructured according to a predefined scheme after a refactoring is applied the alignment between the structure of source code and corresponding unit tests can be broken in this paper we describe different ways in which refactorings can impact the api coverage of unit tests we present our approach of tracking the modifications made by refactorings analyzing their influence on the existing test suite and giving advice to developers on how to update the test suite to migrate it for example tests may need to be moved or new tests developed in case a refactoring introduced new public methods our approach is applicable to all refactorings we conclude this paper by discussing the potential of the presented approach and of the preliminary tool support in the eclipse ide api coverage ast rewrite eclipse plug in junit refactoring structural alignment test driven development unit tests 1st international conference on information and communication technology for intelligent systems ictis 2015 the proceedings contain 60 papers the special focus in this conference is on ict based security and privacy applications the topics include pos word class based categorization of gurmukhi language stemmed stop words techniques and challenges in building intelligent systems ensemble recommendation for employability using cattell s sixteen personality factor model search logs mining an effective model for face detection using r g b color segmentation with genetic algorithm analysing performance disruption of manet under explicit flooding attack frequency an efficient agro meteorological model for evaluating and forecasting weather conditions using support vector machine simulation of a model for refactoring approach for parallelism using parallel computing tool box dynamic congestion analysis for better traffic management using social media an intelligent optimization approach to quarter car suspension system through rsm modeled equation meal based routing in wsn a comparative study of secure hash algorithms enhancing data security using aes encryption algorithm in cloud computing investigating the performance of energy efficient routing protocol for manet under pareto traffic double fully homomorphic encryption for tamper detection in incremental documents enhancement of gsm stream cipher security using variable taps mechanism and nonlinear combination functions on linear feedback shift registers implementation of taguchi method in the optimization of roller burnishing process parameter for surface roughness relationship strength based access control in online social networks and enhancement for power transfer loadability in long transmission line by reactive power compensation enhancing concept extraction from polish texts with rule management springer international publishing switzerland 2016 this paper presents a system for extraction of concepts from unstructured polish texts here concepts are understood as n grams whose words satisfy specific grammatical constraints detection and transformation of concepts to their normalized form are performed with rules defined in a language which combines elements of colored and fuzzy petri nets we apply a user friendly method for specification of samples of transformation patterns that are further compiled to rules to improve accuracy and performance we recently introduced rule management mechanisms which are based on two relations between rules partial refinement and covering the implemented methods include filtering with metarules and removal of redundant rules i e these covered by other rules we report results of experiments which aimed at extracting specific concepts actions using a ruleset refactored with the developed rule management techniques concepts extraction inflection nlp petri nets rules text mining unstructured text 8th international conference on software quality days swqd 2016 the proceedings contain 15 papers the special focus in this conference is on software engineering processes process modelling requirements engineering software architecture software estimation and development the topics include the disciplined agile process decision framework towards business process execution adequacy criteria an experience on applying process mining techniques to the tuscan port community system an expert based requirements effort estimation model using bayesian networks experiences from monitoring effects of architectural changes making the case for centralized software architecture management preventing composition problems in modular java applications deriving extract method refactoring suggestions for long methods the use of precision of software development effort estimates to communicate uncertainty integrating a lightweight risk assessment approach into an industrial development process fast feedback from automated tests executed with the product build and approach of a signature based single sign on proxy solution safer refactorings springer international publishing ag 2016 refactorings often require semantic correctness conditions that amount to software model checking however ides such as eclipse s java development tools implement far simpler checks on the structure of the code this leads to the phenomenon that a seemingly innocuous refactoring can change the behaviour of the program in this paper we demonstrate our technique of introducing runtime checks for two particular refactorings for the java programming language extract and move method and extract local variable these checks can in combination with unit tests detect changed behaviour and allow identification of which specific refactoring step introduced the deviant behaviour 23rd european conference on systems software and services process improvement eurospi 2016 the proceedings contain 28 papers the special focus in this conference is on spi the iso iec 29110 standard communication team issues in spi assessment safety critical environments gamifyspi supporting innovation and improvement the topics include refactoring software development process terminology through the use of ontology an approach to improve the requirements specification written in the natural language through the formal method establishing effective software development teams an exploratory model using a process assessment model to prepare for an iso iec 20000 1 certification towards automated traceability assessment through augmented lifecycle space measuring readiness for compliance situational factors in safety critical software development supporting cyber security based on hardware software interface definition pilot case study in finnish software company gamification proposal for defect tracking in software development process process improving by playing gamifying the onboarding process for novice software practitioners implementing best practices through business games a compact introduction to automotive engineering knowledge formal methods and functional safety forming a european innovation cluster as a think tank and knowledge pool and user orientation through open innovation and customer integration omitting code clones based on ranking the called clones 2016 praise worthy prize s r l all rights reserved code clones represent a stumbling blocking the way of having a more readable maintainable and less complicated source codes free of bugs and errors many studies had been proposed for detecting and omitting the four types of cloned codes based on pattern matching syntax parsing tree parsing and refactoring which is the most commonly used technique to remove the code clones from software while maintaining its original behavior in this paper we propose an automated refactoring technique and its correspondence algorithm to omit code clones of type 1 and type 2 the proposed technique performance was tested and evaluated using four open source java projects jfreechart jruby jcommon and apache ant the performance of the source codes was indicated based on number of metrics as the lines of code number of blank lines method s count and cyclomatic complexity before and after applying the proposed technique the experimentation results indicated that the proposed technique had showed superiority over the state of the art through omitting the cloned codes with the possibility of maintaining the stability and correctness of behavior of the source codes under consideration abstract syntax tree clone refactoring code clones damerau levenshtein distance 2nd ifip tc 2 central and east european conference on software engineering techniques cee set 2007 the proceedings contain 23 papers the special focus in this conference is on measurement processes uml and experiments the topics include formalisms in software engineering extending gqm by argument structures on metamodel based design of software metrics automatic transactions identification in use cases a collaborative method for reuse potential assessment in reengineering based product line adoption capable leader and skilled and motivated team practices to introduce extreme programming platform independent programming of data intensive applications using uml towards uml intensive framework for model driven development uml static models in formal approach alarming results from a comparative case study measuring the human factor with the rasch model empirical analysis of a distributed software development project extending software architecting processes with decision making activities a tool for supporting feature driven development in time role specific notification as formal means to balance agile practices in global software development settings an integrated approach for identifying relevant factors influencing software development productivity a framework for qos contract negotiation in component based applications a case study on the impact of refactoring on quality and productivity in an agile team support for cooperative design of end user tailorable software and considering the potential for further integration a programming interface for determining refactorings of object oriented software systems using clustering improving the quality of the software systems design is the most important issue during the evolution of object oriented software systems refactoring 4 is a process that helps to maintain the internal software quality during the whole software lifecycle a clustering approach for improving software systems design is introduced in 2 for the same purpose some clustering algorithms kred in 2 pamred in 8 hac in 3 that identify the appropriate refactorings for object oriented software systems were developed based on these approaches in this paper we aim at presenting a programming interface for determining refactorings of object oriented software systems using clustering rdi refactorings determination interface using this interface we can simply develop applications for determining refactorings of object oriented software systems using clustering an experiment using the designed interface is also presented 2007 ieee detection and correction of design defects in object oriented designs design defects come from poor design choices and have the effect of degrading the quality of object oriented designs therefore they present opportunities for improvements however design defects have not been precisely specified and there are few appropriate tools that allow their detection as well as their correction our goal is to provide a systematic method to specify systematically design defects precisely and to generate automatically detection and correction algorithms from their specifications the detection algorithms are based not only on metrics but also on semantical and structural properties whereas the correction algorithms are based on refactorings we apply and validate these algorithms on open source object oriented programs to show that our method allows a systematic specification a precise detection and a suitable correction of design defects antipatterns code smells design defects detection correction meta modelling refactorings specification migrating object oriented code to aspect oriented programming aspect oriented programming aop is a new programming paradigm that offers a novel modularization unit for the crosscutting concerns functionalities originally spread across several modules and tangled with each other can be factored out into a single separate unit called an aspect we investigated automated techniques that can be used to support the migration of existing object oriented programming oop code to aop to migrate an application to the new paradigm a preliminary identification of the crosscutting concerns is required aspect mining then refactoring is applied to transform the scattered concerns into aspects the proposed methods have been assessed on case studies for a total of more than half a million lines of code 2007 ieee size and frequency of class change from a refactoring perspective a previous study by bieman et al investigated whether large object oriented classes were more susceptible to change than smaller classes the measure of change used in the study was the frequency with which the features of a class had been changed over a specific period of time from a refactoring perspective the frequency of class change is of value but even for a relatively simple refactoring such as rename method multiple classes may undergo minor modification without any net increase in class and system size in this paper we suggest that the combination of versions of a class and number of added lines of code in the bad code smell detection process may give a better impression of which classes are most suitable candidates for refactoring as such effort in detecting bad code smells should apply to classes with a high growth rate as well as a high change frequency to support our investigation data relating to changes from 161 java classes was collected results concluded that it is not necessarily the case that large classes are more change prone than relatively smaller classes moreover the bad code smell detection process is informed by using the combination of change frequency and class size as a heuristic 2007 ieee loc refactoring version toward an implementation of the form template method refactoring this paper presents an implementation of the form template method refactoring this transformation has not been automated yet but has many similarities with other transformations such as clone detection and removal or method extraction forming a template method is a difficult process because it has to deal with code statements directly few abstractions and algorithms have been investigated yet compared to transformations dealing with higher level aspects such as the classes methods fields and their relations we present a new algorithm that performs this transformation in a semi automated way on java programs we state the difficulties inherent to this transformation and propose solutions to handle them 2007 ieee declarative object identity using relation types object oriented languages define the identity of an object to be an address based object identifier the programmer may customize the notion of object identity by overriding the equals and hashcode methods following a specified contract this customization often introduces latent errors since the contract is unenforced and at times impossible to satisfy and its implementation requires tedious and error prone boilerplate code relation types are a programming model in which object identity is defined declaratively obviating the need for equals and hashcode methods this entails a stricter contract identity never changes during an execution we formalize the model as an adaptation of featherweight java and implement it by extending java with relation types experiments on a set of java programs show that the majority of classes that override equals can be refactored into relation types and that most of the remainder are buggy or fragile springer verlag berlin heidelberg 2007 mining software evolution to predict refactoring can we predict locations of future refactoring based on the development history in an empirical study of open source projects we found that attributes of software evolution data can be used to predict the need for refactoring in the following two months of development information systems utilized in software projects provide a broad range of data for decision support versioning systems log each activity during the development which we use to extract data mining features such as growth measures relationships between classes the number of authors working on a particular piece of code etc we use this information as input into classification algorithms to create prediction models for future refactoring activities different state of the art classifiers are investigated such as decision trees logistic model trees propositional rule learners and nearest neighbor algorithms with both high precision and high recall we can assess the refactoring proneness of object oriented systems although we investigate different domains we discovered critical factors within the development life cycle leading to refactoring which are common among all studied projects 2007 ieee api evolution support with diff catchup refactoring is an important activity in the evolutionary development of object oriented software systems several ides today support the automated application of some refactorings at the same time there is substantial on going research aimed at developing support for deciding when and how software should be refactored and for estimating the effect of the refactoring on the quality requirements of the software on the other hand understanding the refac torings in the evolutionary history of a software system is essential in understanding its design rationale which might be very helpful in assisting future maintenance and evolution tasks the jdevan tool supports a comprehen sive refactoring analysis process including the extraction of logical design elements and relations from the system s code the recovery of design level changes from one version to the next the identification of refactorings as compo sitions of such changes and the interactive visualization and analysis of the recovered changes in this paper we discuss jdevan method and argue for its effectiveness with two case studies on realistic open source object oriented software in the context of which we show how the recovered refactoring knowledge may be used to guide future development 2007 ieee d 2 10 g object oriented design methods d 2 2 eprogrammer workbench d 2 3 coding tools and techniques d 2 3 a object oriented programming object oriented programming refactoring restructuring software systems using clustering in this paper we are focusing on the problem of restructuring object oriented software systems using clustering techniques refactoring 1 is one major issue to improve the design of software systems increasing the internal software quality this paper aims at introducing a new k medoids based clustering algorithm that can be used for improving the design of software systems by identifying the needed refactorings the algorithm uses a measure that evaluates a software system design clustering 2 is used in order to recondition the class structure of a software system the proposed approach can be useful for assisting software engineers in their daily works of refactoring software systems we evaluate our approach using the open source case study jhotdraw 3 illustrating the advantages of our approach in comparison with existing approaches 2007 ieee clustering refactoring system design improving predictive models of cognitive complexity using an evolutionary computational approach a case study the development of software is a human endeavor and program comprehension is an important factor in software maintenance predictive models can be used to identify software components as potentially problematic for the purpose of future maintenance such modules could lead to increased development effort and as such may be in need of mitigating actions such as refactoring or assigning more experienced developers source code metrics can be used as input features to classifiers however there exist a large number of structural measures that capture different aspects of coupling cohesion inheritance complexity and size in machine learning feature selection is the process of identifying a subset of attributes that improves a classifier s performance this paper presents initial results when using a genetic algorithm as a method of improving a classifier s ability to discover cognitively complex classes that degrade program understanding copyright 2007 national research council canada dean jin scheduling of conflicting refactorings to promote quality improvement software refactoring is to restructure object oriented software to improve its quality especially extensibility reusability and maintainability while preserving its external behaviors for a special software system there are usually quite a few refactorings available at the same time but these refactorings may conflict with each other in other words carrying out a refactoring may disable other refactorings consequently only a subset of the available refactorings can be applied together and which refactorings will be applied depends on the schedule application order of the refactorings furthermore carrying out different subsets of the refactorings usually leads to different improvement of software quality as a result in order to promote the improvement of software quality refactorings should be scheduled rationally however how to schedule refactorings is rarely discussed usually software engineers carry out refactorings immediately when they are found out they do not wait until all applicable refactorings are found out and scheduled in other words the refactorings are not scheduled explicitly and conflicts among them are not taken into consideration though more and more refactorings are formalized and automated by refactoring tools refactoring tools apply refactorings usually in a nondeterministic fashion in random in this paper we propose a scheduling approach to schedule conflicting refactorings to promote the improvement of software quality achieved by refactorings conflicts among refactorings are detected and then a scheduling model is presented and then a heuristic algorithm is proposed to solve the scheduling model results of experiments suggest that the proposed scheduling approach is effective in promoting the improvement of software quality copyright 2007 acm conflict quality schedule software refactoring the crss metric for package design quality package design is concerned with the determining the best way to partition the classes in a system into subsystems a poor package design can adversely affect the quality of a software system in this paper we present a new metric class reachability set size crss the distribution of which can be used to determine if the relationships between the classes in a system preclude it from a good package design we compute crss distributions for programs in a software corpus in order to show that some real programs are precluded in this way also we show how the crss metric can be used to identify candidates for refactoring so that the potential package structure of a system can be improved copyright 2007 australian computer society inc 13th americas conference on information systems amcis 2007 volume 2 the proceedings contain 68 papers the special focus in this conference is on information systems business improvements and mobile technologies in business in america the topics include is professionals assess the usefulness of the four most common is courses mastery level learning and the art of database design is curriculum recommendations for web courses based on current technology use by fortune 400 companies exploring technology frames through interview narratives an empirical study examining the usage and perceived importance of xp practices an integrated framework for code reuse and refactoring in extreme programming development of an information technology audit process quality framework the role of diversity and technology in global virtual teams the impacts of electronic collaboration and information exploitation capability on firm performance leader delegation task significance and trust in global software development teams a facilitators perspective on successful virtual communities of practice the role of it human capability in knowledge transfer process under it outsourcing situations an agent based reverse pricing model for reducing bullwhip effect in supply chains multi dimensional data visualization techniques for exploring financial performance data classification algorithm sensitivity to training data with non representative attribute noise the roles of positive and negative utility in predicting online wine purchase behaviour the moderating role of perceived effectiveness of third party control on trust and online purchasing intentions and estimating risk in information technology projects inspecting automated test code a preliminary study testing is an essential part of an agile process as test is automated and tends to take the role of specifications in place of documents however whenever test cases are faulty developers time might be wasted to fix problems that do not actually originate in the production code because of their relevance in agile processes we posit that the quality of test cases can be assured through software inspections as a complement to the informal review activity which occurs in pair programming inspections can thus help the identification of what might be wrong in test code and where refactoring is needed in this paper we report on a preliminary empirical study where we examine the effect of conducting software inspections on automated test code first results show that software inspections can improve the quality of test code especially the repeatability attribute the benefit of software inspections also apply when automated unit tests are created by developers working in pair programming mode springer verlag berlin heidelberg 2007 automated testing empirical study pair programming refactoring software inspection unit test model driven engineering languages and systems 10th international conference models 2007 proceedings the proceedings contain 46 papers the topics discussed include reconciling tggs with qvt guided development with multiple domain specific languages an empirical study of the impact of ocl smells and refactorings on the understandability of ocl specifications on metamodeling in megamodels improving inconsistency resolution with side effect evaluation and costs model composition in product lines and feature interaction detection using critical pair analysis automated semantic analysis of design models piecewise modelling with state subtypes deriving operation contracts from uml class diagrams model driven approach for managing human interface design life cycle integrating heterogeneous tools into model centric development of interactive applications a business process driven approach for generating e commerce user interfaces and integrated definition of abstract and concrete syntax for textual languages icsm 2007 proceedings of the 2007 ieee international conference on software maintenance the proceedings contain 72 papers the topics discussed include the inevitable stability of software change mining the lexicon used by programmers during software evolution evidence based analysis and inferring preconditions for bug detection feature location and extraction using landmarks and barriers matching control flow of program versions tracing model elements design recovery and maintenance of build systems multi objective genetic algorithm to support class responsibility assignment a maintainable software architecture for fast and modular bioinformatics sequence search applying interface contract mutation in regression testing of component based software automated refactoring of legacy java software to enumerated types computation of static execute after relation with applications to software maintenance and automatic test generation from gui applications for testing web services jdeodorant identification and removal of feature envy bad smells in this demonstration we present an eclipse plug in that identifies feature envy bad smells in java projects and resolves them by applying the appropriate move method refactorings the main contribution is the ability to pre evaluate the impact of all possible move refactorings on design quality and apply the most effective one 2007 ieee feature diagrams and logics there and back again feature modeling is a notation and an approach for modeling commonality and variability in product families in their basic form feature models contain mandatory optional features feature groups and implies and excludes relationships it is known that such feature models can be translated into propositional formulas which enables the analysis and configuration using existing logicbased tools in this paper we consider the opposite translation problem that is the extraction of feature models from propositional formulas we give an automatic and efficient procedure for computing a feature model from a formula as a side effect we characterize a class of logical formulas equivalent to feature models and identify logical structures corresponding to their syntactic elements while many different feature models can be extracted from a single formula the computed model strives to expose graphically the maximum of the original logical structure while minimizing redundancies in the representation the presented work furthers our understanding of the semantics of feature modeling and its relation to logics opening avenues for new applications in reverse engineering and refactoring of feature models 2007 ieee analysis of measurement set qualitative characteristics for state estimation purposes the paper proposes a new tool for real time assessment of measurement sets in the context of power system state estimation this tool incorporates many functions including observability analysis and restoration as well as identification of critical measurements and critical sets using only network topology data the proposed methodology updates the qualitative characteristics of the current available measurement set in real time the identification of critical measurements and sets is done using only network topology and is completed before running any state estimation mapping the system states and using information concepts a new state space is obtained where the relationship information between measurements and states is straightforward this map is easily found via triangular factorisation of the jacobian matrix starting from a basecase measurement set every time a snapshot of measurements has to be analysed only refactorisation has to be carried out sparse matrix techniques speed up the process the method was tested in the ieee 14 bus system as well as in the brazilian 383 bus system proving to be reliable fast easy to implement and suitable for real time operation the institution of engineering and technology 2007 simultaneous modification support based on code clone analysis maintaining software systems becomes more difficult as their size and complexity increase one factor that makes software maintenance more difficult is the presence of code clones a code clone is defined as a code fragment occurring more than once in identical or similar form into a software system for example the presence of code clones is a big factor of overlooking some places that should be modified simultaneously one technique that helps the number of code clones is refactoring there are several research efforts that provide support to refactor code clones but unfortunately some code clones cannot or should not be refactored ex stereotyped process absence of abstraction functionality performance enhancement in order to support maintaining the consistency among code clones we propose a simultaneous modification support method given a software system firstly a maintainer identifies a code fragment that must be modified then only the code clones between the identified code fragment and the source files of the software system are detected we developed a simultaneous modification support tool libra and applied it to open source software systems the results showed that libra was a good searching tool as much as grep which is a useful tool of unix 2007 ieee a survey of reasoning in parallelization we elaborate on reasoning in contemporary semi automatic parallelizing refactoring as the main contribution we summarize contemporary approaches and show that all attempts to reason in parallelization thus far have amounted to local code analysis given data and control dependencies we conclude that by retaining this perspective only parallelization continues to exploit merely a subset of the reasoning methods available today and is likely to remain limited to address this problem we suggest to expand the local analyses such that they take seriously relations between individual local parallelizing transformations we argue that such a coupling allows to process sparser parallelizable constructs such as producer consumer coordination we identify questions to be addressed to put this principle into action and report on going work on reasoning mechanisms able to support this 2007 ieee use of a genetic algorithm to identify source code metrics which improves cognitive complexity predictive models in empirical software engineering predictive models can be used to classify components as overly complex such modules could lead to faults and as such may be in need of mitigating actions such as refactoring or more exhaustive testing source code metrics can be used as input features for a classifier however there exist a large number of measures that capture different aspects of coupling cohesion inheritance complexity and size in a large dimensional feature space some of the metrics may be irrelevant or redundant feature selection is the process of identifying a subset of the attributes that improves a classifier s discriminatory performance this paper presents initial results of a genetic algorithm as a feature subset selection method that enhances a classifier s ability to discover cognitively complex classes that degrade program understanding 2007 ieee encapsulating objects with confined types object oriented languages provide little support for encapsulating objects reference semantics allows objects to escape their defining scope and the pervasive aliasing that ensues remains a major source of software defects this paper presents kacheck j a tool for inferring object encapsulation properties of large java programs our goal is to develop practical tools to assist software engineers thus we focus on simple and scalable techniques kacheck j is able to infer confinement the property that all instances of a given type are encapsulated in their defining package this simple property can be used to identify accidental leaks of sensitive objects as well as for compiler optimizations we report on the analysis of a large body of code and discuss language support and refactoring for confinement 2007 acm tracking code clones in evolving software code clones are generally considered harmful in software development and the predominant approach is to try to eliminate them through refactoring however recent research has provided evidence that it may not always be practical feasible or cost effective to eliminate certain clone groups we propose a technique for tracking clones in evolving software our technique relies on the concept of abstract clone region descriptors crd which describe clone regions within methods in a robust way that is independent from the exact text of the clone region or its location in a file we present our definition of crds and describe a complete clone tracking system capable of producing crds from the output of a clone detection tool notify developers of modifications to clone regions and support the simultaneous editing of clone regions we report on two experiments and a case study conducted to assess the performance and usefulness of our approach 2007 ieee relationship between age and refractive predictability of excimer laser in situ keratomileusis objective to explore the relationship between age and refractive predictability of excimer laser in situ keratomileusis lasik for the correction of myopia design retrospective case series participants 362 patients 703 eyes who had performed lasik methods according to the age patients were divided into four groups ≤30y 31 34y 35 39y and ≥40y their preoperative and postoperative refractive powers examined with automatic refactor as well as manifest optometry were analysed and followed up from 6 months to 2 years according to pre operative refractive power patietns were divided into low and moderate myopia group ≤ 6 00d high myopia group 6 25 ∼ 12 00d and super high myopia group ≥ 12 25d the eyes with refractive power at post operative 2 years ≥ 1 00d were regressive eyes main outcome measures refractive error before surgery intended residual refractive power and 3 6 12 24 months post operative refractive powers results there were no significant differences between intended residual refractive powers and refractive powers at post operative 6 month in 3 groups 40y p 0 059 0 369 0 546 while there were significant differences in the group of ≥40y p 0 001 there were significant differences on the rate of regression among groups according or refractive power a significant positive correlation was found between regression and refractive error before surgery regression in 57 83 patients was found among post operative 6 months conclusions the refractive predictability of lasik was influenced by age refractive error and postoperative time for older high myopic patients indication for lasik should be well known strictly attempted correction should be adjusted according to age the degree of myopia habit of eye using to get more satisfactory effects age excimer laser in situ keratomileusis refractive power automatic inference of structural changes for matching across program versions mapping code elements in one version of a program to corresponding code elements in another version is a fundamental building block for many software engineering tools existing tools that match code elements or identify structural changes refactorings and api changes between two versions of a program have two limitations that we overcome first existing tools cannot easily disambiguate among many potential matches or refactoring candidates second it is difficult to use these tools results for various software engineering tasks due to an unstructured representation of results to overcome these limitations our approach represents structural changes as a set of high level change rules automatically infers likely change rules and determines method level matches based on the rules by applying our tool to several open source projects we show that our tool identifies matches that are difficult to find using other approaches and produces more concise results than other approaches our representation can serve as a better basis for other software engineering tools 2007 ieee corpus refactoring a feasibility study background most biomedical corpora have not been used outside of the lab that created them despite the fact that the availability of the gold standard evaluation data that they provide is one of the rate limiting factors for the progress of biomedical text mining data suggest that one major factor affecting the use of a corpus outside of its home laboratory is the format in which it is distributed this paper tests the hypothesis that corpus refactoring changing the format of a corpus without altering its semantics is a feasible goal namely that it can be accomplished with a semi automatable process and in a time effcient way we used simple text processing methods and limited human validation to convert the protein design group corpus into two new formats wordfreak and embedded xml we tracked the total time expended and the success rates of the automated steps results the refactored corpus is available for download at the bionlp sourceforge website http bionlp sourceforge net the total time expended was just over three person weeks consisting of about 102 hours of programming time much of which is one time development cost and 20 hours of manual validation of automatic outputs additionally the steps required to refactor any corpus are presented conclusion we conclude that refactoring of publicly available corpora is a technically and economically feasible method for increasing the usage of data already available for evaluating biomedical language processing systems 2007 johnson et al licensee biomed central ltd analysing refactoring dependencies using graph transformation refactoring is a widely accepted technique to improve the structure of object oriented software nevertheless existing tool support remains restricted to automatically applying refactoring transformations deciding what to refactor and which refactoring to apply still remains a difficult manual process due to the many dependencies and interrelationships between relevant refactorings in this paper we represent refactorings as graph transformations and we propose the technique of critical pair analysis to detect the implicit dependencies between refactorings the results of this analysis can help the developer to make an informed decision of which refactoring is most suitable in a given context and why we report on several experiments we carried out in the agg graph transformation tool to support our claims springer verlag 2007 agg critical pair analysis dependency analysis graph transformation refactoring bridging the gap between aspect mining and refactoring aspect mining techniques help to identify crosscutting structure that could potentially be modularized through object oriented oo or aspect oriented refactoring ao this paper describes a case study in which we used aspect mining techniques to identify and refactor crosscutting concerns using aspect oriented programming we observed that in our case there were many subtle variations in the implementation of the concerns that made them non trivial to modularize with ao refactoring in the end we solved our modularization problem using traditional oo refactoring we conclude that there exists an important gap between the identification of crosscutting concerns and the technologies available to mitigate the problem copyright 2007 acm high impact refactoring based on architecture violations software refactoring has been identified as a key technique for the maintenance and evolution of object oriented system most interesting are high impact refactorings that is refactorings that have a strong impact on the quality of the system s architecture bad smells and code metrics have been suggested as means for identifying refactormg needs according to our experience these techniques are useful yet in order to spot opportunities for high impact refactorings they should be complemented with the analysis of architectural violations the subject of this report is a mid sized java enterprise application from the telecommunications domain whose functionality had to be radically extended we show how we combined several tools and techniques to identify opportunities for high impact refactorings and discuss the resulting architecture the refactoring process tool support as well as related experiences 2007 ieee proceedings csmr 2007 11th european conference on software maintenance and reengineering software evolution in complex software intensive systems the proceedings contain 44 papers the topics discussed include a case study of defect density and charge density and their progress over time consistently incorporating changes to evolve transition based systems a probabilistic approach to predict changes in object oriented software systems towards automatic restructuring of object oriented systems a feature oriented adaptive component model for dynamic evolution a maintenance oriented framework for software components characterization metamodel based inference of inter model correspondence how clones are maintained an empirical study exploring inter module relationships in evolving software systems the dynamic function coupling metric and its use in software evolution online construction of dynamic object process graphs and high impact refactoring based on architecture violations an empirical study of the bad smells and class error probability in the post release object oriented system evolution bad smells are used as a means to identify problematic classes in object oriented systems for refactoring the belief that the bad smells are linked with problematic classes is largely based on previous metric research results although there is a plethora of empirical studies linking software metrics to errors and error proneness of classes in object oriented systems the link between the bad smells and class error probability in the evolution of object oriented systems after the systems are released has not been explored there has been no empirical evidence linking the bad smells with class error probability so far this paper presents the results from an empirical study that investigated the relationship between the bad smells and class error probability in three error severity levels in an industrial strength open source system our research which was conducted in the context of the post release system evolution process showed that some bad smells were positively associated with the class error probability in the three error severity levels this finding supports the use of bad smells as a systematic method to identify and refactor problematic classes in this specific context 2006 elsevier inc all rights reserved bad smells design evolution empirical study object oriented design open source software software metrics detecting similar java classes using tree algorithms similarity analysis of source code is helpful during development to provide for instance better support for code reuse consider a development environment that analyzes code while typing and that suggests similar code examples or existing implementations from a source code repository mining software repositories by means of similarity measures enables and enforces reusing existing code and reduces the developing effort needed by creating a shared knowledge base of code fragments in information retrieval similarity measures are often used to find documents similar to a given query document this paper extends this idea to source code repositories it introduces our approach to detect similar java classes in software projects using tree similarity algorithms we show how our approach allows to find similar java classes based on an evaluation of three tree based similarity measures in the context of five user defined test cases as well as a preliminary software evolution analysis of a medium sized java project initial results of our technique indicate that it 1 is indeed useful to identify similar java classes 2 successfully identifies the ex ante and ex post versions of refactored classes and 3 provides some interesting insights into within version and between version dependencies of classes within a java project copyright 2006 acm change analysis software evolution software repositories tree similarity measures does god class decomposition affect comprehensibility continuous alterations and extensions of a software system introduce so called god classes accumulating ever more responsibilities as god classes make essential steps in program comprehension harder it is expected that effective and efficient techniques to resolve them will facilitate future maintenance tasks this work reports on a laboratory experiment with 63 computer science students in which we verified whether the decomposition of a god class using well known refactorings can affect comprehensibility of the relevant code part five alternative god class decompositions were derived through application of refactorings by which the responsibilities of a natural god class were increasingly split into a number of collaborating classes our results indicate that the derived class decompositions differed significantly with regard to the ability of students to map attributes in the class hierarchy to descriptions of the problem domain moreover this effect has been found to interact with the institution in which the participants were enrolled confirming that comprehensibility is a subjective notion for which we have to take into account people s skills and expectations this work indicates that improving comprehensibility is within the grasp of a single maintainer preparing for future change requests by redistributing the responsibilities of a god class using well known refactorings comprehension decomposition refactoring refactoring detection based on umldiff change facts queries refactoring is an important activity in the evolutionary development of object oriented software systems several ides today support the automated application of some refactorings at the same time there is substantial on going research aimed at developing support for deciding when and how software should be refactored and for estimating the effect of the refactoring on the quality requirements of the software on the other hand understanding the refactorings in the evolutionary history of a software system is essential in understanding its design rationale yet only very limited support exists for detecting refactorings in this paper we present our approach for detecting refactorings by analyzing the system evolution at the design level we evaluate our method with case studies examining two realistic examples of object oriented software 2006 ieee towards a catalogue of refactorings and code smells for aspectj in this paper we contribute to the characterisation of a programming style specific to aspect oriented programming for this purpose we present a collection of refactorings for aspect oriented source code comprising refactorings to enable extraction to aspects of crosscutting concerns from object oriented legacy code the subsequent tidying up of the extracted aspects and factoring out of common code from similar aspects to superaspects the second group of refactorings is documented in detail in addition we propose some new aspect oriented code smells including one smell that is specific to aspect modules we also propose a reinterpretation of some of the traditional object oriented code smells in the light of aspect orientation to detect the presence of crosscutting concerns springer verlag berlin heidelberg 2006 from bad smells to refactoring metrics smoothing the way this chapter presents a study on the relation of refactoring bad smells and metrics the notions of refactoring and bad smells are revised as well as metrics that can be used as guides in the refactoring process connection among those metrics the usual flaws that could be suggested by them and the required corrective actions to reduce or erase these flaws are analyzed the usual flaws can be described in terms of bad smells and the corrective actions in terms of the refactoring operations suggested by each bad smell then we can go from metrics to bad smells and from this to refactoring the chapter also describes solutions for tool support in a language independent manner in this sense it describes the tool architecture which can be defined as metamodel centered a metamodel representing a family of languages is defined as well as framework based solutions for collecting metrics as well as for a refactoring engine and repository these solutions allow reusing the effort on a wide family of object oriented languages the developed frameworks were instantiated to work on instances of our own metamode l in addition to this it also describes how to use the approach and its support with other metamodels finally a case study on the use of metrics in bad smells detection is presented 2007 idea group inc refactoring practice how it is and how it should be supported an eclipse case study refactoring is an important activity in the evolutionary development of object oriented software systems yet several questions about the practice of refactoring remain unanswered such as what fraction of code modifications are refactorings and what are the most frequent types of refactorings to gain some insight in this matter we conducted a detailed case study on the structural evolution of eclipse an integrated development environment ide and a plugin based framework our study indicates that 1 about 70 of structural changes may be due to refactorings 2 for about 60 of these changes the references to the affected entities in a component based application can be automatically updated by a refactoring migration tool if the relevant information of refactored components can be gathered through the refactoring engine and 3 state of the art ides such as eclipse support only a subset of commonly applied low level refactorings and lack support for more complex ones which are also frequent based on our findings we draw some conclusions on high level design requirements for a refactoring based development environment 2006 ieee identifying refactoring opportunities by identifying dependency cycles the purpose of refactoring is to improve the quality of a software system by changing its internal design so that it is easier to understand or modify or less prone to errors and so on one challenge in performing a refactoring is quickly determining where to apply it we present a tool jepends that analyses the source code of a system in order to identify classes as possible refactoring candidates our tool identifies dependency cycles among classes because long cycles are detrimental to understanding testing and reuse we demonstrate our tool on a widelydownloaded open source medium sized java program and show how cycles can be eliminated through a simple refactoring copyright 2006 australian computer society inc common refactorings a dependency graph and some code smells an empirical study of java oss refactoring as a software engineering discipline has emerged over recent years to become an important aspect of maintaining software refactoring refers to the restructuring of software according to specific mechanics and principles in this paper we describe an analysis of the results from a tool whose purpose was to identify and extract refactorings from seven open source java systems in particular we analyzed the mechanics of the most commonly and least commonly applied refactorings to try and account for their frequency results showed the most common refactorings of the fifteen coined a gang of six to be generally those with a high in degree and low out degree when mapped on a dependency graph the same refactorings also featured strongly in the remedying of bad code smells remarkably and surprisingly inheritance and encapsulation based refactorings were found to have been applied relatively infrequently we offer explanations for why this may be the case the paper thus identifies core refactorings central to many of the changes made by developers on open source systems while we can not guarantee that developers consciously undertake refactoring in any sense the empirical results demonstrate that simple renaming and moving fields methods between classes are common components of open source system re engineering from a wider software engineering perspective knowledge of what a modification will incur in likely sub tasks is of value to developers whether working on open source or other forms of software copyright 2006 acm code smells refactoring taxonomy testing drivers for software refactoring decisions this paper presents an empirical study of drivers for software refactoring decisions we studied the refactoring decisions made by 37 students evaluating ten methods of a purposefully constructed java program the decision rationales reported by the evaluators were coded to identify the drivers behind the decisions the identified drivers were categorized into structure documentation visual representation and general drivers the evaluators had conflicting opinions both regarding the internal quality of the methods and refactoring decisions complex code problems were detected only by experienced evaluators using regression analysis we looked at the predictive value of drivers explaining the refactoring decisions the most salient driver leading to a favourable refactoring decision was method size this study provides information of the refactoring decisions and helps form a basis for creating code problem detectors by comparing automatic detection and the identified drivers we gained understanding of code problems that are difficult or impossible to detect automatically for example poor algorithm issues detected only by experienced developers and code problems for which the human eye surpasses automatic detection indicate good areas for developer education copyright 2006 acm code smells evolvability maintainability qualitative analysis refactoring ripcord rapid interface prototyping for cordless devices mobile devices such as cellular phones are indispensable in our daily life the success and penetration of the market of mobile services and applications does not only depend on good innovative ideas but also on their usability therefore several endeavors have been made to tackle these problems in order to provide suitable usability testing methods for user interfaces but traditional testing methods cannot always be extended to mobile devices directly in contrast to the widely standardized and static testing setup for desktop pcs the variety of physical device specific characteristics as well as the highly dynamic context of use 5 influences these methods in this paper we propose a novel approach for prototyping and testing mobile applications and services it enables testing user interfaces and recording the interaction within context of use in early stages of the product development and therefore allows determining conceptional or design flaws before they can cause cost intensive corrections or even refactoring of the product besides its direct applicability this approach allows us to elaborate if and how classical usability testing methods can be transferred to mobile devices and how they are influenced by the device specific characteristics copyright 2006 acm mobile phones rapid prototyping usability testing identifying good architectural design alternatives with multi objective optimization strategies architecture trade off analysis methods are appropriate techniques to evaluate design decisions and design alternatives with respect to conflicting quality requirements however the identification of good design alternatives is a time consuming task which is currently performed manually to automate this task this paper proposes to use evolutionary algorithms and multi objective optimization strategies based on architecture refactorings to identify a sufficient set of design alternatives this approach will reduce development costs and improve the quality of the final system because an automated and systematic search will identify more and better design alternatives architecture refactorings architecture trade off analysis dependability multi objective optimization identifying refactorings from source code changes software has been and is still mostly refactored without tool support moreover as we found in our case studies programmers tend not to document these changes as refactorings or even worse label changes as refactorings although they are not in this paper we present a technique to detect changes that are likely to be refactorings and rank them according to the likelihood the evaluation shows that the method has both a high recall and a high precision it finds most of the refactorings and most of the found refactoring candidates are really refactorings 2006 ieee phoenix based clone detection using suffix trees a code clone represents a sequence of statements that are duplicated in multiple locations of a program clones often arise in source code as a result of multiple cut paste operations on the source or due to the emergence of crosscutting concerns programs containing code clones can manifest problems during the maintenance phase when a fault is found or an update is needed on the original copy of a code section all similar clones must also be found so that they can be fixed or updated accordingly the ability to detect clones becomes a necessity when performing maintenance tasks however if done manually clone detection can be a slow and tedious activity that is also error prone a tool that can automatically detect clones offers a significant advantage during software evolution with such an automated detection tool clones can be found and updated in less time moreover restructuring or refactoring of these clones can yield better performance and modularity in the program this paper describes an investigation into an automatic clone detection technique developed as a plug in for microsoft s new phoenix framework our investigation finds function level clones in a program using abstract syntax trees asts and suffix trees an ast provides the structural representation of the code after the lexical analysis process the ast nodes are used to generate a suffix tree which allows analysis on the nodes to be performed rapidly we use the same methods that have been successfully applied to find duplicate sections in biological sequences to search for matches on the suffix tree that is generated which in turn reveal matches in the code clone detection code clones software analysis suffix trees proceedings of the isca 15th international conference on software engineering and data engineering sede 2006 the proceedings contain 53 papers the topics discussed include traceability for managing evolutionary change mercury a process management system based on the agent technology management support of interorganizational cooperative software development processes based on dynamic process views agile plan refactoring extending reverse inheritance a strategy to integrate legacy systems debugging with software visualization and contract discovery a method to improve software testability alternative approach to utilize software defect reports estimating software reliability with static analysis techniques software defect fractal description operational and program schemas a framework for requirements elicitation techniques selection the effects of requirements and task uncertainty on software product quality correctness as a relative gradual software property and remote sensing and prompting for early stage dementia patients a fast and reliable quadratic approach for q adjustments in fast decoupled load flow model the paper presents a new fast reliable and relatively simple decoupled quadratic load flow dqlf algorithm for q adjustments in power flow solutions q adjusted solutions are inevitable for reactive power planning and management studies for solving power flow problems the fast decoupled load flow fdlf is probably the most popular because of its efficiency but for q adjusted studies the matrix updating problem associated with b″ matrix remains unresolved refactorization of b″ matrix demands more cpu time the proposed approach eliminates formation and refactorization of b″ matrix for both well behaved and ill conditioned systems of q unadjusted and adjusted cases the new method minimizes the computational burden by solving for the busbar voltage magnitudes v using a non linear quadratic equation and it reduces the execution time significantly the solution of this non linear equation undoubtedly offers better solution than that of a linear version improved and reliable convergence on normal and ill conditioned system is expected enforcement of q limits is also very simple and effective the proposed algorithm also proved to handle large degrees of ill conditioning in q adjusted studies compared to the standard fdlf model the performance of the proposed model is investigated by a number of case studies on ieee test systems 14 30 57 118 bus and results are reported for ieee 118 bus system the results indicate the established better convergence and reliability of the proposed model it is atleast 50 faster than the traditional fdlf model for q adjusted case studies copyright kth 2006 decoupled quadratic load flow dqlf fast decoupled load flow fdlf ill condition r factor model refactorings through rule based inconsistency resolution the goal of model driven engineering is to raise the level of abstraction by shifting the focus to models as a result complex software development activities move to the modelling level as well one such activity is model refactoring a technique for restructuring the models in order to improve some quality attributes of the models as a first contribution of this paper we argue and show that refactoring a model is enabled by inconsistency detection and resolution inconsistencies in or between models occur since models typically describe a software system from different viewpoints and on different levels of abstraction a second contribution of this paper is rule based inconsistency resolution which enables reuse of different inconsistency resolutions across model refactorings and manages the flow of inconsistency resolution steps automatically copyright 2006 acm description logics inconsistency management model refactoring rule based systems an approach to refactoring of executable uml models design erosion is one of the unavoidable effects of software evolution this destructive phenomenon occurs also in the context of executable uml models which are primary artefacts in agile mda software development methodology model refactorings are model transformations that can be applied with the aim of counteracting design erosion of uml models in this paper we present a systematic approach to specification of both executable uml model refactorings as well as associated bad smells in models the application of this method is illustrated on an exemplary refactoring and a related bad smell moreover we show how this transformation and detection of the bad smell can be implemented in telelogic tau a state of the art uml case tool copyright 2006 acm executable uml model refactoring refactoring tools and complementary techniques poorly designed software systems are difficult to understand and maintain modifying code in one place could lead to unwanted repercussions elsewhere due to high coupling adding new features can cause further quality degradation to the code if proper design and architectural concerns were not implemented development in a large enterprise system with such attributes will over time lead to a myriad of concerns unless the system is periodically overhauled or refactored in some way refactoring can aid the developer to improve the design of the code and to make it cleaner without changing its behaviour this study provides answers for some of the questions on refactoring a refactoring tool survey is given the ides surveyed include some of the most popular commercial and open source offerings from intellij s idea ibm s eclipse and sun s netbeans we also explain a way to automatically find targets for refactorings via automatic detection of code smells from static code analysis concerns on viewing compiler refactorings as a fully automated refactorings are raised we will perform a critical evaluation of refactoring by surveying these tools 2006 ieee search based determination of refactorings for improving the class structure of object oriented systems a software system s structure degrades over time a phenomenon that is known as software decay or design drift since the quality of the structure has major impact on the maintainability of a system the structure has to be reconditioned from time to time even if recent advances in the fields of automated detection of bad smells and refactorings have made life easier for software engineers this is still a very complex and resource consuming task search based approaches have turned out to be helpful in aiding a software engineer to improve the subsystem structure of a software system in this paper we show that such techniques are also applicable when reconditioning the class structure of a system we describe a novel search based approach that assists a software engineer who has to perform this task by suggesting a list of refactorings our approach uses an evolutionary algorithm and simulated refactorings that do not change the system s externally visible behavior the approach is evaluated using the open source case study jhotdraw copyright 2006 acm design heuristics evolutionary algorithms refactoring software metrics tool supported refactoring of existing object oriented code into aspects aspect oriented programming aop provides mechanisms for the separation of crosscutting concerns functionalities scattered through the system and tangled with the base code existing systems are a natural testbed for the aop approach since they often contain several crosscutting concerns which could not be modularized using traditional programming constructs this paper presents an automated approach to the problem of migrating systems developed according to the object oriented programming oop paradigm into aspect oriented programming aop a simple set of six refactorings has been defined to transform oop to aop and has been implemented in the aop migrator tool an eclipse plug in a set of enabling transformations from oop to oop complement the initial set of refactorings the paper presents the results of four case studies which use the approach to migrate selected crosscutting concerns from medium sized java programs in the range of 10k to 40k lines of code into equivalent programs in aspectj the case study results show the feasibility of the migration and indicate the importance of the enabling transformations as a preprocessing step 2006 ieee aspect oriented software development program transformation refactoring mptp 0 2 design implementation and initial experiments this paper describes the second version of the mizar problems for theorem proving mptp system and first experimental results obtained with it the goal of the mptp project is to make the large formal mizar mathematical library mml available to current first order automated theorem provers atps and vice versa and to boost the development of domain based knowledge based and generally ai based atp methods this version of mptp switches to a generic extended tptp syntax that adds term dependent sorts and abstract fraenkel terms to the tptp syntax we describe these extensions and explain how they are transformed by mptp to standard tptp syntax using relativization of sorts and deanonymization of abstract terms full mizar proofs are now exported and also encoded in the extended tptp syntax allowing a number of atp experiments this covers for example consistent handling of proof local constants and proof local lemmas and translating of a number of mizar proof constructs into the tptp formalism the proofs using second order mizar schemes are now handled by the system too by remembering and if necessary abstracting from the proof context the first order instances that were actually used these features necessitated changes in mizar in the mizar to tptp exporter and in the problem creating tools mizar has been reimplemented to produce and use natively a detailed xml format suitable for communication with other tools the mizar to tptp exporter is now just a xslt stylesheet translating the xml tree to the tptp syntax the problem creation and other mptp processing tasks are now implemented in about 1 300 lines of prolog all these changes have made mptp more generic more complete and more correct the largest remaining issue is the handling of the mizar arithmetical evaluations we describe several initial atp experiments both on the easy and on the hard mml problems sometimes assisted by machine learning it is shown that on the nonarithmetical problems countersatisfiability completions is no longer detected by the atp systems suggesting that the mizar deconstruction done by mptp is in this case already complete about every fifth nonarithmetical theorem is proved in a fully autonomous mode in which the premises are selected by a machine learning system trained on previous proofs in 329 of these cases the newly discovered proofs are shorter than the mml originals and therefore are likely to be used for mml refactoring this situation suggests that even a simple inductive or deductive system trained on formal mathematics can be sometimes smarter than mml authors and usable for general discovery in mathematics springer science business media inc 2007 atp mizar mml mpa mptp proof discovery re proving refactoring programs to secure information flows adding a sound information flow security policy to an existing program is a difficult task that requires major analysis of and changes to the program in this paper we show how refactoring programs into distinct components of high and low security is a useful methodology to aid in the production of programs with sound information flow policies our methodology proceeds as follows given a program with no information flow controls a program slicer is used to identify code that depends on high security inputs high security code so identified is then refactored into a separate component which may be accessed by the low security component via public method calls a security policy that labels input data and checks the output points can then enforce the desired end to end security property controlled information releases can occur at explicit declassification points if deemed safe the result is a well engineered program with explicit interfaces between components of different security levels copyright 2006 acm declassification information flow refactoring slicing a stability oriented business component refactoring method using bayesian analysis reusable components should be continuously refactored during the full lifecycle to modify those designs unsuitable to reuse and to improve reuse performance in this paper we proposed a stability oriented business component refactoring method using bayesian analysis before introduction on this method a unified feature oriented component model and its reuse mechanism are briefly proposed with the classification of component reuse styles modification levels in this method clear separation of stability is considered as the goal of refactoring to decrease reuse cost practical reuse data is utilized as the information source of refactoring and bayesian analysis method is adopted to calculate posterior distribution and estimation of a set of stability parameters by analyzing variation tendency of each parameter component designers can take three basic refactoring operations and ten concrete refactoring rules to reconfigure granularity and instantiation degree of components to realize reuse cost optimization in order to evaluate performance improvement before and after refactoring five metrics are addressed a practical case is compendiously shown to validate the effectiveness of this method with some qualitative comparisons with other refactoring methods in literatures 2006 asian network for scientific information bayesian analysis method component refactoring reuse cost optimization stability statistical reuse data adaptive star grammars we propose an extension of node and hyperedge replacement grammars called adaptive star grammars and study their basic properties a rule in an adaptive star grammar is actually a rule schema which via the so called cloning operation yields a potentially infinite number of concrete rules adaptive star grammars are motivated by application areas such as modeling and refactoring object oriented programs we prove that cloning can be applied lazily unrestricted adaptive star grammars are shown to be capable of generating every type 0 string language however we identify a reasonably large subclass for which the membership problem is decidable springer verlag berlin heidelberg 2006 applying and combining three different aspect mining techniques understanding a software system at source code level requires understanding the different concerns that it addresses which in turn requires a way to identify these concerns in the source code whereas some concerns are explicitly represented by program entities like classes methods and variables and thus are easy to identify crosscutting concerns are not captured by a single program entity but are scattered over many program entities and are tangled with the other concerns because of their crosscutting nature such crosscutting concerns are difficult to identify and reduce the understandability of the system as a whole in this paper we report on a combined experiment in which we try to identify crosscutting concerns in the jhotdraw framework automatically we first apply three independently developed aspect mining techniques to jhotdraw and evaluate and compare their results based on this analysis we present three interesting combinations of these three techniques and show how these combinations provide a more complete coverage of the detected concerns as compared to the original techniques individually our results are a first step towards improving the understandability of a system that contains crosscutting concerns and can be used as a basis for refactoring the identified crosscutting concerns into aspects springer science business media llc 2006 a measurement framework for object oriented software testability testing is an expensive activity in the development process of any software system measuring and assessing the testability of software would help in planning testing activities and allocating required resources more importantly measuring software testability early in the development process during analysis or design stages can yield the highest payoff as design refactoring can be used to improve testability before the implementation starts this paper presents a generic and extensible measurement framework for object oriented software testability which is based on a theory expressed as a set of operational hypotheses we identify design attributes that have an impact on testability directly or indirectly by having an impact on testing activities and sub activities we also describe the cause effect relationships between these attributes and software testability based on thorough review of the literature and our own testing experience following the scientific method we express them as operational hypotheses to be further tested for each attribute we provide a set of possible measures whose applicability largely depends on the level of details of the design documents and the testing techniques to be applied the goal of this framework is twofold 1 to provide structured guidance for practitioners trying to measure design testability 2 to provide a theoretical framework for facilitating empirical research on testability 2005 elsevier b v all rights reserved diagnosing design problems in object oriented systems software decay is a phenomenon that plagues aging software systems while in recent years there has been significant progress in the area of automatic detection of code smells on one hand and code refactorings on the other hand we claim that existing restructuring practices are seriously hampered by their symptomatic and informal non repeatable nature this paper makes a clear distinction between structural problems and structural symptoms also known as code smells and presents a novel causal approach to restructuring object oriented systems our approach is based on two innovations the encapsulation of correlations of symptoms and additional contextual information into higher level design problems and the univocal explicit mapping of problems to unique refactoring solutions due to its explicit repeatable nature the approach shows high potential for increased levels of automation in the restructuring process and consequently a decrease in maintenance costs 2005 ieee an experiment on subjective evolvability evaluation of object oriented software explaining factors and interrater agreement recent trends in software development have emphasized the importance of refactoring in preserving software evolvability we performed two experiments on software evolvability evaluation i e evaluating the existence of certain code problems called code smells and the refactoring decision we studied the agreement of the evaluators interrater agreement was high for simple code smells and low for the refactoring decision furthermore we analyzed evaluators demographics and source code metrics as factors explaining the evaluations the code metrics explained over 70 of the variation regarding the simple code smell evaluations but only about 30 of the refactoring decision surprisingly the demographics were not useful predictors neither for evaluating code smells nor the refactoring decision the low agreement for the refactoring decisions may indicate difficulty in building tool support simulating real life subjective refactoring decisions however code metrics tools should be effective in highlighting straightforward problems e g simple code smells 2005 ieee refactoring support for class library migration as object oriented class libraries evolve classes are occasionally deprecated in favor of others with roughly the same functionality in java s standard libraries for example class hashtable has been superseded by hashmap and iterator is now preferred over enumeration migrating client applications to use the new idioms is often desirable but making the required changes to declarations and allocation sites can be quite labor intensive moreover migration becomes complicated and sometimes impossible if an application interacts with external components if a legacy class is not completely equivalent to its replacement or if multiple interdependent classes must be migrated simultaneously we present an approach in which mappings between legacy classes and their replacements are specified by the programmer then an analysis based on type constraints determines where declarations and allocation sites can be updated the method was implemented in eclipse and evaluated on a number of java applications on average our tool could migrate more than 90 of the references to legacy classes copyright 2005 acm design theory languages refactoring support for class library migration as object oriented class libraries evolve classes are occasionally deprecated in favor of others with roughly the same functionality in java s standard libraries for example class hashtable has been superseded by hashmap and iterator is now preferred over enumeration migrating client applications to use the new idioms is often desirable but making the required changes to declarations and allocation sites can be quite labor intensive moreover migration becomes complicated and sometimes impossible if an application interacts with external components if a legacy class is not completely equivalent to its replacement or if multiple interdependent classes must be migrated simultaneously we present an approach in which mappings between legacy classes and their replacements are specified by the programmer then an analysis based on type constraints determines where declarations and allocation sites can be updated the method was implemented in eclipse and evaluated on a number of java applications on average our tool could migrate more than 90 of the references to legacy classes copyright 2005 acm design theory languages towards a catalog of aspect oriented refactorings in this paper we present a collection of aspect oriented refactorings covering both the extraction of aspects from object oriented legacy code and the subsequent tidying up of the resulting aspects in some cases this tidying up entails the replacement of the original implementation with a different centralized design made possible by modularization the collection of refactorings includes the extraction of common code in various aspects into abstract superaspects we review the traditional object oriented code smells in the light of aspect orientation and propose some new smells for the detection of crosscutting concerns in addition we propose a new code smell that is specific to aspects 2005 acm aspect oriented programming code smells object oriented programming programming style refactoring towards an approach for aspect oriented software reengineering this paper presents a reengineering approach to help in migrating pure object oriented codes to a mixture of objects and aspects the approach focuses on aspect mining to identify potential crosscutting concerns to be modeled and implemented as aspects and on refactoring techniques to reorganize the code according to aspect oriented paradigm by using code transformations it is possible to recover the aspect oriented design using a transformational system with the recovered design it is possible to add or modify the system requirements in a case tool and to generate the codes in an executable language in this case aspectj aop aspect mining mvcase refactoring software reengineering software transformation identifying traits with formal concept analysis traits are basically mixins or interfaces but with method bodies in languages that support traits classes are composed out of traits there are two main advantages with traits firstly decomposing existing classes into traits from which they can be recomposed improves the factoring of hierarchies secondly it increases the library reuse potential by providing more reusable traits identifying traits and decomposing class hierarchies into traits is therefore an important and challenging task to facilitate maintainability and evolution in this paper we present how we use formal concept analysis to identify traits in inheritance hierarchies our approach is two staged first we identify within a hierarchy maximal groups of methods that have a set of classes in common second we cluster cohesive groups of methods based on method invocations as potential traits we applied our approach on two significant hierarchies and compare our results with the manual refactorization of the same code which was done by the authors of traits copyright 2005 acm formal concept analysis logical views mixins traits icse 2005 proceedings of the 3rd workshop on software quality 3 wosq 2005 the proceedings contain 13 papers the topics discussed include value based quality processes and results using idave to determine availability requirements software quality economics for defect detection techniques using failure prediction qfd application in software process management and improvement based on cmm improving quality through software process improvement in thailand initial analysis software quality development and assurance in rup msf and xp a comparative study quality cleanroom and formal methods dealing with imprecise quality factors in software design early estimation of software quality using in process testing metrics a controlled case study aries refactoring support tool for code clone a real time measure of software system families an empirical assessment of using stereotypes to improve reading techniques in software inspections and trade off analysis in web development an experiment on the use of qfd extending dynamic aspect mining with static information aspect mining tries to identify crosscutting concerns in legacy systems and thus supports the refactoring into an aspect oriented design we briefly introduce dynamit a dynamic aspect mining tool that detects crosscutting concerns based on tracing method executions while the approach is generally fairly precise further analysis revealed that some false positives were systematically caused by dynamic binding furthermore some aspect candidates were blurred or not detected due to not sufficient tracing mechanisms of method executions when using aspectj s execution pointcuts for the trace generation we enhanced the mining capabilities of dynamit by taking additional static type information into account and generating the traces using call pointcuts instead in an initial case study with anchovis a 1300 loc java program the number of mined aspect candidates increased by a factor of three while the number of false positives remained zero 2005 ieee archeology of code duplication recovering duplication chains from small duplication fragments code duplication is a common problem and a well known sign of bad design as a result of that in the last decade the issue of detecting code duplication led to various solutions and tools that can automatically find duplicated blocks of code however duplicated fragments rarely remain identical after they are copied they are oftentimes modified here and there this adaptation usually scatters the duplicated code block into a large amount of small islands of duplication which detected and analyzed separately hide the real magnitude and impact of the duplicated block in this paper we propose a novel automated approach for recovering duplication blocks by composing small isolated fragments of duplication into larger and more relevant duplication chains we validate both the efficiency and the scalability of the approach by applying it on several well known open source case studies and discussing some relevant findings by recovering such duplication chains the maintenance engineer is provided with additional cases of duplication that can lead to relevant refactorings and which are usually missed by other detection methods 2005 ieee code duplication design flaws quality assurance detecting and visualizing refactorings from software archives we perform knowledge discovery in software archives in order to detect refactorings on the level of classes and methods our refvis prototype finds these refactorings in cvs repositories and relates them to transactions and configurations additionally refvis relates movements of methods to the class inheritance hierarchy of the analyzed project furthermore we present our visualization technique that illustrates these refactorings refvis provides both a class hierarchy layout and a package layout and uses color coding to distinguish different kinds of refactorings details on each can be displayed on demand using mouse over tooltips finally we demonstrate by case studies on two open source projects how refvis facilitates understanding of refactorings applied to a software project 2005 ieee reverse engineering goal models from legacy code a reverse engineering process aims at reconstructing high level abstractions from source code this paper presents a novel reverse engineering methodology for recovering stakeholder goal models from both structured and unstructured legacy code the methodology consists of the following major steps 1 refactoring source code by extracting methods based on comments 2 converting the refactored code into an abstract structured program through statechart refactoring and hammock graph construction 3 extracting a goal model from the structured program s abstract syntax tree 4 identifying nonfunctional requirements and derive softgoals based on the traceability between the code and the goal model to illustrate this requirements recovery process we refactor stake holder goal models from two legacy software code bases an unstructured web based email in php squirrelmail and a structured email client system in java columba 2005 ieee multi criteria detection of bad smells in code with uta method bad smells are indicators of inappropriate code design and implementation they suggest a need for refactoring i e restructuring the program towards better readability understandability and eligibility for changes smells are defined only in terms of general subjective criteria which makes them difficult for automatic identification existing approaches to smell detection base mainly on human intuition usually supported by code metrics unfortunately these models do not comprise the full spectrum of possible smell symptoms and still are uncertain in the paper we propose a multi criteria approach for detecting smells adopted from uta method it learns from programmer s preferences and then combines the signals coming from different sensors in the code and computes their utility functions the final result reflects the intensity of an examined smell which allows the programmer to make a ranking of most onerous odors springer verlag berlin heidelberg 2005 refactoring the aspectizable interfaces an empirical assessment aspect oriented programming aims addressing the problem of the crosscutting concerns i e those functionalities that are scattered among several modules in a given system aspects can be defined to modularize such concerns in this work we focus on a specific kind of crosscutting concerns the scattered implementation of methods declared by interfaces that do not belong to the principal decomposition we call such interfaces aspectizable all the aspectizable interfaces identified within a large number of classes from the java standard library and from three java applications have been automatically migrated to aspects to assess the effects of the migration on the internal and external quality attributes of these systems we collected a set of metrics and we conducted an empirical study in which some maintenance tasks were executed on the two alternative versions with and without aspects of the same system in this paper we report the results of such a comparison 2005 ieee aspect oriented programming empirical studies program transformations refactoring predicting the probability of change in object oriented systems of all merits of the object oriented paradigm flexibility is probably the most important in a world of constantly changing requirements and the most striking difference compared to previous approaches however it is rather difficult to quantify this aspect of quality this paper describes a probabilistic approach to estimate the change proneness of an object oriented design by evaluating the probability that each class of the system will be affected when new functionality is added or when existing functionality is modified it is obvious that when a system exhibits a large sensitivity to changes the corresponding design quality is questionable the extracted probabilities of change can be used to assist maintenance and to observe the evolution of stability through successive generations and identify a possible saturation level beyond which any attempt to improve the design without major refactoring is impossible the proposed model has been evaluated on two multiversion open source projects the process has been fully automated by a java program while statistical analysis has proved improved correlation between the extracted probabilities and actual changes in each of the classes in comparison to a prediction model that relies simply on past data 2005 ieee object oriented design methods object oriented programming product metrics quality analysis and evaluation refactoring gcc using structure field access traces amp concept analysis 2005 acm isbn refactoring usually involves statically analyzing source code to understand which transformations safely preserve execution behavior of the program however static analysis may not scale well for large programs when analysis results are too general when tools for analyzing the source code are unwieldy or when the tools simply do not exist in such cases it can be simpler to analyze the program at runtime to gather answers needed for safe code changes i show how dynamic data can guide refactoring of a single data structure into a hierarchy of classes specifically i show how i refactored the gcc compiler to cut its use of heap memory in order to partition the declaration data structure into more efficiently sized parts i used data structure field access traces to automatically identify how the data structure might be refactored i also identified other potential refactorings of the data structure using concept analysis these results then guided byhand modifications to the compiler i finally evaluated what size test cases would be needed to gather adequate information to correctly perform the refactoring the case study showed the refactoring could be performed with the dynamic information but without traces from an exhaustive set of test cases some fields would be moved incorrectly case study gcc meaning preserving restructuring a technique for automatic component extraction from object oriented programs by refactoring component based software development cbd is based on building software systems from previously existing software components in cbd reuse of common parts in component form can reduce the development cost of new systems and reduce the maintenance cost associated with the support of these systems however existing programs have usually been built using another paradigm such as the object oriented oo paradigm oo programs cannot be reused rapidly or effectively in the cbd paradigm even if they contain reusable functions in this paper we propose a technique for extracting components from existing oo programs by our new refactoring extract component our technique of refactoring can identify and extract reusable components composed of classes from oo programs and modify the surrounding parts of extracted components in original programs we have developed a system that performs our refactoring automatically and extracts javabeans components from java programs as a result of evaluation experiments it is found that our system is useful for extracting reusable components along with usage examples from java programs 2004 elsevier b v all rights reserved component based development cbd javabeans object oriented programming refactoring software component software reuse physical properties of the dust in the solar system and its interrelation with small bodies dust particles in the solar system are produced from the small bodies asteroids comets meteoroids and kuiper belt objects a further source of dust is provided by the warm interstellar medium that the sun is currently embedded in and that streams into the solar system we review the physical properties of solar system dust and trace back its interrelation with the small solar system bodies comets contain relatively pristine material that they transport to the inner solar system the alteration of dust in the vicinity of comets is complex and connected to the gas evolution but a significant part of the organic dust material survives these alterations the optical properties of cometary dust are best described with a mixture of silicate and carbon bearing materials as far as the darkness of the cometary material is concerned according to recent models this is not a result of the porosity but rather of the darkness of the carbon bearing component this does not contradict the observation of silicate features in the thermal emission brightness of cometary dust since porous mixtures of silicate and carbon bearing dust can produce the observed polarization and albedo characteristics as well as the silicate features the carbon bearing component is most likely an organic refactory component the relative contributions of different sources change within the solar system dust cloud and depend as well on the measurement technique considered in particular the dust from asteroids which provides a large component of the dust near earth orbit is also preferably seen with most of the detection methods the majority of dust inward from 1 au is produced from cometary dust and meteoroids dust material evaporation induced by collisions inward from 1 au produces a minor heavy ion component in the solar wind plasma known as inner source pick up ions 2006 international astronomical union comets general interplanetary medium meteors meteoroids tositumomab and 131i therapy in non hodgkin s lymphoma tositumomab and 131 i tositumomab constitute a relatively new radioimmunotherapeutic regimen for patients with cd20 follicular non hodgkin s lymphoma nhl currently it is approved for use in patients whose disease has relapsed after chemotherapy and is refactory to rituximab including patients whose tumors have transformed to a higher histologic grade this review outlines the current and evolving status of this therapeutic regimen at nonmyeloablative doses methods clinical data from multiple published studies and preliminary communications encompassing more than 1 000 patients were reviewed to describe the current status of tositumomab and 131 i tositumomab therapy the therapy is delivered in 2 parts a dosimetric dose and a therapeutic dose the therapeutic radioactivity millicurie dose is calculated on a patient individualized tailored basis a series of 3 total body γ camera scans are used to determine the patient specific pharmacokinetics total body residence time of the radiolabeled antibody conjugate required to deliver the desired total body radiation dose typically 75 cgy results in clinical trials objective response rates in patients who had been extensively pretreated with chemotherapy ranged from 47 to 68 tositumomab and 131 i tositumomab therapy also was effective in patients who had failed to respond to or who had relapsed after rituximab therapy with a 68 overall response rate thirty percent of such patients achieved complete responses that were generally of several years duration single center trials using tositumomab and 131 i tositumomab therapy alone or after chemotherapy in previously untreated patients have shown response rates in excess of 90 with most responses complete retreatment with tositumomab and 131 i tositumomab and use of lower total body radiation doses of tositumomab and 131 i tositumomab to treat patients who have relapsed after stem cell transplantation have been shown feasible in limited clinical studies toxicity is predominately hematologic however human antimouse antibodies hypothyroidism and myelodysplastic syndrome have been reported in a small fraction of patients conclusion tositumomab and 131 i tositumomab therapy at patient specific nonmyeloablative doses is safe and effective in treatment of relapsed and refractory follicular nhl toxicity is mainly hematologic and reversible tositumomab and 131 i tositumomab therapy is assuming a growing role in this common malignancy non hodgkin s lymphoma radioimmunotherapy tositumomab and i tositumomab therapy 131 using reengineering and aspect based techniques to retrieve knowledge embedded in object oriented legacy system this paper presents an approach to retrieve the knowledge embedded in object oriented legacy system this approach aids in the migration from object oriented code written in java to a combination of objects and aspects using aspectj the approach uses aspect mining in order to identify possible crosscutting concerns from the object oriented source code and extracts them through refactorings into new aspect oriented code next the aspect oriented design is retrieved through software transformations and may be imported in a case tool becoming available in higher abstraction levels the retrieved information constitutes important knowledge that may be reused in future projects or in reengineering 2004 ieee oopsla 04 conference companion 19th annual acm conference on object oriented programming systems languages and applications the proceedings contain 105 papers the topics discussed include jmock supporting responsibility based design with mock objects advanced refactorings in eclipse jquery finding your way through tangled code modeling event driven applications with a specification language medasl design snippets partial design representations extracted from source code meta programming for the real world jra offline analysis of runtime behavior modeling and building software product lines with eclipse prism is research in aspect mining smell detection for eclipse program transformations for re engineering c components oopsla gpce c saw and genaweave a two level aspect weaving toolsuite the concern manipulation environment oopsla gpce object oriented structural software configuration management implementing dsl in metaocaml modeling dynamics of agile software development interactive visualization of object oriented programs and generic ownership practical ownership in programming languages an automatic approach to identify class evolution discontinuities when a software system evolves features are added removed and changed moreover refactoring activities are periodically performed to improve the software internal structure a class may be replaced by another two classes can be merged or a class may be split in two others as a consequence it may not be possible to trace software features between a release and another when studying software evolution we should be able to trace a class lifetime even when it disappears because it is replaced by a similar one split or merged such a capability is also essential to perform impact analysis this paper proposes an automatic approach inspired on vector space information retrieval to identify class evolution discontinuities and therefore cases of possible refactoring the approach has been applied to identify refactorings performed over 40 releases of a java open source domain name server almost all the refactorings found were actually performed in the analyzed system thus indicating the helpfulness of the approach and of the developed tool refactoring releases software evolution traceability refactoring class hierarchies with kaba kaba is an innovative system for refactoring java class hierarchies it uses the snelting tip algorithm in order to determine a behavior preserving refactoring which is optimal with respect to a given set of client programs kaba can be based on dynamic as well as static program analysis the static variant will preserve program behavior for all possible input values the dynamic version guarantees preservation of behavior for all runs in a given test suite kaba offers automatic refactoring as well as manual refactoring using a dedicated editor in this contribution we recapitulate the snelting tip algorithm present the new dynamic version and explain new extensions which allow to handle full java we then present five case studies which discuss the kaba refactoring proposals for programs such as javac and antlr kaba proved that javac does not need refactoring but generated semantics based refactoring proposals for antlr categories and subject descriptors d 2 7 software engineering distribution maintenance and enhancement restructuring reverse engineering and reengineering d 3 3 programming languages language constructs and features classes and objects inheritance f 3 2 logics and meanings of programms semantics of programming languages program analysis refactoring refactoring methods for knowledge bases the manual development of large knowledge systems is a difficult and error prone task in order to facilitate extensions to an existing knowledge base the structural design of the implemented knowledge needs to be improved from time to time however experts are often deterred even from important design improvements since some restructurings are too complex to handle in this paper we introduce a framework that allows for automated refactorings refactoring methods are well defined and are executed in a semi automated way in this manner the developer is supported during the process of restructuring of even large knowledge bases refactoring methods are usually applied to improve the design of the knowledge base in this paper we sketch some design anomalies that identify poor design of the knowledge base springer verlag berlin heidelberg 2004 refactoring improving coupling and cohesion of existing code refactorings are widely recognised as ways to improve the internal structure of object oriented software while maintaining its external behaviour unfortunately refactorings concentrate on the treatment of symptoms the so called code smells thus improvements depend a lot on the skills of the maintainer coupling and cohesion on the other hand are quality attributes which are generally recognized as being among the most likely quantifiable indicators for software maintainability therefore this paper analyzes how refactorings manipulate coupling cohesion characteristics and how to identify refactoring opportunities that improve these characteristics as such we provide practical guidelines for the optimal usage of refactoring in a software maintenance process 2004 ieee evaluating clone detection techniques from a refactoring perspective in the last decade several researchers have investigated techniques to automatically detect duplicated code in programs exceeding hundreds of thousands lines of code all of these techniques have known merits and deficiencies but as of today little is known on how these techniques fit into the refactoring process of object oriented systems this paper compares three representative detection techniques simple line matching parameterized matching and metric fingerprints by means of five small to medium sized cases and analyses the differences between the reported matches based on this comparison we conclude that 1 simple line matching is best suited for a partial yet advanced restructuring with little effort 2 metric fingerprints work best for refactoring a system with minimal effort 3 parameterized matching demands more effort yet allows a more profound less obvious restructuring of the code 2004 ieee straightening spaghetti code with refactoring changes to software systems often entail a loss of quality especially if they have to be accomplished under pressure of time long term software projects must counter this phenomenon one way or the other to preserve long term maintainability this paper presents the results of a case study trying to improve an extensive low quality code base by object oriented and tool supported refactoring to obtain practically relevant experiences this case study was conducted within an on going commercial software project the existing code base was first assessed using metrics as well as subjective judgment and later on refactored according to the findings of the assessment by this we evaluated the practical applicability of several metrics and refactoring tools the results of this experiment indicate that tool support is immature and the impact of refactoring is limited if the code base has gone astray for a longer period of time refactoring software maintenance software metrics migrating interface implementations to aspects separation of concerns and modularization are the cornerstones of software engineering however when a system is decomposed into units functionalities often emerge which cannot be assigned to a single element of the decomposition the implementation of interfaces 1 represents a typical instance of this problem in fact the code that defines the interface methods is often scattered across several classes in the system and tangled with the original code aspect oriented programming provides mechanisms for the dynamic and static composition of transversal functionalities that can be used to factor out the implementation of interfaces in this paper we describe a technique for the identification of those interface implementations that are most likely to represent crosscutting concerns moreover the code transformation refactoring to migrate such interfaces to aspects is also presented experimental results validate the approach 2004 ieee using clustering technique to restructure programs program restructuring or refactoring is often required when a function becomes too large or is involved in multiple activities and therefore exhibits low cohesion a critical factor in restructuring is to increase cohesion and decrease coupling there are many existing methods which measure cohesion and coupling but do not provide much information as to how to restructure the program while some other methods exist which only deals with restructuring the functions the paper presents a simple but effective approach to function restructuring based on the experimental research on cohesion and coupling measure for software cohesion could be the first step of reengineering a software system to identify the functions with low cohesion the next step is to restructure the identified functions a clustering technique is presented in this paper which can assess the cohesiveness of a function and also gives indicaiton as to how to decompose a function to multiple high cohesive functions several examples are presented to demonstrate the concept aries rrfactoring support environment based on code clone analysis code clone has been regarded as one of factors that make software maintenance more difficult a code clone is a code fragment in a source code that is identical or similar to another for example if we modify a code fragment which has code clones it is necessary to consider whether we have to modify each of its code clones hence removal of code clones makes maintainability and comprehensibility of source code more improved we have proposed a method that detects refactoring oriented code clone in this paper in order to improve the usefulness and applicability of the method in the actual software maintenance we have extended our refactoring support method concretely we have developed a characterization of code clones by some metrics which suggest how to remove them then we have developed refactoring support tool aries we expect aries can support software maintenance more effectively code clone metrics object oriented refactoring software maintenance tool asaam aspectual software architecture analysis method software architecture analysis methods aim to predict the quality of a system before it has been developed in general the quality of the architecture is validated by analyzing the impact of predefined scenarios on architectural components hereby it is implicitly assumed that an appropriate refactoring of the architecture design can help in coping with critical scenarios and mending the architecture this paper shows that there are also concerns at the architecture design level which inherently crosscut multiple architectural components which cannot be localized in one architectural component and which as such can not be easily managed by using conventional abstraction mechanisms we propose the aspectual software architecture analysis method asaam to explicitly identify and specify these architectural aspects and make them transparent early in the software development life cycle asaam introduces a set of heuristic rules that help to derive architectural aspects and the corresponding tangled architectural components from scenarios the approach is ilustrated for architectural aspect identification in the architecture design of a window management system aspect oriented software architecture design scenario based architectural evaluation scenario based aspect identification refactoring class hierarchies with kaba kaba is an innovative system for refactoring java class hierarchies it uses the snelting tip algorithm 13 in order to determine a behavior preserving refactoring which is optimal with respect to a given set of client programs kaba can be based on dynamic as well as static program analysis the static variant will preserve program behavior for all possible input values the dynamic version guarantees preservation of behavior for all runs in a given test suite kaba offers automatic refactoring as well as manual refactoring using a dedicated editor in this contribution we recapitulate the snelting tip algorithm present the new dynamic version and explain new extensions which allow to handle full java we then present five case studies which discuss the kaba refactoring proposals for programs such as javac and antlr kaba proved that javac does not need refactoring but generated semantics based refactoring proposals for antlr refactoring automated design flaw correction in object oriented systems software inevitably changes as a consequence we observe the phenomenon referred to as software entropy or software decay the software design continually degrades making maintenance and functional extensions overly costly if not impossible there exist a number of approaches to identify design flaws problem detection and to remedy them refactoring there is however a conceptual gap between these two stages there is no appropriate support for the automated mapping of design flaws to possible solutions in this paper we propose an integrated quality driven and tool supported methodology to support object oriented software evolution our approach is based on the novel concept of correction strategies correction strategies serve as reference descriptions that enable a human assisted tool to plan and perform all necessary steps for the safe removal of detected design flaws with special concern towards the targeted quality goals of the restructuring process we briefly sketch our tool chain and illustrate our approach with the help of a medium sized real world case study supporting architectural restructuring by analyzing feature models in order to lower the risk reengineering projects aim at high reuse rates therefore tasks like architectural restructuring have to be performed in a way that developed new system architectures allow reuse of all valuable legacy systems parts with minimal changes during architectural restructuring there are two major types of modification detection of architecture disproportions and their refactoring and detection of redundancies and their fusion in this paper we introduce a method for applying domain knowledge for supporting these restructuring steps the method operates on feature models words and terms of features and of architectural documents are analyzed by cluster analysis information retrieval and metrics techniques in this way the method joins the approaches of feature analysis and of enhancing reengineering with domain knowledge by applying feature models for structuring the domain knowledge the method results in clues and hints for the development of a new architecture it provides an effective addition to the conventional software architecture design methods the method was developed and applied in an industrial reengineering project within image processing domain it has been proved to be applicable to large and complex systems even in case of heavy monolithic parts we use examples from this project to illustrate the method evolution of rule based programs the term rule based program is meant to include definite clause programs sos specifications attribute grammars and conditional rewrite systems these setups are widely used for the executable specification or implementation of language based tools e g interpreters translators type checkers program analysers and program transformations we provide a pragmatic transformation based approach for expressing and tracking changes in rule based programs in the course of program evolution to this end we design an operator suite for the transformation of rule based programs the operators facilitate steps for clean up refactoring and enhancement we use sos based interpreter examples to illustrate evolution of rule based programs we use logic programming to execute the examples while the relevant evolution operators are made available as logic meta programs 2004 elsevier inc all rights reserved attribute grammars constructive algebraic specification extensibility logic programming meta programming natural semantics program transformation refactoring reuse rule based programming software evolution structural operational semantics 4th conference on extreme programming and agile methods xp agile universe 2004 the proceedings contain 54 papers the special focus in this conference is on testing integration and managing requirements and usability the topics include combining formal specifications with test driven development long build trouble shooting guide the role of process measurement in test driven development acceptance test driven planning an agile customer centered method suitability of fit user acceptance tests for specifying functional requirements using storyotypes to split bloated xp stories distributed pair programming support for distributed pair programming in the transparent video facetop toward a conceptual framework of agile methods security engineering and extreme programming an agile cmm adapting extreme programming to research development and production environments outsourcing and offshoring with agility user story methodology adaptations for projects non traditional in scope and customer gui contributions research close to the action getting leaders on board third international workshop on empirical evaluation of agile methods ui design as part of an agile process agile development for embedded software refactoring our writings agile tests as documentation agile project management agile methods for safety critical software development tailoring the functional requirements specification process to improve agility advanced fit lab effective user stories outsourcing and offshoring with agility coaching agile software teams a practical approach for testers and the customer team first encounter with agile methods working effectively with legacy code the art of acceptance testing agile planning tracking and project management boot camp agile project management and scripting web tests 7th international conference on fundamental approaches to software engineering fase 2004 held as part of the joint european conferences on theory and practice of software etaps 2004 the proceedings contain 28 papers the special focus in this conference is on fundamental approaches to software engineering the topics include distributed information management with xml and web services a formal treatment of context awareness consistent adaptation and evolution of class diagrams during refinement measuring aspect cohesion refactoring object z specifications checking absence of illicit applet interactions a tool assisted framework for certified bytecode verification reasoning about card tears and transactions in java card predictable dynamic plugin systems a correlation framework for the corba component model an integrated development environment for analysis synthesis and verification of component based systems actor centric modeling of user rights modeling role based access control using parameterized uml models compositional nested long running transactions a tool for automatic translation from daml s to high level petri nets integrating meta modelling aspects with graph transformation for efficient visual language definition and model manipulation an operational semantics for stateflow improving use case based requirements using formally grounded specifications an integrated development environment for process control requirements and design automated debugging using path based weakest preconditions filtering tobias combinatorial test suites systematic testing of software architectures in the c2 style optimising communication structure for model checking translating software designs for model checking enhancing remote method invocation through type based static analysis and specification and analysis of real time systems using real time maude 5th international conference on extreme programming and agile processes in software engineering xp 2004 the proceedings contain 60 papers the special focus in this conference is on acceptance testing scalability issues new insights refactoring and social issues the topics include putting a motor on the canoo webtest acceptance testing framework generative acceptance testing for difficult to test software distributed product development using extreme programming efficient markets efficient projects and predicting the future agile principles and open source software development agile specification driven development towards a proper integration of large refactorings in agile software development the oregon software development process empirical analysis on the satisfaction of it employees comparing xp practices with other software development methodologies agile processes enhancing user participation for small providers of off the shelf software self adaptability of agile software processes enterprise continuous integration using binary dependencies automated generation of unit tests for refactoring test driven development and software process improvement in china a comparison of software development process experiences literate programming to enhance agile methods application of lean and agile principles to workflow management assistance for supporting xp test practices in a distributed cscw environment combining ad hoc and regression testing complete test generation for extreme programming conditional test for javabeans components agile methods in software engineering education extreme programming in a university project a selection framework for agile methodologies designing the ultimate acceptance testing framework and xp and organizational change the role of constructors in the context of refactoring object oriented systems constructors play an essential role in object oriented oo languages as a means of object creation yet very little empirical evidence exists on constructors trends in their composition and how they impact comprehension and encapsulation of oo classes in this paper we empirically investigate the opportunities benefits and problems of refactoring class constructors across a sample of classes from five java systems the refactoring used namely replacing multiple constructors with creation methods was applied to each of a set of classes containing three or more constructors empirical results showed benefits in terms of removed duplicated lines of code across the majority of systems they also showed the potential for improved class comprehension by the creation of non constructor methods as a replacement for constructors and improved encapsulation of class elements through use of a private catch all constructor we also provide evidence from five c systems which suggests similar trends in constructors to those found for java in terms of problems encountered frequent and inconsistent use of the super construct made refactoring prohibitively difficult in some cases the existence of java interfaces also means a lack of scope for constructor refactoring the results indicate clear and tangible benefits to be gained from investigation and implementation of refactoring techniques in java but with caution being exercised in certain cases refactoring in practice is not as straightforward as the theory suggests 2003 ieee an information based view of representational coupling in object oriented systems in this paper we investigate a special type of coupling in object oriented systems when a method of a class c invokes a method of a class d the method of c becomes dependent on the representational details of d the more low level the service provided by d is the higher the dependency of c on d this dependency is known as representational coupling coupling in general and representational coupling in particular are important because they influence the extensibility of a system that is the ease with which software can be adapted to changing requirements the higher the coupling the harder it is to make changes since any changes local to one module are likely to affect many other modules we propose a qualitative measure of representational coupling as opposed to quantitative measures provided by metrics that is based on partial orders over equivalence relations on the state space we also introduce the notion of intrinsic representational coupling that expresses the amount of representational coupling that is inherent to the system finally we show that despite its non quantitative nature our measure can be useful in identifying candidate methods for refactoring we demonstrate this by applying our measure to several examples in the literature showing in each case how an implementation with non minimal representational coupling can be transformed using a few simple refactorings into a solution with minimal representational coupling equal to the intrinsic representational coupling springer verlag berlin heidelberg 2003 coupling extensibility metrics object oriented refactoring predicting faulty classes using design metrics with discriminant analysis nowadays risk assessment is one of software engineering processes that plays important role in software development life cycle applying risk assessment to software the earlier is the better developers should detect defects of software early at design phase so the improvement action such as refactoring can be taken constructing fault prediction model using design metrics is one approach that can help developers to identify the faulty classes at early phase this paper collects object oriented design metrics and introduces some new metrics that tend to affect the existing of faults in classes then construct the fault prediction model with discriminant analysis technique the prediction model was trained by data collected from sale system and was validated using data from cd selection system the result indicates that 12 of 14 design metrics are associated with fault proneness and the model can be used to classify faulty level of new classes design metrics discriminant analysis prediction model reliability traits composable units of behaviour despite the undisputed prominence of inheritance as the fundamental reuse mechanism in object oriented programming languages the main variants single inheritance multiple inheritance and mixin inheritance all suffer from conceptual and practical problems in the first part of this paper we identify and illustrate these problems we then present traits a simple compositional model for structuring object oriented programs a trait is essentially a group of pure methods that serves as a building block for classes and is a primitive unit of code reuse in this model classes are composed from a set of traits by specifying glue code that connects the traits together and accesses the necessary state we demonstrate how traits overcome the problems arising from the different variants of inheritance we discuss how traits can be implemented effectively and we summarize our experience applying traits to refactor an existing class hierarchy springer verlag berlin heidelberg 2003 inheritance mixins multiple inheritance reuse smalltalk traits proceedings 7th european conference on software maintenance and reengineering csmr 2003 the proceedings contain 42 papers the topics discussed include software services and software maintenance software documentation how much is enough revitalizing modifiability of legacy assets towards automatical migration of transformation rules after grammar extension automated cobol to java recycling light weight product lines for evolution and maintenance of web sites web applications design and maintenance using symbolic model checking enabling legacy system accessibility by web heterogeneous clients towards a benchmark for web site extractors a call for community participation identifying refactoring opportunities using logic meta programming refactoring browser with preprocessor the role of constructors in the context of refactoring object oriented systems supporting evolution in component based development using component libraries and reengineering legacy application to e business with modified rational unified process building conceptual schemas by refining general ontologies in practice most conceptual schemas of information systems and databases are developed essentially from scratch this paper deals with a new approach to that development consisting on the refinement of a general ontology we identify and characterize the three activities required to develop a conceptual schema from a general ontology that we call refinement pruning and refactoring the focus of the paper is on the differences of the new approach with respect to the traditional one the pruning activity may be automated we formalize it and present a method for its realization besides we identify a particular problem that appears during the refactoring activity determining whether two types are redundant and provide two sufficient conditions for it we illustrate the approach with the development of a conceptual schema by refinement of the cyc ontology however our results apply to any general ontology the conceptual modeling language we have used is the uml but we believe that our results could be applied to any similar language springer verlag berlin heidelberg 2003 global analysis and transformations in preprocessed languages tool support for refactoring code written in mainstream languages such as c and c is currently lacking due to the complexity introduced by the mandatory preprocessing phase that forms part of the c c compilation cycle the defintion and use of macros complicates the notions of scope and of identifier boundaries the concept of token equivalence classes can be used to bridge the gap between the language proper semantic analysis and the nonpreprocessed source code the cscout toolchest uses the developed theory to analyze large interdependent program families a web based interactive front end allows the precise realization of rename and remove refactorings on the original c source code in addition cscout can convert programs into a portable obfuscated format or store a complete and accurate representation of the code and its identifiers in a relational database c c preprocessor program families refactoring renaming reverse engineering refactoring middleware with aspects middleware platforms such as web services j2ee corba and dcom have become increasingly popular during the last decade they have been very successful in solving distributed computing problems for a large family of application domains the architecture of middleware systems have gone through many significant cycles of evolution both in terms of the completeness of functionality and the range of adoptions for different types of platforms however at the same time it is getting increasingly difficult to achieve and to maintain a high level of adaptability and configurability because the structure of the middleware architecture is becoming overly complicated and rigid we attribute that problem to the limitations of traditional software decomposition methods aspect oriented programming on the contrary has introduced new design perspectives that permit the superimpositions of different abstraction models on top of one another this is a very powerful technique for separating and simplifying design concerns in our effort of applying principles of aspect orientation to the middleware architecture we first pragmatically analyze the use of aspects in the middleware architecture we then show that aspects are the correct remedy for the above outlined middleware problems by quantifying crosscutting concerns in the legacy implementations of several prominent middleware systems our aspect analysis results strongly indicate that modularity of middleware architecture is greatly hindered by the wide existence of tangled logic to go one step further we factor out a number of crosscutting concerns identified in the mining process reimplement them as aspects and superimpose them back into the refactored architecture this allows us to use a set of software engineering metrics to quantify the refactorization in terms of changes in the structural complexity modularity and performance of the resulting system this aspect oriented refactoring proves that aspect orientation is capable of composing orthogonal design requirements the final woven system is able to correctly provide both the fundamental functionality and the aspectized functionality with negligible overhead and an overall leaner architecture furthermore the aspectized feature can be configured in and out during compile time which greatly enhances the configurability of the architecture aspect analysis aspect oriented programming aspects middleware refactoring refactoring for generalization using type constraints refactoring is the process of applying behavior preserving transformations called refactorings in order to improve a program s design associated with a refactoring is a set of preconditions that must be satisfied to guarantee that program behavior is preserved and a set of source code modifications an important category of refactorings is concerned with generalization e g extract interface for re routing the access to a class via a newly created interface and pull up members for moving members into a superclass for these refactorings both the preconditions and the set of allowable source code modifications depend on interprocedural relationships between types of variables we present an approach in which type constraints are used to verify the preconditions and to determine the allowable source code modifications for a number of generalization related refactorings this work is implemented in the standard distribution of eclipse see www eclipse org class hierarchy program analysis refactoring subtyping type constraints initial experience with miniature axial flow ventricular assist devices for postcardiotomy heart failure objective the recently introduced impella recover microaxial flow left and right ventricular assist devices l rvad were evaluated as to provide circulatory support in the setting of postcardiotomy heart failure or posttransplant graft failure methods the impella recover 100 lvad is a small 6 4 mm in diameter intracardiac pump which is implanted via a prosthetic graft attached to the ascending aorta and is then advanced into the lv trespassing the aortic valve the recover lvad delivers a continuous blood flow by direct drainage of the lv cavity and ejection of the blood into the ascending aorta the new recover 600 rvad is a small paracardiac pump delivering a continuous blood flow by drainage of the right atrium and blood return to the pulmonary artery by combined use of the two devices biventricular support bvad can be provided between 5 2 and 10 02 the recover lvad has been implanted in six patients 66 ± 11 years of age n 3 70 years with left heart failure following coronary artery bypass procedures in all cases the indication for lvad insertion was heart failure refactory to optimized catecholamine and iabp support preoperative lv function was compromised in all patients lvef 28 ± 12 before the operation one patient presented with chronic lv dysfunction three patients were in cardiogenic shock as a consequence of acute myocardial infarction the world s clinical first use of the recover rvad together with the recover lvad was performed in one male patient with intraoperative graft failure following cardiac transplantation results the recover lvad delivered blood flows up to 5 l min four patients were successfully weaned from the lvad after 169 ± 34 hours in two patients lv function did not recover the latter patients and two of the patients in whom the lvad could be removed died later from multiorgan failure secondary to septicemia the patient with posttransplant graft failure was weaned from the recover bvad after 143 h full recovery of graft function occurred within this time frame the patient however died later as a consequence of intracranial hemorrhage conclusions our initial experience with the impella recover lvad and rvad was favourable in terms of ease of implantation and device removal and simplicity of device control the abundance of additional systemic heparinization and the availability of a zero net flow drive mode during the weaning phase are further distinct advantages of the new support systems cardiogenic shock graft failure heart failure heart transplantation left ventricular assist device myocardial infarction postcardiotomy cardiogenic shock ventricular assist device software systems as complex networks structure function and evolvability of software collaboration graphs software systems emerge from mere keystrokes to form intricate functional networks connecting many collaborating modules objects classes methods and subroutines building on recent advances in the study of complex networks i have examined software collaboration graphs contained within several open source software systems and have found them to reveal scale free small world networks similar to those identified in other technological sociological and biological systems i present several measures of these network topologies and discuss their relationship to software engineering practices i also present a simple model of software system evolution based on refactoring processes which captures some of the salient features of the observed systems some implications of object oriented design for questions about network robustness evolvability degeneracy and organization are discussed in the wake of these findings 2003 the american physical society international workshop on principles of software evolution iwpse the proceedings contain 24 papers the topics discussed include program slicing tool for effective software evolution using aspect oriented technique a model for conformance analysis of software documents beyond the refactoring browser advanced tool support for software refactoring dynamic behavior and protocol models for incremental changes among a set of collaborative objects class refinement for software evolution lightweight prevention of architectural erosion process oriented metrics for software architecture evolvability the chaos of software development stability and volatility in the linux kernel software evolution a distant perspective using coordination contracts for flexible adaptation to changing business rules business rule evolution and measures of business rule evolution and reconstruction of successful software evolution using clone detection architectural refactoring in framework evolution a case study springer verlag berlin heidelberg 2002 the know it all project is investigating methodologies for the development application and evolution of frameworks a concrete framework for database management systems is being developed as a case study for the methodology research the methodology revolves around a set of models for the domain the functionality the architecture the design and the code these models reflect the common and variable features of the domain refactoring of source code has been studied as a preliminary step in the evolution of object oriented software in cascaded refactoring we view framework evolution as a two step process refactoring and extension the refactoring step is a set of refactorings one for each model the refactorings chosen for a model determine the rationale or constraints for the choice of refactorings of the next model there are several issues with respect to architecture that we have encountered and are exploring these include 1 the choice of models for the architecture 2 the design of the architecture and its evaluation 3 the evolution of the architecture by extending the concept of refactoring from source code to architecture and 4 the modeling of variation in architectures across the product line here we focus on the refactoring of the architecture 1st acm sigplan sigsoft international conference on generative programming and component engineering gpce 2002 the proceedings contain 20 papers the special focus in this conference is on generative programming and component engineering the topics include program generation termination and binding time analysis generative programming for embedded systems a specification and scripting language for binary data memoization in type directed partial evaluation a protocol stack development tool using generative programming building composable aspect specific languages with logic metaprogramming architectural refactoring in framework evolution towards a modular program derivation via fusion and tupling generative programming for embedded software a framework for the detection and resolution of aspect interactions bridging the gap between implementation and design program termination analysis in polynomial time generators for synthesis of qos adaptation in distributed real time embedded systems optimizing content management system pipelines component based programming for higher order attribute grammars altering java semantics via bytecode manipulation meta programming with concrete object syntax and managing dynamic changes in multi stage program generation systems producing reusable object oriented components a domain and organization specific perspective developing reusable object oriented software requires a designer to determine how to structure a software system so as to achieve the necessary functionality while at the same time increasing the reuse potential of the software we introduce a set of reusability metrics intended to be iteratively applied during the design and implementation parts of the software life cycle to help guide the production and identification of reusable components component identification centers on the application s domain with reuse focusing specifically on an organization s future systems our approach requires the developer to subjectively categorize classes identify component boundaries and specify where components are related our metrics provide reuse valuations on the couplings between components based upon the results of applying our metrics we provide refactoring guidelines to increase the separation between components in a manner that improves component reusability we include an application of our metrics to a commercial object oriented framework component based engineerin quantification and metrics reuse process automated method extraction refactoring by using block based slicing refactoring improves the design of existing code but is not complex to do by hand this paper proposes a mechanism that automatically refactors methods of object oriented programs by using program slicing to restructure a method without changing its observable behavior the mechanism uses block based slicing that does not extract the fragments of code from the whole program but from the region consisting of some consecutive basic blocks of the program a refactoring tool implementing the mechanism constructs a new method that contains the extracted code and re forms the source method that contains the remaining code and statements indispensable for executing it with this tool a programmer indicates only a variable of interest in the code that he she wants to refactor and then selects a suitable method from among the candidates created by the tool the programmer does not have to test the refactored code since the mechanism is based on data and control flow analysis thus the tool enables programmers to avoid manual refactoring whose process is error prone and time consuming using transformation systems for software maintenance and reengineering software maintenance costs dominate software engineering costs partly because most such engineering is done manually program transformation tools leverage an engineer provided base of transforms a kind of generative reuse of programming knowledge to automate analysis modification and generation of software enhancing productivity and quality over conventional methods this tutorial provides a complete overview of program transformation from theory to implementation to application several real transformation systems will be examined with application examples including automated detection and removal of duplicate code from large systems and the potential for semi automated refactoring of large object frameworks the tutorial progresses from introductory to intermediate but all the necessary background will be provided so attendees need only basic software engineering knowledge and motivating experience modifying software refactoring tool challenges in a strongly typed language this poster examines the challenges of developing a refactoring tool for a weakly typed language such as smalltalk as opposed to a strongly typed language such as java to explore this we will compare the push up field refactoring in each language this refactoring was selected because it is relatively simple conceptually but difficult to implement for java in a weakly typed language such as smalltalk push up field is simple the user simply determines that the parent class needs the variable the refactoring tool moves the field to the parent class then the tool searches all the subclasses of the parent class if the classes have a variable with the same name the refactoring tool removes the variable from the subclass the task is complete for java a description of classes and types is necessary let s start with a base class a a has a number of child classes b c d e f and g each of b g has a single instance variable named var the only difference between the classes is the type of var b and c both have a variable named var with type x d has a variable named var with a type y e has a variable named var with type w f has a variable named var with a type of z and g has a variable named var with the type int w x y and z are classes w is the base class x is a subclass of w and y is a subclass of x z is unrelated to all of the other classes since all subclasses of a have a variable named var a programmer might suspect that they could reduce the amount of code by moving the variable into the parent class a let s move the field named var from class b into class a like in smalltalk the java refactoring tool can remove the variable var from b and c since the var variable in both classes have the same type the source file for a would get the declaration of type x named var the source file for a might also gain an import for the type x let s postpone the discussion of the scope of the variable var the refactoring tool can remove var from d since the storage in a is sufficient however the impact on the source code depends on whether there is a difference between the interface of x and y if there are methods or fields added in y that are not in x then by removing the variable var from d the refactoring tool must be sure to cast var back to a y in code that refers to var in a way that accesses the differences for instance if x and y have a method m then in d the invocation var m remains unchanged if y has a method n and no similar method is present in x or a parent class of x then d must change the code that looks like var n to y var n the refactoring tool cannot remove var from e since a variable of type w can not be stored in a class x a refactoring tool might change the type of the object in class a to w the effect of casting var to an x or a y type would be more widespread to remove var from f the refactoring tool would need to change the variable var s type to object since object is the base class for all classes thus would be a common storage type for ws and zs everywhere that var is used in any source files it must be cast to the appropriate type eliminating the benefit of compile time type checking removing var from g is even more difficult since a primitive type such as int does not derive from object the refactoring tool must find a way to store var for g java provides a series of immutable types that store the primitive types i e java lang integer to access the variable s value var would be replaced with var intvalue to set var the tool would create a new instance of the integer class and assign it to var since multithreaded programming is encouraged any operation that replaces an atomic action with a series of steps must be considered very carefully in this instance the assignment of a value to var is atomic but now includes the creation of an integer object followed by an assignment object instantiation is not atomic therefore if might be necessary to wrap the assignment of var in an appropriate synchronized block synchronized blocks are computationally very expensive and should not be used indiscriminately therefore an automated tool should not remove the variable var from g as a result of pushing var from b to a instead a refactoring tool might recommend renaming the variable var in g 2000 acm finding refactorings via change metrics reverse engineering is the process of uncovering the design and the design rationale from a functioning software system reverse engineering is an integral part of any successful software system because changing requirements lead to implementations that drift from their original design in contrast to traditional reverse engineering techniques which analyse a single snapshot of a system we focus the reverse engineering effort by determining where the implementation has changed since changes of object oriented software are often phrased in terms of refactorings we propose a set of heuristics for detecting refactorings by applying lightweight object oriented metrics to successive versions of a software system we validate our approach with three separate case studies of mature object oriented software systems for which multiple versions are available the case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system metrics object oriented frameworks refactoring reverse engineering software evolution finding refactorings via change metrics reverse engineering is the process of uncovering the design and the design rationale from a functioning software system reverse engineering is an integral part of any successful software system because changing requirements lead to implementations that drift from their original design in contrast to traditional reverse engineering techniques which analyse a single snapshot of a system we focus the reverse engineering effort by determining where the implementation has changed since changes of object oriented software are often phrased in terms of refactorings we propose a set of heuristics for detecting refactorings by applying lightweight object oriented metrics to successive versions of a software system we validate our approach with three separate case studies of mature object oriented software systems for which multiple versions are available the case studies suggest that the heuristics support the reverse engineering process by focusing attention on the relevant parts of a software system 2000 acm metrics object oriented frameworks refactoring reverse engineering software evolution stage value predictors and efficient newton iterations in implicit runge kutta methods the prediction of stage values in implicit runge kutta methods is important both for overall efficiency as well as for the design of suitable control strategies for the method the purpose of this paper is to construct good stage value predictors for implicit methods and to verify their behavior in practical computations we show that for stiffly accurate methods of low stage order it is necessary to use several predictors in other words a continuous extension for the method will not yield the best results we also investigate how to gain additional efficiency in the newton iterations used to correct the prediction error this leads to new control strategies with respect to refactorization of jacobians that seek to globally minimize total work per unit time of integration 1998 society for industrial and applied mathematics control strategies convergence implicit runge kutta newton iteration predictors the potential role of glycine 160 of human o sup 6 sup alkylguanine dna alkyltransferase in reaction with o sup 6 sup benzylguanine as determined by site directed mutagenesis and molecular modelling comparisons o 6 alkylguanine dna alkyltransferase atase repairs toxic mutagenic and carcinogenic o 6 alkylguanine o 6 alkg lesions in dna by a highly conserved reaction involving the stoichiometric transfer of the alkyl group to the active centre cysteine residue of the atase protein in the escherichia coli ada atase which is effectively refactory to inhibition by o 6 benzylguanine o 6 bzg the residue corresponding to glycine 160 g160 for the mammalian proteins of this class is replaced by a tryptophan w therefore to investigate the potential role of the g160 of the human atase hat protein in determining sensitivity to o 6 bzg site directed mutagenesis was used to produce a mutant protein hatg160w substituted at position 160 with a w residue the hatg160w mutant was found to be stably expressed and was 3 and 5 fold more sensitive than hat to inactivation by o 6 bzg in the absence and presence of additional calf thymus dna respectively a similar dna dependent increased sensitivity of the hatg160w mutant relative to wild type was also found for o 6 methylguanine mediated inactivation the potential role of the w160 residue in stabilising the binding of the o 6 alkg to the protein is discussed in terms of a homology model of the structure of hat the region occupied by g w 160 forms the site of a putative hinge that could be important in the conformational change that is likely to occur on dna binding three sequence motifs have been identified in this region which may influence o 6 bzg access to the active site ysgg or ysggg in mammals yagg in e coli ogt yags in dat from bacillus subtilis yrwg in e coli ada and salmonella typhimurium but ykws in saccharomyces cerevisina or yrggf in adab from b subtilis finally conformational and stereoelectronic analysis of the putative transition states for the alkyl transfer from a series of inactivators of hat including o 6 bzg was undertaken to rationalise the unexpected weak inhibition shown by the α π unsaturated electrophiles atase dna receptor o alkylguanine 6 o benzylguanine 6 o methylguanine 6 quasi real time dynamic simulation for dispatcher training simulator dts of east china power system this paper proposes the simulation models and algorithm of quasi real time dynamic simulation for dispatcher training simulator dts of east china power system to increase the simulation speed without sacrificing the simulation accuracy the dynamic behavior of the system is divided into transient and mid long term modes while artificial damping term is introduced to realize the smooth transition from one mode to the other adaptive reference frames and variable step sizes are employed for further increasing the simulation speed in addition fast topology algorithm based on width priority that can keep track with random switching operations and fast refactorization method based on sparse techniques used in this software package are also presented case studies of east china power system verify the validity of the above mentioned measures clinical implications of pleomorphic ventricular tachycardias on oral sotalol therapy in 90 consecutive patients with coronary artery disease and sustained monomorphic ventricular tachycardia who were treated with oral sotalol and underwent programmed stimulation to determine drug effectiveness the influence of sotalol on induced ventricular tachycardia morphology was retrospectively examined in 54 patients 60 sotalol rendered the tachycardia non inducible however contrary to drug testing with class i antiarrhythmic agents induction of multiple morphologies at baseline study did not predict failure of subsequent drug testing with sotalol in the remaining 36 patients 40 in whom sotalol did not modify inducibility 21 patients i e a total of 23 manifested at least one new morphology during electropharmacological testing on sotalol this effect was independent of the degree of left ventricular dysfunction infarct location and numbers of morphologies at baseline but corresponded with drug induced changes in refactoriness this observation may be related to a proarrhythmic effect of sotalol slowing of ventricular tachycardia rate and changes in morphology may have implications in patients receiving implantable cardioverter defibrilators or those undergoing ablative procedures drug testing pleomorphism refractoriness sotalol ventricular tachycardia binding objects to scenarios of use scenarios are a natural and effective medium for thinking in general and for design in particular our work seeks to develop a potential unification between recent scenario oriented work in object oriented analysis design methods and scenario oriented work in the analysis design of human computer interaction we illustrate this perspective by showing 1 how scenario questioning can be used to systematically interrogate the knowledge and practices of potential users and thereby to create object oriented analysis models that are psychologically valid 2 how depicting an individual object s point of view can serve as a pedagogical scaffold to help students of object oriented analysis see how to identify and assign object responsibilities in creating a problem domain model and 3 how usage scenarios can be employed to motivate and coordinate the design implementation refactoring and reuse of object oriented software 1994 academic press inc a timing model for the revised simplex method it is shown that the time spent in a widely implemented version of the revised simplex method for linear programming can be modeled as the classic inventory control system using an economic order quantity eoq formula an approximation to the optimal frequency for basis refactorization can be inferred such timing models can be used to significantly reduce the cost of routine applications as well as to predict the performance of new variants of the algorithm 1993 computational mathematical programming linear programming simplex method iterative bad data suppression applied to state estimators based on the augmented matrix method the augmented matrix method for power system state estimation combines simple conception good numerical behavior and computational efficiency concerning bad data processing however the method presents a difficulty the calculation of normalized residuals is not straightforward so that the implementation of conventional bad data identification procedures may become complicated this paper presents a technique for bad data processing based on weighted residuals and a nonquadratic cost function to circumvent that problem the weighted residuals are immediately available from the proposed formulation for the augmented matrix method the non quadratic cost function is piecewise quadratic constant and the break points are varied through the iterations to allow proper bad data identification the application of a diakoptical technique avoids the need for costly refactorizations of the augmented matrix the results from simulation studies carried out with the ieee 14 bus and 30 bus test systems are presented 1991 compensation technique for q limit enforcements in a constant complex jacobian power flow model this paper presents a simple and efficient compensation technique to deal with bus type switchings associated with q limit enforcements at voltage controlled pv buses in a constant jacobian power flow model the jacobian is expressed in the complex variable form resulting in reduced storage requirements as compared to real form of representation of the jacobian the structure of the jacobian is preserved irrespective of bus type switchings while q limit enforcements are performed at the pv buses this feature permits implementation of optimal ordering of buses in an efficient way while factorizing the jacobian matrix the jacobian is held constant throughout the load flow solution process incremental secondary injections isis are provided at the respective pv buses to maintain the specified voltages the required injections are computed from the proposed compensation model results indicate that the proposed technique is quite efficient as the number of iterations for solution to converge irrespective of bus type switchings remains same as that in unadjusted solution case because of its simplicity and efficiency the proposed model could become an alternative to the technique of matrix refactorization dealing with such problems of q limit enforcements associated with bus type switchings in constant matrix power flow methods the proposed model is tested on several power systems and the results are highly encouraging 1990 by hemisphere publishing corporation computing karmarkar projections quickly the paper presents a numerical method for computing the projections for karmarkar s new algorithm for linear programming the method is simple to implement fully exploits sparsity and appears in limited experimentation to have good stability properties preliminary numerical experience indicates that the method promises advantages over methods that refactor a matrix at every iteration 1988 the mathematical programming society inc cholesky factorization karmarkar s method linear programming rank one updates determination of the thermal conductivity of ceramics by the hot wire technique the thermal conductivity lambda of magnesium oxide based refractories was determined by the hot wire technique over the temperature range from 300 to 1000 degree c the results exhibit an error not exceeding the systematic error of this method plus or minus 10 percent the standard unit used for such measurement was improved by adding a high accuracy temperature regulator to the constant temperature maintenance system this reduced the time required for temperature stabilization in successive runs by a factor of 3 to 4 the experimental results were correlated by formulas which can be used in practical calculations of thermal conductivities of refactories in the above temperature range tests of refractoriness and conduction during clinical electrophysiologic studies yields and roles relationships between refractoriness and conduction and the likelihood of obtaining results from these tests have not been reported in detail in patients undergoing clinically indicated electrophysiologic testing therefore attempts were made in 100 such patients to determine the effective and functional refractory periods erp frp of the atrium atrioventricular av node and specialized ventricular conduction system during sinus rhythm and atrial pacing conduction was tested using incremental ramp atrial pacing to facilitate comparison of conduction and refractoriness effective and functional conduction periods ecp fcp were defined ecp longest pacing cycle length failing to conduct and fcp shortest conducted cycle length one or more determinations of atrial refractoriness were possible in 95 subjects but no measurable atrial conduction end points were attained in contrast av nodal erps or frps could be determined in only 47 using the extrastimulus technique in spite of multiple atrial drive pacing rates av nodal ecps and fcps could be determined in all 100 patients using ramp pacing comparison of atrial erps and frps in patients in whom av nodal refractoriness could and could not be determined showed no significant differences patients in whom it was not possible to determine av nodal erps and frps had shorter ecps and fcps than other patients thus inability to determine av nodal refractory periods was caused by prior atrial refractoriness atrial frp longer than av nodal erp block or refactoriness in the atrium or av node prevented detailed evaluation of the ventricular specialized conduction system in all but a few subjects av nodal ecps correlated with erps but were longer fcps also correlated but were shorter than the frps the maximum av node delay ah interval was the same with ramp pacing and extrastimulus testing during atrial pacing in the high right atrium refractory period testing is more useful than rapid pacing for evaluation of av nodal function particularly in large groups of patients such as those undergoing drug studies conduction testing will provide more nearly universal data than testing for refractoriness neither method is able to provide routine assessment of the ventricular specialized conduction system the factor structure and internal consistency of the self concept and motivation inventory what face would you wear preschool kindergarten form the self concept and motivation inventory what face would you wear preschool kindergarten form has the potential to be of use in measuring the academic self concept of preschoolers this study sought to determine if the theoretical three factor structure of the scamin could be recovered in a state wide sample of kindergarten students in 1986 5742 kindergarteners from tennessee schools participating in the reduced pupil teacher ratio project were given the preschool kindergarten form of the scamin the sample was drawn from 42 school districts in all geographic regions of tennessee and represented a mix of inner city urban rural and suburban schools the intercorrelation matrix of the 24 scamin items was analyzed by the principal components method and extracted factors were rotated to a varimax solution an initial analysis suggested the presence of an atheoretical factor and two items which appeared to be unrelated to any obtained factor subsequent refactoring of the scamin resulted in the successful recovery of the expected three factor structure cronbach s alpha for the scales academic self concept achievement investment and achievement needs were 0 666 0 599 and 0 598 respectively the results of this factor analysis of the early preschool kindergarten form of the scamin suggest both strengths and weaknesses in the factorial composition of the 24 scamin items users of the scamin are cautioned against a naive application of this instrument s scales 1988 sage publications all rights reserved partial matrix refactorization partial refactorization methods update the ldu factors of a matrix to reflect changes in some its elements this paper presents two new partial refactorization methods for sparse matrices test results indicate that they are significantly more efficient than existing techniques and have the potential to speed up a number of important power system problems copyright 1986 by the institute of electrical and electronics engineers inc partial matrix refactorization partial refactorization methods update the ldu factors of a matrix to reflect changes in some of its elements this paper presents two new partial refactorization methods for sparse matrices test results indicate that they are more efficient than existing techniques and have the potential to speed up a number of important power system problems sparse matrix factor modification in structural reanalysis structural reanalysis problems such as in nonlinear finite element analysis or optimum design involve progressive changes in the global stiffness matrix and its matrix factors although many studies have been devoted to the subject of matrix factor modification most investigations have dealt with the problem separately from sparse matrix methods this paper introduces a graph‐theoretic model for the forward solution procedure which is applicable for identifying the modified entries of the matrix factors due to changes in the original matrix applications of this graph‐theoretic model to existing refactorization methods are presented the relation between substructuring and sparse matrix ordering strategies and their effects on reanalysis are discussed modification of a sparse matrix associated with an n × n finite element grid ordered by the nested dissection scheme is analysed copyright 1985 john wiley sons ltd refractory arrhythmias invasive diagnosis and treatment the term refactory in relation to cardiac arrhythmias is defined and the method of electrophysiologic investigation of arrhythmias presented two modes of invasive arrhythmia treatment are available which afford favorable results namely tachycardia pacemaker and surgery indications for each of these procedures are discussed electron microscopic examination of the dissolution behavior of fusion cast glass furnace blocks 1 investigation of diffusion in a simple model system a detailed analysis of the corrosion of both traditional and fusion cast refactories is made difficult by the interaction of complex processes such as diffusion and convection a simple laboratory method has therefore been developed to determine by electron microprobe concentration distributions in the contact zone when there is exchange by diffusion without convection because convection is eliminated the method allows the properties of the glass refractory interface at the beginning of the experiment to be evaluated and the dissolution layer of the refractory to be measured to gain a better knowledge of the sodium enrichment occurring at the glass refractory interface diffusion experiments have been made with a simple model system comprising a sodium silicate glass and an alumina rich glass similar to the glassy phase in fusion cast refractories experimental results are presented in microphotographs and discussed the factorial structure of responses to perceptual complexity a series of figures differing in complexity were exposed to 44 nursing students ss were monitored for gsr and heart rate while they looked at each figure for as long as they wished they then rated each figure on 20 semantic differential type scales the data were factor analyzed by the principal axis method with communalities iterated by refactoring followed by varimax rotation four factors were extracted and the first three were identified as osgood s activity evaluative and potency factors it was suggested that the activity factor relates to arousal raising stimulus properties while the evaluative factor relates to arousal reducing or restraining stimulus properties 1971 psychonomic journals inc all rights reserved the measurement of speed in motor performance when the centroid method of factor analysis was applied to two sets of data on athletic performances three significant factors emerged strength velocity and dead weight scores on this speed factor were predicted by the multiple regression technique the factor loadings on the speed factor being used as the criterion correlations and these predicted scores were correlated with each of the other variables when the original tables augmented by the new speed variable were refactored the computed speed factor fell on the speed axis as a primary trait it is thus shown that it is possible to isolate and measure a factor which appears in variables under consideration only as a compound 1940 psychometric society towards a multi view approach to model driven refactoring model driven engineering an emerging trend in software engineering has enabled the application of refactoring to uml models one of the important steps in refactoring is the identification of refactoring opportunities within the model also referred to as model smells an object oriented system modeled by uml is built up from many different views model refactoring in recent proposals is applied to a single view in the model hence information from other views are either not considered or later synchronized for consistency preservation in this paper we outline an approach to refactor uml models using a multi view approach we exploit the inter view relationship to suggest model smells by combining information from each uml view we restrict our scope to one diagram from each uml view class diagram structural view sequence diagram behavioral view and use case diagram functional view for each model smell we describe a steps to detect the existence of the model smell b set of composite refactorings to remove the detected smell and c demonstration using a running example we also propose a multi view model refactoring framework to realize the approach proposed in this paper 2012 ieee class diagram model refactoring sequence diagram uml use case diagram refactoring meets spreadsheet formulas the number of end users who write spreadsheet programs is at least an order of magnitude larger than the number of trained programmers who write professional software we studied a corpus of 3691 spreadsheets and we found that their formulas are riddled with the same smells that plague professional software hardcoded constants duplicated expressions unnecessary complexity and unsanitized input these make spreadsheets difficult to read and expensive to maintain like automated refactoring in the object oriented domain spreadsheet refactoring can be transformative in this paper we present seven refactorings for spreadsheet formulas implemented in refbook a plugin for microsoft excel to evaluate the usefulness of refbook we employed three kinds of empirical methods first we conducted a user survey with 28 excel users to find out whether they preferred the refactored formulas second we conducted a controlled experiment with the same 28 participants to measure their productivity when doing manual refactorings third we performed a retrospective case study on the euses spreadsheet corpus with 3691 spreadsheets to determine how often we could apply the refactorings supported by refbook the results show i users prefer the improved quality of refactored formulas ii refbook is faster and more reliable than manual refactoring and iii the refactorings are widely applicable on average refbook is able to apply the refactorings in less than half the time that users performed the refactorings manually 92 54 of users introduced errors or new smells into the spreadsheet or were unable to complete the task 2012 ieee applying game theory to restructure pl sql code success of any organization is based on the quality of the information system which undergoes many alterations during its life cycle hence it can be quoted as an example for a live entity database is a core component in any information system and it gets affected due to change in business logic a popularly used data model in any organization is the relational model changes that are made in relational schema also modify the queries that access the relations it is really difficult to identify the set of queries that access the same relation in the case of large information system similarity measures concept is one of the techniques that are applied in object oriented programming for refactoring is used in this proposed system for restructuring procedures into packages by taking pl sql code as input the proposed system groups those queries or procedures that access the same relations into a single package the objective of this research is to determine whether the proposed methodology can be used as a mechanism to improve the maintainability of pl sql code this process of packaging is done by applying game theoiy so as to increase understandability and maintainability of the system medwell journals 2012 game theoiy nash equilibrium packaging pay off matrix pl sql refactoring restructuring structural similarity move code refactoring with dynamic analysis in order to reduce coupling and increase cohesion we refactor program source code previous research efforts for suggesting candidates of such refactorings are based on static analysis which obtains relations among classes or methods from source code however these approaches cannot obtain runtime information such as repetition count of loop dynamic dispatch and actual execution path therefore previous approaches might miss some refactoring opportunities to tackle this problem we propose a technique to find refactoring candidates by analyzing method traces we have implemented a prototype tool based on the proposed technique and evaluated the technique on two software systems as a result we confirmed that the proposed technique could detect some refactoring candidates which increase code quality 2012 ieee dynamic analysis move method refactoring refactoring software maintenance selecting refactorings an option based approach refactoring aims to improve the design of existing code to cope with foreseen software architecture evolution the selection of the optimum refactoring strategy can be a daunting task involving the identification of refactoring candidates the determination of which refactorings to apply and the assessment of the refactoring impact on software product quality characteristics as such the benefits from refactorings are measured from the quality advancements achieved through the application of state of the art structural quality assessments on refactored code perceiving refactoring trough the lens of value creation the optimum strategy should be the one that maximizes the endurance of the architecture in future imposed changes we argue that an alternative measurement and examination of the refactoring success is possible one that focuses on the balance between effort spent and anticipated cost minimization in this arena traditional quality evaluation methods fall short in examining the financial implications of uncertainties imposed by the frequent updates modifications and by the dynamics of the xp programming in this paper we apply simple real options analysis techniques and we perceive the selection of the optimum refactoring strategy as an option capable of generating value cost minimization upon adoption doing so we link the endurance of the refactored architecture to its true monetary value to get an estimation of the expected cost that is needed to apply the considered refactorings and to the effect of applying them in the cost of future adoptions we conducted a case study the results of the case study suggest that every refactoring can be associated with different benefit levels during system extension 2012 ieee architecture edurance real options refactorings when does a refactoring induce bugs an empirical study refactorings are as defined by fowler behavior preserving source code transformations their main purpose is to improve maintainability or comprehensibility or also reduce the code footprint if needed in principle refactorings are defined as simple operations so that are unlikely to go wrong and introduce faults in practice refactoring activities could have their risks as other changes this paper reports an empirical study carried out on three java software systems namely apache ant xerces and ar go uml aimed at investigating to what extent refactoring activities induce faults specifically we automatically detect and then manually validate 15 008 refactoring operations of 52 different kinds using an existing tool ref finder then we use the szz algorithm to determine whether it is likely that refactorings induced a fault results indicate that while some kinds of refactorings are unlikely to be harmful others such as refactorings involving hierarchies e g pull up method tend to induce faults very frequently this suggests more accurate code inspection or testing activities when such specific refactorings are performed 2012 ieee empirical studies fault inducing changes mining software repositories refactoring increasing clone maintenance support by unifying clone detection and refactoring activities context clone detection tools provide an automated mechanism to discover clones in source code on the other side refactoring capabilities within integrated development environments provide the necessary functionality to assist programmers in refactoring however we have observed a gap between the processes of clone detection and refactoring objective in this paper we describe our work on unifying the code clone maintenance process by bridging the gap between clone detection and refactoring method through an eclipse plug in called cedar clone detection analysis and refactoring we forward clone detection results to the refactoring engine in eclipse in this case the refactoring engine is supplied with information about the detected clones to which it can then determine those clones that can be refactored we describe the extensions to eclipse s refactoring engine to allow clones with additional similarity properties to be refactored results our evaluation of open source artifacts shows that this process yields considerable increases in the instances of clone groups that may be suggested to the programmer for refactoring within eclipse conclusion by unifying the processes of clone detection and refactoring in addition to providing extensions to the refactoring engine of an ide the strengths of both processes i e more significant detection capabilities and an established framework for refactoring can be garnered 2012 elsevier b v all rights reserved code clones maintenance refactoring an empirical investigation into the impact of refactoring on regression testing it is widely believed that refactoring improves software quality and developer s productivity by making it easier to maintain and understand software systems on the other hand some believe that refactoring has the risk of functionality regression and increased testing cost this paper investigates the impact of refactoring edits on regression tests using the version history of java open source projects 1 are there adequate regression tests for refactoring in practice 2 how many of existing regression tests are relevant to refactoring edits and thus need to be re run for the new version 3 what proportion of failure inducing changes are relevant to refactorings by using a refactoring reconstruction analysis and a change impact analysis in tandem we investigate the relationship between the types and locations of refactoring edits identified by reffinder and the affecting changes and affected tests identified by the faulttracer change impact analysis the results on three open source projects jmeter xmlsecurity and ant show that only 22 of refactored methods and fields are tested by existing regression tests while refactorings only constitutes 8 of atomic changes 38 of affected tests are relevant to refactorings furthermore refactorings are involved in almost half of the failed test cases these results call for new automated regression test augmentation and selection techniques for validating refactoring edits 2012 ieee empirical study refactoring regression testing software evolution empirically examining the parallelizability of open source software system an empirical study is presented that examines the potential to automatically parallelism using refactoring tools and or compilers 11 open source software static analysis methods are applied to each system to determine the number of for loops and free loops i e loops that can be parallized for each non free loop the various inhibitors to parallelization are determined and counted the results show that function calls within for loops represent the vast majority of inhibitors and thus pose the greatest roadblock to adapt and re engineer systems to better utilize parallelization this is somewhat contradictory to the literature which is focused primarily on the removal of data dependencies within loops additionally the historical data of inhibitor counts for the set of systems is presented over a ten year period the data shows few of the systems examined are increasing the potential to parallelizable loops over time 2012 ieee data dependency emprical study function calls parallelization inhibitors reegnineering high dimensional full inverse characterization of fractal volumes the present paper describes a methodology for the inverse identification of the complete set of parameters associated with the weirstrass mandelbrot w m function that can describe any fractal scalar field distribution of measured data defined within a volume our effort is motivated by the need to be able to describe a scalar field quantity distribution in a volume in order to be able to represent analytically various non homogeneous material properties distributions for engineering and science applications our method involves utilizing a refactoring of the w m function that permits defining the characterization problem as a high dimensional singular value decomposition problem for the determination of the so called phases of the function coupled with this process is a second level exhaustive search that enables the determination of the density of the frequencies involved in defining the trigonometric functions involved in the definition of the w m function numerical applications of the proposed method on both synthetic and actual volume data validate the efficiency and the accuracy of the proposed approach this approach constitutes a radical departure from the traditional fractal dimension characterization studies and opens the road for a very large number of applications and generalizes the approach developed by the authors for fractal surfaces to that of fractal volumes copyright 2012 by asme search based detection of high level model changes software models are iteratively refined restructured and evolved the detection and analysis of changes applied between two versions of a model are one of the most important tasks during evolution and maintenance activities in this paper we propose an approach to detect high level model changes in terms of refactorings our approach takes as input an exhaustive list of possible refactorings the initial model and revised model and generates as output a list of detected changes representing a sequence of refactorings a solution is defined as a combination of refactorings that should maximize as much as possible the similarity between the expected revised model and the generated model after applying the refactoring sequence on the initial model due to the huge number of possible refactoring combinations a heuristic method is used to explore the space of possible solutions to this end we used and adapted genetic algorithm as global heuristic search the validation results on various versions of real world models taken from an open source project confirm the effectiveness of our approach 2012 ieee model evolution refactoring detection search based model driven software engineering entropy based bug prediction using support vector regression predicting software defects is one of the key areas of research in software engineering researchers have devised and implemented a plethora of defect bug prediction approaches namely code churn past bugs refactoring number of authors file size and age etc by measuring the performance in terms of accuracy and complexity different mathematical models have also been developed in the literature to monitor the bug occurrence and fixing process these existing mathematical models named software reliability growth models are either calendar time or testing effort dependent the occurrence of bugs in the software is mainly due to the continuous changes in the software code the continuous changes in the software code make the code complex the complexity of the code changes have already been quantified in terms of entropy as follows in hassan 9 in the available literature few authors have proposed entropy based bug prediction using conventional simple linear regression slr method in this paper we have proposed an entropy based bug prediction approach using support vector regression svr we have compared the results of proposed models with the existing one in the literature and have found that the proposed models are good bug predictor as they have shown the significant improvement in their performance 2012 ieee bug prediction complexity of code change entropy support vector regression bad smells and refactoring methods for gui test scripts testing the gui graphical user interface of a software application is typically accomplished by developing a gui test script composed of sequences of events and assertions a gui test script is in a sense similar to the source code of a program since events and assertions are like source code statements which are executed line by line therefore like source code a gui test script may have bad smells and refactoring is an effective technique that can eradicate bad smells making the script better and easier to maintain this paper studies the bad smells a gui test script may have and the refactoring methods that can be applied to remove the bad smells a total of 11 bad smells are identified and 16 refactoring methods are proposed the refactoring methods have been implemented in a gui testing tool called gtt to support the automatic refactoring of gui test scripts 2012 ieee gui testing refactoring smell test script identifying improvement potential in evolving product line infrastructures 3 case studies successful software products evolve continuously to meet the changing stakeholder requirements for software product lines an additional challenge is that variabilities characteristics that vary among products change as well over time that challenge must be carefully tackled during the evolution of the product line infrastructure this is a significant problem for many software development organizations as practical guidelines on how to evolve core assets and especially source code are missing this paper investigates how to achieve good enough variability management during the evolution of variation in software design and implementation assets as a first contribution we present a customizable goal based approach which helps to identify improvement potential in existing core assets to ease evolution to find concrete ways to improve the product line infrastructure we list the typical symptoms of variability code smells and show how to refine them to root causes questions and finally to metrics that can be extracted from large code bases as a second main contribution we show how this method was applied to evaluate the reuse quality of three industrial embedded systems these systems are implemented in c or c and use conditional compilation as the main variability mechanism we also introduce the analysis and refactoring tool set that was used in the case studies and discuss the lessons learnt copyright 2012 acm goal based product line measurement industrial case study product line code evolution pulse e variability code smells identification and application of extract class refactorings in object oriented systems refactoring is recognized as an essential practice in the context of evolutionary and agile software development recognizing the importance of the practice modern ides provide some support for low level refactorings a notable exception in the list of supported refactorings is the extract class refactoring which is conceived to simplify large complex unwieldy and less cohesive classes in this work we describe a method and a tool implemented as an eclipse plugin designed to fulfill exactly this need our method involves three steps a recognition of extract class opportunities b ranking of the identified opportunities in terms of the improvement each one is anticipated to bring about to the system design and c fully automated application of the refactoring chosen by the developer the first step relies on an agglomerative clustering algorithm which identifies cohesive sets of class members within the system classes the second step relies on the entity placement metric as a measure of design quality through a set of experiments we have shown that the tool is able to identify and extract new classes that developers recognize as coherent concepts and improve the design quality of the underlying system 2011 elsevier inc all rights reserved clustering object oriented programming refactoring software reengineering constructing models for predicting extract subclass refactoring opportunities using object oriented quality metrics context refactoring is a maintenance task that refers to the process of restructuring software source code to enhance its quality without affecting its external behavior inspecting and analyzing the source code of the system under consideration to identify the classes in need of extract subclass refactoring esr is a time consuming and costly process objective this paper explores the abilities of several quality metrics considered individually and in combination to predict the classes in need of esr method for a given a class this paper empirically investigates using univariate logistic regression analysis the abilities of 25 existing size cohesion and coupling metrics to predict whether the class is in need of restructuring by extracting a subclass from it in addition models of combined metrics based on multivariate logistic regression analysis were constructed and validated to predict the classes in need of esr and the best model is justifiably recommended we explored the statistical relations between the values of the selected metrics and the decisions of the developers of six open source java systems with respect to whether the classes require esr results the results indicate that there was a strong statistical relation between some of the quality metrics and the decision of whether esr activity was required from a statistical point of view the recommended model of metrics has practical thresholds that lead to an outstanding classification of the classes into those that require esr and those that do not conclusion the proposed model can be applied to automatically predict the classes in need of esr and present them as suggestions to developers working to enhance the system during the maintenance phase in addition the model is capable of ranking the classes of the system under consideration according to their degree of need of esr 2012 elsevier b v all rights reserved class cohesion class coupling class quality extract subclass refactoring logistic regression analysis object oriented design improving software maintenance size metrics a case study automated report generation system for particle monitoring in hard disk drive industry a software maintenance size can be used to predict maintenance effort or maintenance time however the traditional maintenance size metric only relies on line of source code loc which hardly is suitable for object oriented software this research proposed four new maintenance size metrics based on number of classes number of methods average number of methods per class and weighted methods per class an automated report generation system in hdd industry args pms was used as a case study to measure the performance of each proposed metric we found that for enhanced software maintenance tasks maintenance size based on an average number of methods per class ms mc gave the best performance in predicting maintenance time for a refactoring maintenance task maintenance size based on line of code ms loc weighted methods per class ms wmc and average methods per class ms mc were the best better and good estimators for predicting maintenance time respectively on average the maintenance size based on weighted methods per class gave the best performance 2012 ieee estimated time to maintenance maintenance size object oriented software maintenance metric proceedings c conference on computer science and software engineering c3s2e 12 the proceedings contain 19 papers the topics discussed include comparing and combining genetic and clustering algorithms for software component identification from object oriented code an adaptive computational model for emotion regulation strategies based on gross theory an effective ensemble method for hierarchical clustering evolving dungeon crawler levels with relative placement unifying and refactoring dmf to support concurrent jini and jms dms in gipsy using poetry as a teaching tool for the humanities to learn computer science concepts a complexity analysis of a jacobi method for lattice basis reduction quick mlcs a new algorithm for the multiple longest common subsequence problem a survey on formal methods in self adaptive systems incorporating shape into spatially aware adaptive object segmentation algorithm knowledge representation for self adaptive behavior and fleshing out gestures augmenting 3d interaction proceedings of the 5th workshop on refactoring tools wrt 12 the proceedings contain 12 papers the topics discussed include what kind of and how clones are refactored a case study of three oss projects integration of smells and refactorings within the eclipse modeling framework an approach and tool for synchronous refactoring of uml diagrams and models using model to model transformations computation of refactoring plans from refactoring strategies using htn planning let s make refactoring tools user extensible scripting a refactoring with rascal and eclipse identifying extract method refactoring candidates automatically a language independent parallel refactoring framework refactoring tools for dynamic languages custom declarative refactoring in netbeans and refactoring development simplified proceedings of the 5th workshop on refactoring tools wrt 12 the proceedings contain 12 papers the topics discussed include what kind of and how clones are refactored a case study of three oss projects integration of smells and refactorings within the eclipse modeling framework an approach and tool for synchronous refactoring of uml diagrams and models using model to model transformations computation of refactoring plans from refactoring strategies using htn planning let s make refactoring tools user extensible scripting a refactoring with rascal and eclipse identifying extract method refactoring candidates automatically a language independent parallel refactoring framework refactoring tools for dynamic languages custom declarative refactoring in netbeans and refactoring development simplified identifying extract method refactoring candidates automatically refactoring becomes an essential activity in software development process especially for large and long life projects extract method is one of the most frequently used refactorings to address code smells such as long and incohesive methods and duplicated code automated means of identifying opportunities for refactoring can make the software development process faster and more efficient in this paper an abstraction for methods viz data and structure dependency dsd graph and an algorithm viz longest edge removal algorithm to find extract method refactoring candidates is proposed 2012 acm automatic refactoring candidate identification data and structure dependency graph extract method refactoring longest edge removal algorithm refactoring fifth workshop on refactoring tools wrt 2012 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of specific transformations that need to be performed tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial program analysis and applying the transformations may affect many locations throughout a program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in modern day ides this workshop is a continuation of a series of previous workshops ecoop 2007 oopsla 2008 and 2009 icse 2011 see http refactoring info wrt where researchers and developers of refactoring tools can meet and discuss recent ideas and work and view tool demonstrations copyright 2012 acm program analysis program manipulation refactoring transformation 2012 6th international workshop on software clones iwsc 2012 proceedings the proceedings contain 24 papers the topics discussed include an accurate estimation of the levenshtein distance using metric trees and manhattan distance a novel approach based on formal methods for clone detection claims and beliefs about code clones do we agree as a community a survey clone detection using rolling hashing suffix trees and dagification a case study dispersion of changes in cloned and non cloned code java bytecode clone detection via relaxation on code fingerprint and semantic web reasoning mining object oriented design models for detecting identical design structures safe clone based refactoring through stereotype identification and iso generation a case study on applying clone technology to an industrial application framework industrial application of clone change management system a common conceptual model for clone detection results and filtering clones for individual user based on machine learning analysis safe clone based refactoring through stereotype identification and iso generation most advanced existing tools for clone based refactoring propose a limited number of predefined clone removal transformations that can be applied automatically typically under user control this fixed set of refactorings usually guarantee that semantics is preserved but is inherently limited to generally applicable transformations extract method pull up method etc this tool design rules out many potential domain specific or application specific clone removals such cases are ordinarily recognized by humans as stereotypes derived from a higher level concept and manually replaced with an appropriate abstraction thus in current tools generality is sacrificed for the safety of the transformation this paper proposes an alternative approach in which the spectrum of refactoring techniques is open including manual interventions while keeping strong safety guarantees based on the notion of iso generation our method can operate on multiple languages and has been prototyped on a subset of a real world legacy asset containing c and cobol programs with promising results 2012 ieee clones maintainability refactoring safety using structural and semantic information to support software refactoring in the software life cycle the internal structure of the system undergoes continuous modifications these changes push away the source code from its original design often reducing its quality in such cases refactoring techniques can be applied to improve the design quality of the system approaches existing in literature mainly exploit structural relationships present in the source code e g method calls to support the software engineer in identifying refactoring solutions however also semantic information is embedded in the source code by the developers e g the terms used in the comments this research investigates about the usefulness of combining structural and semantic information to support software refactoring 2012 ieee refactoring semantic information testing cardinality estimation models in sql server reliable query optimization greatly depends on accurate cardinality estimation ce which is inherently inexact as it relies on statistical information in commercial database systems cardinality estimation models are sophisticated components that over years of development can become very complex the code that implements cardinality estimation models like most complex software systems that handle a large space of possible inputs and conditions can deviate from its original architecture and design points over time hence it is often necessary to refactor and redesign the entire system to accommodate new inputs and conditions and also to reflect existing ones in a more intentional way in this paper we describe such an exercise the replacement and validation of a new cardinality estimation model in microsoft sql server we describe the motivation behind this change and provide a high level sketch of the empirical methods used to ensure that the new cardinality estimation model satisfies its goals while minimizing the potential risk of plan regressions for existing customers copyright 2012 acm cardinality estimation experimental methodology query optimization software quality systematic abstraction of abstract machines we describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well established abstract machines for higher order and imperative programming languages to demonstrate the technique and support our claim we transform the cek machine of felleisen and friedman proc of the 14th acm sigact sigplan symp prin program langs 1987 pp 314 325 a lazy variant of krivine s machine higher order symb comput vol 20 2007 pp 199 207 and the stack inspecting cm machine of clements and felleisen acm trans program lang syst vol 26 2004 pp 1029 1052 into abstract interpretations of themselves the resulting analyses bound temporal ordering of program events predict return flow and stack inspection behavior and approximate the flow and evaluation of by need parameters for all of these machines we find that a series of well known concrete machine refactorings plus a technique of store allocated continuations leads to machines that abstract into static analyses simply by bounding their stores these machines are parameterized by allocation functions that tune performance and precision and substantially expand the space of analyses that this framework can represent we demonstrate that the technique scales up uniformly to allow static analysis of realistic language features including tail calls conditionals mutation exceptions first class continuations and even garbage collection in order to close the gap between formalism and implementation we provide translations of the mathematics as running haskell code for the initial development of our method copyright cambridge university press 2012 aspect mining using model based clustering legacy systems contain critical and complex business code that has been in use for a long time this code is difficult to understand maintain and evolve in large part due to crosscutting concerns software system features such as persistence logging and error handling whose implementation is spread across multiple modules aspect oriented techniques separate crosscutting concerns from the base code using separate modules called aspects and thus simplify the legacy code aspect mining techniques identify aspect candidates so that the legacy code can then be refactored into aspects this study shows that model based clustering using a carefully selected vector space of features can be more effective than extant aspect mining methods based on heuristic methods as such hierarchical or partitional clustering three model based algorithms were experimentally compared against existing heuristic methods such as k means clustering and agglomerative hierarchical clustering using six different vector space models model based algorithms performed better in not spreading the methods of the concerns across the multiple clusters and were significantly better at partitioning the data such that given an ordered list of clusters fewer clusters and methods were needed to be analyzed to find all the concerns in addition model based algorithms automatically determined the optimal number of clusters a great advantage over the heuristic based algorithms lastly the newly defined vector space models performed better relative to aspect mining than the previously defined vector space models 2012 ieee aspect mining aspect oriented programming crosscutting concerns fan in metric heuristic based clustering model based clustering software metrics refactoring access control policies for performance improvement in order to facilitate managing authorization access control architectures are designed to separate the business logic from an access control policy to determine whether a user can access which resources a request is formulated from a component called a policy enforcement point pep located in application code given a request a policy decision point pdp evaluates the request against an access control policy and returns its access decision i e permit or deny to the pep with the growth of sensitive information for protection in an application an access control policy consists of a larger number of rules which often cause a performance bottleneck to address this issue we propose to refactor access control policies for performance improvement by splitting a policy handled by a single pdp into its corresponding multiple policies with a smaller number of rules handled by multiple pdps we define seven attribute set based splitting criteria to facilitate splitting a policy we have conducted an evaluation on three subjects of reallife java systems each of which interacts with access control policies our evaluation results show that 1 our approach preserves the initial architectural model in terms of interaction between the business logic and its corresponding rules in a policy and 2 our approach enables to substantially reduce request evaluation time for most splitting criteria copyright 2012 acm access control extensible access control markup language performance policy decision point policy enforcement point refactoring identifying tailoring and suggesting form template method refactoring opportunities with program dependence graph many research efforts have been performed on removing code clones especially it is highly expected that clone removal techniques by applying form template method have high applicability because they can be applied to code clones that have some gaps consequently some researchers have proposed techniques to support refactoring with form template method however previous research efforts still have some issues in this paper we propose a new technique with program dependence graph to resolve these issues by using program dependence graph we can handle trivial differences that are unrelated to behavior of a program consequently the proposed method can suggest more appropriate removal candidates than previously proposed techniques 2012 ieee code clones form template method program dependence graph refactoring software maintenance automated refactoring using design differencing software systems that undergo repeated addition of functionality commonly suffer a loss of quality in their underlying designs termed design erosion this leads to the maintenance of a system becoming increasingly difficult and time consuming during its lifetime refactoring can reduce the effects of design erosion but this process requires significant effort on the part of the maintenance programmer research into automated refactoring has had some success in reducing the effort involved however source code refactoring uses refactoring steps that are too small to effect major design changes design level refactoring is also possible but these approaches operate on design models and do little to help in the subsequent refactoring of the source code in this paper we present a novel refactoring approach that refactors a program based both on its desired design and on its source code the maintenance programmer first creates a desired design a uml class model for the software based on the current software design and their understanding of how it may be required to evolve then the source code is refactored using the desired design as a target this resulting source code has the same behavior as the original but its design more closely correlates to the desired design we conducted an investigation using several open source java applications to determine how precisely it is possible to refactor program source code to a desired design our findings were that the original program could be refactored to the desired design with an accuracy of over 90 hence demonstrating the viability of automated refactoring using design differencing 2012 ieee automated design improvement design differencing refactoring tool search based refactoring proceedings 2012 16th european conference on software maintenance and reengineering csmr 2012 the proceedings contain 69 papers the topics discussed include a multi objective technique to prioritize test cases based on latent semantic indexing identifying tailoring and suggesting form template method refactoring opportunities with program dependence graph understanding structural complexity evolution a quantitative analysis anomalies in rule adapted workflows a taxonomy and solutions for vbpmn on the comparison of user space and kernel space traces in identification of software anomalies a market based bug allocation mechanism using predictive bug lifetimes industrial comparability of student artifacts in traceability recovery research an exploratory survey a gpu based architecture for parallel image aware version control uncovering causal relationships between software metrics and bugs archimetrix improved software architecture recovery in the presence of design deficiencies and on the relevance of code anomalies for identifying architecture degradation symptoms semantic technologies and e learning towards an entity centric approach for learning management systems in the past the application of semantic technologies to educational settings attracted a lot of attention in particular regarding those approaches and software tools able to enrich categorize and retrieve learning objects in this paper we present a different perspective specifically the evolution of a traditionally engineered learning platform into a semantic enabled application the semantic enrichment addresses two issues a the unique identification of entities inside the contents and b adding new features to the platform without refactoring it through the usage of semantic representation of information we believe that these two modifications are missing elements for semantic learning and in order to apply these changes we integrated our virtual communities platform with the entity centric tools developed in the okkam eu funded project okkam tools provide a solution to uniquely identifying entities inside data and contents specifically using the entity name system ens which supplies a persistent identifier called okkamid to any entity included in the dataset and advanced entity matching methods for detecting the occurrence of the same entity in different contexts this allows a deeper connection between entities information available inside content inside the platform and outside the platform once the entity in the lms has been profiled it is possible to connect any content where the different occurrences of the same entity have been used and also to connect any other content outside the learning platform where that entity has been identified for example web pages or social networks furthermore we extended a domain ontology sioc for the conceptual representation needs of the application and created an rdf graph mapped onto the database in order to add new functionalities to our virtual community platform taking advantage of the inference processes available through a reasoner and substituting some parts of the business logic of the application a new design defects classification marrying detection and correction previous work classify design defects based on symptoms long methods large classes long parameter lists etc and treat separately detection and correction steps this paper introduces a new classification of defects using correction possibilities thus correcting different code fragments appending to specific defect category need approximately the same refactoring operations to apply to this end we use genetic programming to generate new form of classification rules combining detection and correction steps we report the results of our validation using different open source systems our proposal achieved high precision and recall correction scores 2012 springer verlag berlin heidelberg design defects genetic programming refactoring search based software engineering software maintenance tracing your maintenance work a cross project validation of an automated classification dictionary for commit messages a commit message is a description of a change in a version control system vcs besides the actual description of the change it can also serve as an indicator for the purpose of the change e g a change to refactor code might be accompanied by a commit message in the form of refactored class xy to improve readability we would label the change in our example a perfective change according to maintenance literature this simplified example shows how it is possible to classify a change by its commit message however commit messages are unstructured textual data and efforts to automatically label changes into categories like perfective have only been applied to a small set of projects within the same company or the same community in this work we present a cross project evaluated and valid mapping of changes to the code base and their purpose that is usable without any customization on any open source project we provide further the eclipse plug in subcat which allows for a comfortable analysis of projects from within eclipse by using subcat we are able to automatically assess if a commit to the code was e g a bug fix or a refactoring this information is very useful for e g developer profiling or locating bad smells in modules 2012 springer verlag berlin heidelberg a data centric approach to synchronization concurrency related errors such as data races are frustratingly difficult to track down and eliminate in large object oriented programs traditional approaches to preventing data races rely on protecting instruction sequences with synchronization operations such control centric approaches are inherently brittle as the burden is on the programmer to ensure that all concurrently accessed memory locations are consistently protected data centric synchronization is an alternative approach that offloads some of the work on the language implementation data centric synchronization groups fields of objects into atomic sets to indicate that these fields must always be updated atomically each atomic set has associated units of work that is code fragments that preserve the consistency of that atomic set synchronization operations are added automatically by the compiler we present an extension to the java programming language that integrates annotations for data centric concurrency control the resulting language called aj relies on a type system that enables separate compilation and supports atomic sets that span multiple objects and that also supports full encapsulation for more efficient code generation we evaluate our proposal by refactoring classes from standard libraries as well as a number ofmultithreaded benchmarks to use atomic sets our results suggest that data centric synchronization is easy to use and enjoys low annotation overhead while successfully preventing data races moreover experiments on the specjbb benchmark suggest that acceptable performance can be achieved with a modest amount of tuning 2012 acm concurrent object oriented programming data races programming model serializability attributed graph transformation with inheritance efficient conflict detection and local confluence analysis using abstract critical pairs inheritance is an important and widely spread concept enabling the elegant expression of hierarchy in object oriented software programs or models it has been defined for graphs and graph transformations enhancing the applicability of this formal technique up to now for the analysis of transformations with inheritance a flattening construction has been used which yields all the well known results for graph transformation but results in a large number of graphs and rules that have to be analyzed in this paper we introduce a new category of typed attributed graphs with inheritance for the detection of conflicts between graph transformations on these graphs the notion of abstract critical pairs is defined this allows us to perform the analysis on polymorphic rules and transformations without the need for flattening which significantly increases the efficiency of the analysis and eases the interpretation of the analysis results the new main result is the local confluence theorem for typed attributed graph transformation with inheritance using abstract critical pairs all constructions and results are demonstrated on an example for the analysis of refactorings 2011 elsevier b v all rights reserved critical pair analysis inheritance m adhesive category with nacs typed attributed graph transformation a precise method method interaction based cohesion metric for object oriented classes the building of highly cohesive classes is an important objective in object oriented design class cohesion refers to the relatedness of the class members and it indicates one important aspect of the class design quality a meaningful class cohesion metric helps object oriented software developers detect class design weaknesses and refactor classes accordingly several class cohesion metrics have been proposed in the literature most of these metrics are applicable based on low level design information such as attribute references in methods some of these metrics capture class cohesion by counting the number of method pairs that share common attributes a few metrics measure cohesion more precisely by considering the degree of interaction through attribute references between each pair of methods however the formulas applied by these metrics to measure the degree of interaction cause the metrics to violate important mathematical properties thus undermining their construct validity and leading to misleading cohesion measurement in this paper we propose a formula that precisely measures the degree of interaction between each pair of methods and we use it as a basis to introduce a low level design class cohesion metric lscc we verify that the proposed formula does not cause the metric to violate important mathematical properties in addition we provide a mechanism to use this metric as a useful indicator for refactoring weakly cohesive classes thus showing its usefulness in improving class cohesion finally we empirically validate lscc using four open source software systems and eleven cohesion metrics we investigate the relationship between lscc other cohesion metrics and fault occurrences in classes our results show that lscc is one of three metrics that explains more accurately the presence of faults in classes lscc is the only one among the three metrics to comply with important mathematical properties and statistical analysis shows it captures a measurement dimension of its own this suggests that lscc is a better alternative when taking into account both theoretical and empirical results as a measure to guide the refactoring of classes from a more general standpoint the results suggest that class quality as measured in terms of fault occurrences can be more accurately explained by cohesion metrics that account for the degree of interaction between each pair of methods 2012 acm attribute class cohesion low level design method method method interaction object oriented software quality refactoring unsupervised restructuring of object oriented software systems using self organizing feature maps this paper addresses the problem of software restructuring a method often used during software maintenance in order to improve the structure and therefore the maintainability of a software system improper software structure is the main factor that negatively in uences the maintainability of the software system and thus improving it becomes a major requirement maintenance activities such as adding new functionalities or correcting previously undetected errors within the software system imply continuous restructuring of the code we aim at automatically identifying using an unsupervised approach the refactorings that would improve the internal structure of a software system for this purpose a self organizing feature map will be used we evaluate our approach on the open source case study jhotdraw and on a real software system providing a comparison with similar existing approaches and emphasizing this way the potential of our proposal 2012 issn 1349 4198 clustering refactoring self organizing map software engineering unsupervised learning refactoring techniques for aggressive object inlining in java applications object inlining oi is a known optimization in object oriented programming in which referenced objects of class b are inlined into their referencing objects of class a by making all fields and methods of class b part of class a the optimization saves all the new operations of b type objects from class a and at the same time replaces all indirect accesses from a to fields of b by direct accesses to the best of our knowledge in spite of the significant performance potential of the oi optimization reported performance measurements were relatively moderate this is because an aggressive oi optimization requires complex analysis and code transformations to overcome problems like multiple references to the inlinable object object references that escape their object scope etc to extract the full potential of oi we propose a two stage process the first stage includes automatic analysis of the source code that informs the user via comments in the ide about code transformations that are needed in order to enable or to maximize the potential of the oi optimization in the second stage the oi optimization is applied automatically on the source code as a code refactoring operation or preferably as part of the compilation process prior to javac run we show that this half automated technique helps to extract the full potential of oi the proposed oi refactoring process also determines the order of applying the inlinings of the objects and enables us to apply inlinings of objects created inside a method thus enabling us to reach better performance gain in this work we also include an evaluation of the oi optimization effects on multithreaded applications running on multicore machines the comments and the oi transformation were implemented in the eclipse jdt java development tools plugin the system was then applied on the specjbb2000 source code along with profiling data collected by the eclipse tptp plugin the proposed system achieved 46 improvement in performance 2011 springer science business media llc eclipse inlining java refactoring building an expert system to assist system refactorization the separation of concerns is an important issue in the building of maintenable systems aspect oriented programming aop is a software paradigm that allows the encapsulation of those concerns that crosscut a system and can not be modularized using current paradigms such as object oriented programming in this way aop increases the software modularization and reduces the impact when changes are made in the system in order to take advantage of the benefits of aop the legacy oo systems should be migrated to migrate object oriented systems to aspect oriented ones specific refactorings for aspects should be used this is a complex and tedious task for the developer because he she needs to know how the refactorings should be applied and under what context therefore it is desirable to have tools that help him her through the process in this article we present an expert software agent named refactoringrecommender that assists the developer during a refactorization of a system the agent uses a markovian algorithm with the goal of predicting the needed restructurings 2011 elsevier ltd all rights reserved aspect refactoring aspect oriented software development expert systems interface agents the impact of accounting for special methods in the measurement of object oriented class cohesion on refactoring and fault prediction activities class cohesion is a key attribute that is used to assess the design quality of a class and it refers to the extent to which the attributes and methods of the class are related typically classes contain special types of methods such as constructors destructors and access methods each of these special methods has its own characteristics which can artificially affect the class cohesion measurement several metrics have been proposed in the literature to indicate class cohesion during high or low level design phases the impact of accounting for special methods in cohesion measurement has not been addressed for most of these metrics this paper empirically explores the impact of including or excluding special methods on cohesion measurements that were performed using 20 existing class cohesion metrics the empirical study applies the metrics that were considered to five open source systems under four different scenarios including 1 considering all special methods 2 ignoring only constructors 3 ignoring only access methods and 4 ignoring all special methods this study empirically explores the impact of including special methods in cohesion measurement for two applications of interest to software practitioners including refactoring and predicting faulty classes the results of the empirical studies show that the cohesion values for most of the metrics considered differ significantly across the four scenarios and that this difference significantly affects the refactoring decisions but does not significantly affect the abilities of the metrics to predict faulty classes 2011 elsevier inc all rights reserved class cohesion class quality cohesion metric fault prediction object oriented design refactoring special methods evaluating the extended refactoring guidelines refactoring is a process that improves the internal structure of a program without changing its externally observable behavior on the contrary in many cases refactoring support for java outputs semantically non equivalent code after refactoring also the research on refactoring has mostly focused on restructuring a class its parent and child classes only however refactoring will not be complete without updating other components in the program that may be impacted because of this change in particular clients and test classes associated with the restructured classes may be affected by this change and hence must be updated accordingly in this work we have identified the exact nature of changes required in these effected components and the elements contained in them using this information we have developed extended refactoring guidelines that address semantic violations of program behavior during refactoring we also report our findings from an experiment performed to judge the usability and effectiveness of the extended guidelines for move method refactoring 2012 ieee maintenance postconditions preconditions refactoring unit testing an empirical study of refactoring in the context of fanin and fanout coupling the aim of refactoring is to reduce software complexity and hence simplify the maintenance process in this paper we explore the impact of refactorings on fanin and fanout coupling metrics through extraction of refactoring data from multiple releases of five java open source systems we first considered how a single refactoring modified these metric values what happened when refactorings had been applied to a single class in unison and finally what influence a set of refactorings had on the shape of fan in and fan out distributions results indicated that on average refactored classes tended to have larger fanin and fan out values when compared with non refactored classes where evidence of multiple different refactorings applied to the same class was found the net effect in terms of fanin and fan out coupling values was negligible 2011 ieee coupling refactoring software metric distribution proceedings of the 27th ieee international conference on software maintenance icsm 2011 the proceedings contain 75 papers the topics discussed include fault interaction and its repercussions a novel approach to regression test selection for j2ee applications automated change impact analysis for agent systems impactscale quantifying change impact to predict faults in large software systems identifying performance deviations in thread pools mining java class naming conventions generating natural language summaries for crosscutting source code concerns expanding identifiers to normalize source code vocabulary using tactic traceability information models to reduce the risk of architectural degradation during system maintenance on integrating orthogonal information retrieval methods to improve traceability link recovery method engineering based legacy to soa migration method identifying overly strong conditions in refactoring implementations and crossing the boundaries while analyzing heterogeneous component based software systems visualizing the refactoring of classes via clustering when developing object oriented classes it is difficult to determine how to best reallocate the members of large complex classes to create smaller more cohesive ones clustering techniques can provide guidance on how to solve this allocation problem however inappropriate use of clustering can result in a class structure that is less maintainable than the original the extc visualizer helps the programmer understand the class structure by visually emphasizing important features of the class s members and their interrelationships more importantly it helps users see how various clustering algorithms group the class s members these insights help a programmer choose appropriate techniques for refactoring large classes copyright 2011 australian computer society inc clustering graph maintainability refactoring software visualization refactoring of a beef cattle farm simulator software systems are continuing changing because of new functionality has to be incorporated or the exiting one has to be changed systems have to be well evolved otherwise the will not be easily changed aspect orientation provides mechanisms to evolve and maintain systems by encapsulating systems crosscutting concerns in aspects we have developed an object oriented grazedbased beef cattle simulator which has maintenance and evolution problems for this reason in order to take advantages of the aspect orientation we present in this work the migration of the simulator to the aspect orientation the crosscutting concerns identified in the object oriented system are presented and how these crosscutting concerns are transformed into aspect in the target aspect oriented system 2005 ieee aspect mining aspect oriented development aspect refactoring system evolution truerefactor an automated refactoring tool to improve legacy system and application comprehensibility manual refactoring is a complicated process requiring intimate knowledge of the software design and underlying intended behavior of a system this knowledge is not always available fully automated refactoring using a meta heuristic based search that is dependent on software quality metrics and code smells as a guide eliminates the need for the developer to be intimately connected to the software under modification computer applications in industry and engineering benefit significantly from new approaches to self correcting refactoring software truerefactor is an automated refactoring tool that significantly improves the comprehensibility of legacy systems the goal of truerefactor is to modify legacy object oriented systems in order to increase the understandability maintainability and reusability aspects of legacy software and to simultaneously generate new uml documentation in order to help developers understand the changes being made this paper presents the research behind the design as well as a technical overview of the implementation of truerefactor we summarize the research goals that truerefactor addresses and identify opportunities where it can be actively utilized computer science 2011 proceedings of the 34th australasian computer science conference acsc 2011 the proceedings contain 18 papers the topics discussed include building instance knowledge network for word sense disambiguation human action recognition using silhouette histogram performance improvement of vertical handoff algorithms for qos support over heterogeneous wireless networks resource provisioning based on leases preemption in intergrid jointly compatible pair linking for visual tracking with probabilistic priors web based visualizations supporting rehabilitation of heart failure patients by promoting behavioral change visualizing the refactoring of classes via clustering optimistic and efficient concurrency control for asynchronous collaborative systems a dynamic archive based niching particle swarm optimizer using a small population size optimized relative lempel ziv compression of genomes enhancing the believability of embodied conversational agents through environment self and interaction awareness and dynamic visualization of software state proceedings of the isca 26th international conference on computers and their applications cata 2011 the proceedings contain 25 papers the topics discussed include scheduling energy usage in a residential energy management system using the branch and bound technique learning the meaning of words as associations between invariant forms measuring component specification implementation concordance with semantic mutation testing a distributed cooperative search algorithm using multiple contexts and pruning knowledge discovery in us census data using attribute oriented induction with fuzzy concept hierarchy software engineering online and hybrid learning models at psu twitter reporter breaking news detection and visualization through the geo tagged twitter network virtual city a gaming tool for training and education active learning mashups for tablet classrooms discrete time model for pwm converters in discontinuous capacitor voltage mode and gui tools and generated code refactoring to reveal intent seke 2011 proceedings of the 23rd international conference on software engineering and knowledge engineering the proceedings contain 146 papers the topics discussed include visual specification of component based slow intelligence systems design of component based slow intelligence systems and application to social influence analysis slow intelligence system and network management a case study extending software quality models a sample in the domain of semantic technologies a technology of profiling inter procedural paths a software engineering approach to user driven control of the microgrid a comparative study of different strategies for predicting software quality criteria of human software evaluation feature selection approach a dual clustering approach to the extract class refactoring an empirical study of software metrics selection using support vector machine software defect prediction for high dimensional and class imbalanced data and specification and runtime verification of api constraints on interacting objects optimal refactoring policy for agile information systems maintenance a control theoretic approach many information systems development companies are facing the question on how to apply agile methods in information systems maintenance ism performing correction of software defects in ism inevitably degenerates program structure on the other hand agile methods provide refactoring to improve program structure without changing its behavior this paper builds an optimal control model to balance the tradeoff between defect correction and refactoring we answer three questions first is that optimal to perform parallel defect correction and refactoring second how to determine the iteration length for agile ism if team wants to include refactoring in the iteration third how long the iteration should be if team wants to improve program s structure to a certain level at the end of the iteration to our knowledge this paper is the pioneer in understanding agile ism policy analytically managerial implications of the results are also discussed in the paper 2011 by the ais icis administrative office all rights reserved agile maintenance defect correction optimal control refactoring identifying refactoring through formal model based on data flow graph identifying refactoring is an important step of bad smell removal process many developers have problem identifying refactoring e g novice developers are not sure which refactorings should be applied even skilled developers may need to spend a lot of time doing this manually identifying refactoring techniques can alleviate these problems for developers in our previous work we proposed refactoring filtering conditions rfc that identify candidate refactorings for removing long method bad smell these conditions analyze internal structure inside a method with data flow analysis our research improves these rfc based on more refined data flow analysis and presents its formal description this research also demonstrates an approach of using the improved rfc of three refactorings moreover we conducted an experiment to compare the efficiency of the results of our approach with that of our previous work and that of developer suggestion 2011 ieee bad smell maintainability refactoring software maintenance complete high dimensional inverse characterization of fractal surfaces the present paper describes a methodology for the inverse identification of the complete set of parameters associated with the weirstrass mandelbrot w m function that can describe any rough surface known by its profilometric or topographic data our effort is motivated by the need to determine the mechanical electrical and thermal properties of contact surfaces between deformable materials that conduct electricity and heat and require an analytical representation of the surfaces involved our method involves utilizing a refactoring of the w m function that permits defining the characterization problem as a high dimensional singular value decomposition problem for the determination of the so called phases of the function coupled with this process is a second level exhaustive search that enables the determination of the density of the frequencies involved in defining the trigonometric functions involved in the definition of the w m function our approach proves that this is the only additional parameter that needs to be determined for full characterization of the w m function as the rest can be selected arbitrarily numerical applications of the proposed method on both synthetic and actual elevation data validate the efficiency and the accuracy of the proposed approach this approach constitutes a radical departure from the traditional fractal dimension characterization studies and opens the road for a very large number of applications 2011 by asme automatic handling of global variables for multi threaded mpi programs conventional implementations of the mpi standard tend to associate one mpi process per processor which limits their support for modern multi core platforms an increasingly popular approach is to combine mpi with threads where mpi processes are light weight threads global variables in legacy mpi applications however present a challenge because they may be accessed by multiple mpi threads simultaneously thus transforming legacy mpi applications to become thread safe in such mpi execution environments requires proper handling of global variables in this paper we present three approaches to automatically eliminate global variables to ensure thread safety for an mpi program these approaches include a a compilerbased refactoring technique using a photran based tool as an example which automates the source to source transformation for programs written in fortran b a technique based on a global offset table got and c a technique based on thread local storage tls the second and third methods automatically detect global variables and privatize them for each thread at runtime we discuss the advantages and disadvantages of these approaches and compare their performance using both synthetic benchmarks such as the nas benchmarks and a real scientific application the flash code 2011 ieee common agile practices in software processes objective to investigate studies about software processes looking for practices which can be used to obtain agility in software processes method a systematic review including seven search engines was executed in feb 2010 to apply the defined criteria to select papers and extract information regarding working practices bringing agility to software processes results from 6696 retrieved papers 441 were selected to support the identification of 236 occurrences of 51 distinct practices associated with the concept of agility their descriptions were deeply analyzed and consolidated after discarding those which appeared in the technical literature in a small amount of papers 17 agile practices were identified conclusion although further studies are necessary to evaluate the efficacy of these 17 agile practices 12 of them have been more commonly approached in the software projects and could be primarily considered test driven development continuous integration pair programming planning game onsite customer collective code ownership small releases metaphor refactoring sustainable pace simple design and coding standards 2011 ieee agile methods agile practices agile software processes evidence based software engineering systematic review e quality a graph based object oriented software quality visualization tool recently with increasing maintenance costs studies on software quality are becoming increasingly important and widespread because high quality software means more easily maintainable software measurement plays a key role in quality improvement activities and metrics are the quantitative measurement of software design quality in this paper we introduce a graph based object oriented software quality visualization tool called e quality e quality automatically extracts quality metrics and class relations from java source code and visualizes them on a graph based interactive visual environment this visual environment effectively simplifies comprehension and refactoring of complex software systems our approach assists developers in understanding of software quality attributes by level categorization and intuitive visualization techniques experimental results show that the tool can be used to detect software design flaws and refactoring opportunities 2011 ieee design flaw detection design patterns eclipse object oriented metrics refactoring software maintenance software quality software visualization bridging light cone and nrqcd approaches asymptotic behavior of b inf c inf electromagnetic form factor this work aims at illustrating that for a class of leading twist hard exclusive reactions involving two heavy quarkonia the light cone approach when equipped with the strategy of refactorization of the light cone distribution amplitude of quarkonium can be employed to elegantly reproduce the corresponding predictions made in the nonrelativistic qcd nrqcd factorization approach order by order in perturbative expansion taking the electromagnetic form factor of the b c meson at large momentum transfer q 2 as a concrete example we compare the results obtained from both nrqcd based and light cone based calculations through the next to leading order nlo in α s while at the leading order lo in both velocity and 1 q 2 expansion and explicitly confirm their mutual agreement as a byproduct we apply our nlo result to explore certain features about the asymptotic behavior of the heavy light meson form factor we also address the major theoretical obstacles that prevent us from establishing an analogous equivalence between these two approaches for the double charmonium production process of phenomenological interest e e → j φ η c sissa 2011 asymptotic freedom nlo computations qcd design smell detection with similarity scoring and fingerprinting preliminary study design smells in software models reduce the software quality smells identification supports the refactoring which is a way to improve the quality of models and subsequently increasing software readability maintainability and extensibility we propose a preliminary study of using similarity scoring algorithm and fingerprinting algorithm for design smells detection in the future we plan to do extensive verification on several large projects integrate these methods to the smells detection framework and compare effectiveness with other approaches 2011 ieee algorithms anti patterns design smells fingerprinting refactoring similarity scoring a classification of refactoring methods based on software quality attributes refactoring is the process of improving the design of existing code by changing its internal structure without affecting its external behavior refactoring tends to improve software quality by improving design improving readability and reducing bugs there are many different refactoring methods each having a particular purpose and effect consequently the effect of refactoring methods on software quality attributes may vary moreover it is often unclear to software designers how to use refactoring methods to improve specific quality attributes in this paper we propose a classification of refactoring methods based on their measurable effect on software quality attributes this in turn helps software designers choose appropriate refactoring methods that will improve the quality of their designs based on the design objectives it also enables them to predict the quality drift caused by using particular refactoring methods 2011 king fahd university of petroleum and minerals refactoring classification software metrics software quality attributes software refactoring supporting design model refactoring for improving class responsibility assignment although a responsibility driven approach in object oriented analysis and design methodologies is promising the assignment of the identified responsibilities to classes simply class responsibility assignment cra is a crucial issue to achieve design of higher quality the grasp by larman is a guideline for cra and is being put into practice however since it is described in an informal way using a natural language its successful usage greatly relies on designers skills this paper proposes a technique to represent grasp formally and to automate appropriate cra based on them our computerized tool automatically detects inappropriate cra and suggests alternatives of appropriate cras to designers so that they can improve a cra based on the suggested alternatives we made preliminary experiments to show the usefulness of our tool 2011 springer verlag class responsibility assignment grasp object oriented design identification of extract method refactoring opportunities for the decomposition of methods the extraction of a code fragment into a separate method is one of the most widely performed refactoring activities since it allows the decomposition of large and complex methods and can be used in combination with other code transformations for fixing a variety of design problems despite the significance of extract method refactoring towards code quality improvement there is limited support for the identification of code fragments with distinct functionality that could be extracted into new methods the goal of our approach is to automatically identify extract method refactoring opportunities which are related with the complete computation of a given variable complete computation slice and the statements affecting the state of a given object object state slice moreover a set of rules regarding the preservation of existing dependences is proposed that exclude refactoring opportunities corresponding to slices whose extraction could possibly cause a change in program behavior the proposed approach has been evaluated regarding its ability to capture slices of code implementing a distinct functionality its ability to resolve existing design flaws its impact on the cohesion of the decomposed and extracted methods and its ability to preserve program behavior moreover precision and recall have been computed employing the refactoring opportunities found by independent evaluators in software that they developed as a golden set 2011 elsevier inc extract method refactoring module decomposition program slicing towards a classification of logical dependencies origins a case study logical dependencies are implicit relationships established between software artifacts that have evolved together software engineering researchers have investigated this kind of dependency to assess fault proneness detect design issues infer code decay and predict likely changes in code despite the acknowledged relation between logical dependencies and software quality the nature of the logical dependencies is unknown in the literature most authors hypothesize about their origins but no empirical study has been conducted to investigate the real nature of these dependencies in this paper we investigated the origins of logical dependencies by means of a case study involving a java floss project we mined the project repository filtered out irrelevant data based on statistical analyses and performed a manual inspection of the logical dependencies to identify their origins using information from the revision comments code diffs and informal interviews held with the developers of the analyzed project preliminary results showed that logical dependencies involved files that changed together for a series of different reasons which ranged from changing software license to refactoring classes that belonged to the same semantic class 2011 acm case study change coupling empirical software engineering logical coupling logical dependencies mining software repositories software evolution search based software engineering third international symposium ssbse 2011 proceedings the proceedings contain 20 papers the topics discussed include exploiting decomposability using recombination in genetic algorithms an exploratory discussion conducting and analyzing empirical studies in search based software engineering ten years of search based software engineering a bibliometric analysis on parameter tuning in search based software engineering a fuzzy approach to requirements prioritization multi level automated refactoring using design exploration comparing metaheuristic algorithms for error detection in java programs applications of model reuse when using estimation of distribution algorithms to test concurrent software cooperative co evolutionary optimization of software project staff assignments and job scheduling an ant colony optimization approach to the software release planning with dependent requirements and integration test of classes and aspects with a multi evolutionary and coupling based approach clone detection in repositories of business process models over time process model repositories tend to accumulate duplicate fragments also called clones as new process models are created or extended by copying and merging fragments from other models this phenomenon calls for methods to detect clones in process models so that these clones can be refactored as separate subprocesses in order to improve maintainability this paper presents an indexing structure to support the fast detection of clones in large process model repositories the proposed index is based on a novel combination of a method for process model decomposition specifically the refined process structure tree with established graph canonization and string matching techniques experiments show that the algorithm scales to repositories with hundreds of models the experimental results also show that a significant number of non trivial clones can be found in process model repositories taken from industrial practice 2011 springer verlag rank based refactoring decision support two studies refactoring can result in code with improved maintainability and is considered a preventive maintenance activity managers of large projects need ways to decide where to apply scarce resources when performing refactoring there is a lack of tools for supporting such decisions we introduce a rank based software measure driven refactoring decision support approach to assist managers the approach uses various static measures to develop a weighted rank ranking classes or packages that need refactoring we undertook two case studies to examine the effectiveness of the approach specifically we wanted to see if the decision support tool yielded results similar to those of human analysts managers and in less time so that it can be used to augment human decision making in the first study we found that our approach identified classes as needing refactoring that were also identified by humans in the second study a hierarchical approach was used to identify packages that had actually been refactored in 15 releases of the open source project tomcat we examined the overlap between the tool s findings and the actual refactoring activities the tool reached 100 86 7 recall on the package class level though these studies were limited in size and scope it appears that this approach is worthy of further examination 2011 springer verlag london limited decision support maintainability refactoring software engineering abstracting abstract machines a systematic approach to higher order program analysis predictive models are fundamental to engineering reliable software systems however designing conservative computable approximations for the behavior of programs static analyses remains a difficult and error prone process for modern high level programming languages what analysis designers need is a principled method for navigating the gap between semantics and analytic models analysis designers need a method that tames the interaction of complex languages features such as higher order functions recursion exceptions continuations objects and dynamic allocation we contribute a systematic approach to program analysis that yields novel and transparently sound static analyses our approach relies on existing derivational techniques to transform high level language semantics into low level deterministic state transition systems with potentially infinite state spaces we then perform a series of simple machine refactorings to obtain a sound computable approximation which takes the form of a non deterministic state transition systems with finite state spaces the approach scales up uniformly to enable program analysis of realistic language features including higher order functions tail calls conditionals side effects exceptions firstclass continuations and even garbage collection 2011 acm using software metrics to select refactoring for long method bad smell refactoring is a technique for improving software structure without changing its behavior which can be used to remove bad smells and increases software maintainability but only few approaches have been proposed to address the identification of appropriate refactorings specifically our research proposes a method to select refactoring based on software metrics which are defined in terms of data flow and control flow graphs the method consist of 4 steps 1 calculate metrics 2 find candidate refactoring by using refactoring filtering condition rfc 3 apply a suite of candidate refactorings and compute maintainability and 4 identify the refactoring that gives the highest maintainability we demonstrate out approach by giving an example of removing a long method bad smell in a customer class in a movie rental system our approach proves to be able to suggest an appropriate set of refactoring techniques such as extract method replace temp with query and decompose condition to solve the long method bad smell 2011 ieee bad smell long method refactoring identification software maintainability software metrics ecoop 2011 object oriented programming 25th european conference proceedings the proceedings contain 26 papers the topics discussed include a co relational model of data for large shared data banks an empirical study of object protocols in the wild the beauty and the beast separating design from algorithm using structure based recommendations to facilitate discoverability in apis mining evolution of object usage improving the tokenization of identifier names revisiting information hiding reflections on classical and nonclassical modularity worlds controlling the scope of side effects can we avoid high coupling expressiveness simplicity and users a refactoring constraint language and its application to eiffel types regions and effects for safe programming with object oriented parallel frameworks tunable static inference for generic universe types verifying multi object invariants with relationships and frequency estimation of virtual call targets for object oriented programs prioritizing design debt investment opportunities technical debt is the technical work developers owe a system typically caused by speeding up development e g before a software release approaches such as code smell detection have been developed to identify particular kinds of debt e g design debt up until now code smell detection has been used to help point to components that need to be freed from debt by refactoring to date a number of methods have been described for finding code smells in a system however typical debt properties such as the value of the debt and interest rate to be paid have not been well established this position paper proposes an approach to using cost benefit analysis to prioritize technical debt reduction work by ranking the value and interest of design debt caused by god classes the method is based on metric analysis and software repository mining and is demonstrated on a commercial software application at a mid size development company the results are promising the method helps to identify which refactoring activities should be performed first because they are likely to be cheap to make yet have significant effect and which refactorings should be postponed due to high cost and low payoff 2011 acm code smells design debt god class maintainability refactoring technical debt analyzing and forecasting near miss clones in evolving software an empirical study effort for development and maintenance of complex large software is believed to have dependency on the amount of duplicated code fragments code clones present in code bases for example clones need to be carefully and consistently maintained and or refactored for preventing accidental error propagation thus it is important to understand the proportion and evolution of clones in evolving software systems for cost estimation or the like this paper presents a study on the evolution of near miss clones at release level in medium to large open source software systems of different types operating systems database systems editors etc written in three different programming languages namely c c and java using a hybrid clone detector nicad we detected both exact and near miss clones at different levels of similarity applying statistical methods we investigated from different dimensions the evolution of both exact and near miss clones and also forecasted the amount of clones in future releases of the software systems our study offers significant insights into the existence and evolution of code clones and their relationships with programming language or paradigm and program size 2011 ieee grading code quality of programming assignments based on bad smells programming assignments pas are very important to many computer science courses traditionally the grading of a programming assignment is based mainly on the correctness of the code however from the view point of software engineering education such a grading does not encourage students to develop code that is easy to read and maintain thus the authors created a grading policy that considers not only the correctness but also the quality of the code expecting students to follow the most important discipline the source code should be written in a way that is readable and maintainable instead of using pure subjective code quality ratings bad smells are used to assess the code quality of pas when a pa is graded by the teaching assistant a list of bad smells is identified and given to the student so that the student can use refactoring methods to improve the code 2011 ieee jdeodorant identification and application of extract class refactorings evolutionary changes in object oriented systems can result in large complex classes known as god classes in this paper we present a tool developed as part of the jdeodorant eclipse plugin that can recognize opportunities for extracting cohesive classes from god classes and automatically apply the refactoring chosen by the developer 2011 authors clustering object oriented programming refactoring software reengineering identifying method friendships to remove the feature envy bad smell nier track we propose a novel approach to identify move method refactoring opportunities and remove the feature envy bad smell from source code the proposed approach analyzes both structural and conceptual relationships between methods and uses relational topic models to identify sets of methods that share several responsabilities i e friend methods the analysis of method friendships of a given method can be used to pinpoint the target class envied class where the method should be moved in the results of a preliminary empirical evaluation indicate that the proposed approach provides meaningful refactoring opportunities 2011 acm refactoring relational topic model source code quality fourth workshop on refactoring tools wrt 2011 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of transformations that need to be performed tool support for refactoring is essential because checking the preconditions of refactoring often requires nontrivial program analysis and applying transformations may affect many locations throughout a program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in today s ides this workshop is a continuation of a series of previous workshops ecoop 2007 oopsla 2008 and 2009 see http refactoring info wrt where researchers and developers of refactoring tools can meet and discuss recent ideas and work and view tool demonstrations 2011 acm program analysis program manipulation refactoring transformation non essential changes in version histories numerous techniques involve mining change data captured in software archives to assist engineering efforts for example to identify components that tend to evolve together we observed that important changes to software artifacts are sometimes accompanied by numerous non essential modifications such as local variable refactorings or textual differences induced as part of a rename refactoring we developed a tool supported technique for detecting non essential code differences in the revision histories of software systems we used our technique to investigate code changes in over 24 000 change sets gathered from the change histories of seven long lived open source systems we found that up to 15 5 of a system s method updates were due solely to non essential differences we also report on numerous observations on the distribution of non essential differences in change history and their potential impact on change based analyses 2011 acm differencing algorithms mining software repositories software change analysis a visualization method of program dependency graph for identifying extract method opportunity refactoring is important for efficient software maintenance however tools supports are highly required for refactoring because manual operations of refactoring are troublesome and error prone this paper proposes a technique that suggests extract method candidates automatically extract method refactoring is to create a new method from a code fragment in an existing method previous research efforts showed that the extract method refactoring is often performed prior to other refactorings so that it is important to support extract method refactoring previous studies have proposed methods that suggest extract method candidates based on linage or complexity however it is originally desirable to divide methods based on their functionalities this paper uses the strength of data connection between sentences in the source code we deem that strongly connected data expresses a single function this paper proposes a technique that suggests extract method candidates based on strongly connected data 2011 acm program dependency graph refactoring visualization a bottom up approach to understand functional programs one affective way to carry out a program comprehension process is by refactoring the source code in this paper we explore this approach in the functional programming paradigm on haskell programs specifically as result we have identified many correlations between the traditional procedural and object oriented program comprehension process and the so called understanding oriented refactorings in the functional programming context besides we have identified a catalog of refactorings used to improve program efficiency which applied in reverse order are valuable for program understanding purposes coupled to these refactorings there is a calculational process by means of which we obtain a full formal description of program functionality all together a bottom up program comprehension strategy in the functional setting is described 2011 acm formal methods program comprehension refactorings 4th workshop on refactoring tools wrt 2011 co located with icse 2011 proceedings the proceedings contain 8 papers the topics discussed include code motion for api migration fixing sql injection vulnerabilities in java a visualization method of program dependency graph for identifying extract method opportunity automated acceptance test refactoring a security aware refactoring tool for java programs a refactoring tool to extract gpu kernels understanding the longevity of code smells preliminary results of an explanatory survey impact of refactoring on quality code evaluation and code imp a tool for automated search based refactoring a security aware refactoring tool for java programs refactoring is a useful practice in developing and maintaining software since it improves the design of existing code without changing its external behavior therefore contemporary integrated development environments tend to include refactoring tools that support automatic transformations of source code unfortunately some of the popular refactoring transformations make existing code vulnerable although they improve its maintainability the existence of vulnerable code is still a serious issue for many software systems this paper describes a tool with support for a new class of refactoring concerning software security which is built as an eclipse plug in it helps programmers to easily know the adverse impact of code changes on security vulnerabilities in the application of refactoring and provides them with a chance to determine if they could accept or should cancel the applied refactoring consequently they feel safe to improve the maintainability of existing code without missing security vulnerabilities newly inserted into the code to evaluate the capability of this tool we made an experiment with it the experimental results show the usefulness of the tool and also reveal several remaining issues to be tackled 2011 acm access control information flow refactoring software restructuring extracting code clones for refactoring using combinations of clone metrics code clone detection tools may report a large number of code clones while software developers are interested in only a subset of code clones that are relevant to software development tasks such as refactoring our research group has supported many software developers with the code clone detection tool ccfinder and its gui front end gemini gemini shows clone sets i e a set of code clones identical or similar to each other with several clone metrics including their length and the number of code clones however it is not clear how to use those metrics to extract interesting code clones for developers in this paper we propose a method combining clone metrics to extract code clones for refactoring activity we have conducted an empirical study on a web application developed by a japanese software company the result indicates that combinations of simple clone metric is more effective to extract refactoring candidates in detected code clones than individual clone metric 2011 acm code clone industrial case study refactoring a visualization method of program dependency graph for identifying extract method opportunity copyright 2011 acm refactoring is important for efficient software maintenance however tools supports are highly required for refactoring because manual operations of refactoring are troublesome and error prone this paper proposes a technique that suggests extract method candidates automatically extract method refactoring is to create a new method from a code fragment in an existing method previous research efforts showed that the extract method refactoring is often performed prior to other refactorings so that it is important to support extract method refactoring previous studies have proposed methods that suggest extract method candidates based on linage or complexity however it is originally desirable to divide methods based on their functionalities this paper uses the strength of data connection between sentences in the source code we deem that strongly connected data expresses a single function this paper proposes a technique that suggests extract method candidates based on strongly connected data program dependency graph refactoring visualization wrt 2011 proceedings of the 4th workshop on refactoring tools co located with icse 2011 the proceedings contain 8 papers the topics discussed include code motion for api migration fixing sql injection vulnerabilities in java a visualization method of program dependency graph for identifying extract method opportunity automated acceptance test refactoring a security aware refactoring tool for java programs a refactoring tool to extract gpu kernels understanding the longevity of code smells preliminary results of an explanatory survey impact of refactoring on quality code evaluation and code imp a tool for automated search based refactoring a security aware refactoring tool for java programs copyright 2011 acm refactoring is a useful practice in developing and maintaining software since it improves the design of existing code without changing its external behavior therefore contemporary integrated development environments tend to include refactoring tools that support automatic transformations of source code unfortunately some of the popular refactoring transformations make existing code vulnerable although they improve its maintainability the existence of vulnerable code is still a serious issue for many software systems this paper describes a tool with support for a new class of refactoring concerning software security which is built as an eclipse plug in it helps programmers to easily know the adverse impact of code changes on security vulnerabilities in the application of refactoring and provides them with a chance to determine if they could accept or should cancel the applied refactoring consequently they feel safe to improve the maintainability of existing code without missing security vulnerabilities newly inserted into the code to evaluate the capability of this tool we made an experiment with it the experimental results show the usefulness of the tool and also reveal several remaining issues to be tackled access control information flow refactoring software restructuring two dimensional fast response flood modeling desktop parallel computing and domain tracking emergency flood management is enhanced by using models that can estimate the timing and location of flooding typically flood routing and inundation prediction is accomplished by using one dimensional 1d models these have been the models of choice because they are computationally simple and quick however these models do not adequately represent the complex physical processes present for shallow flows located in the floodplain or in urban areas two dimensional 2d models developed on the basis of the full hydrodynamic equations can be used to represent the complex flow phenomena that exist in the floodplain and are therefore recommended by the national research council for increased use in flood analysis studies the major limitation of these models is the increased computational cost two dimensional flood models are prime candidates for parallel computing but traditional methods equipment e g message passing paradigm are more complex in terms of code refactoring and hardware setup in addition these hardware systems may not be available or accessible to modelers conducting flood analyses this paper presents a 2d flood model that implements multithreading for use on now prevalent multicore computers this desktop parallel computing architecture has been shown to decrease computation time by 14 times on a 16 processor computer and when coupled with a wet cell tracking algorithm has been shown to decrease computation by as much as 310 times these accomplishments make high fidelity flood modeling more feasible for flood inundation studies using readily available desktop computers 2011 american society of civil engineers domain tracking flood modeling java multithreading multicore multiprocessor computing parallel computing shallow water equations ranking refactoring suggestions based on historical volatility the widespread acceptance of refactorings as a simple yet effective approach to improve the design of object oriented systems has stimulated an effort to develop semi automatic tools for detecting design flaws with simultaneous suggestions for their removal however even in medium sized projects the number of detected occurrences can be so large that the refactoring process becomes intractable for the designer it is reasonable to expect that some of the suggested refactorings will have a significant effect on the improvement of maintainability while others might be less important this implies that the suggested solutions can be ranked according to one or more criteria in this paper we propose the exploitation of past source code versions in order to rank refactoring suggestions according to the number proximity and extent of changes related with the corresponding code smells the underlying philosophy is that code fragments which have been subject to maintenance tasks in the past are more likely to undergo changes in a future version and thus refactorings involving the corresponding code should have a higher priority to this end historical volatility models drawn from the field of forecasting risk in financial markets are investigated as measures expressing the urgency to resolve a given design problem the approach has been integrated into an existing smell detection eclipse plug in while the evaluation results focus on the forecast accuracy of the examined models 2011 ieee code smell forecasting models historical volatility refactoring software history software repositories architectural refactoring of a mission critical integration application a case study architecture refactoring can be thought of as a process of changing the architecture of an existing application without altering the functional behavior it is to improve the operational and developmental quality attributes such as performance stability complexity and maintainability due to changing business expectations as well as runtime environments architecture refactoring may need to be done incrementally over multiple software release cycles in this industry experience report we present an architectural refactoring of a mission critical integration application after it was originally implemented we discuss the drivers behind the refactoring and the approach initial results from the refactoring show significant improvement of stability and throughput of the system we also present recommendations on architectural refactoring and discuss the importance of key performance indicators that drive architecture refactoring architecture refactoring software maintenance incremental clone detection and elimination for erlang programs a well known bad code smell in refactoring and software maintenance is the existence of code clones which are code fragments that are identical or similar to one another this paper describes an approach to incrementally detecting similar code based on the notion of least general common abstraction or anti unification as well as a framework for user controlled incremental elimination of code clones within the context of erlang programs the clone detection algorithm proposed in this paper achieves 100 precision high recall rate and is user customisable regarding the granularity of the clone classes reported by detecting and eliminating clones in an incremental way we make it possible for the tool to be used in an interactive way even with large codebases both the clone detection and elimination functionalities are integrated with wrangler a tool for interactive refactoring of erlang programs we evaluate the approach with various case studies 2011 springer verlag code clone detection erlang program analysis program transformation refactoring software maintenance wrangler an empirical study of long lived code clones previous research has shown that refactoring code clones as soon as they are formed or discovered is not always feasible or worthwhile to perform since some clones never change during evolution and some disappear in a short amount of time while some undergo repetitive similar edits over their long lifetime toward a long term goal of developing a recommendation system that selectively identifies clones to refactor as a first step we conducted an empirical investigation into the characteristics of long lived clones our study of 13558 clone genealogies from 7 large open source projects over the history of 33 25 years in total found surprising results the size of a clone the number of clones in the same group and the method level distribution of clones are not strongly correlated with the survival time of clones however the number of developers who modified clones and the time since the last addition or removal of a clone to its group are highly correlated with the survival time of clones this result indicates that the evolutionary characteristics of clones may be a better indicator for refactoring needs than static or spatial characteristics such as loc the number of clones in the same group or the dispersion of clones in a system 2011 springer verlag code clones empirical study refactoring software evolution code bad smells a review of current knowledge fowler et al identified 22 code bad smells to direct the effective refactoring of code these are increasingly being taken up by software engineers however the empirical basis of using code bad smells to direct refactoring and to address trouble in code is not clear i e we do not know whether using code bad smells to target code improvement is effective this paper aims to identify what is currently known about code bad smells we have performed a systematic literature review of 319 papers published since fowler et al identified code bad smells 2000 to june 2009 we analysed in detail 39 of the most relevant papers our findings indicate that duplicated code receives most research attention whereas some code bad smells e g message chains receive little this suggests that our knowledge of some code bad smells remains insufficient our findings also show that very few studies report on the impact of using code bad smells with most studies instead focused on developing tools and methods to automatically detect code bad smells this indicates an important gap in the current knowledge of code bad smells overall this review suggests that there is little evidence currently available to justify using code bad smells copyright 2010 john wiley sons ltd code bad smells empirical software engi neering refactoring systematic literature review correlation between object oriented metrics and refactoring repeated code modification lowers code quality and impacts object oriented system design object oriented metrics have proven as indicators of problems in system design they have been grouped in minimal sets known as quality models to assess object oriented system quality improvement can be gained by establishing relationships between quality characteristics and metrics computed from object oriented diagrams quality models include metrics that can produce better code in object oriented systems code quality can also be gained with refactoring refactoring is used to reduce complexity and eliminate redundant code it is important to identify when and where to use refactoring there are many different approaches this work presents early stage analysis and focuses on exploring whether object oriented metrics can be used as indicators where in the code refactoring can be used through multiple itera tions of successive measurement and refactoring relation between metric values and need of refactoring can be concluded 2011 springer verlag automated metric collection metric based refactoring object oriented metrics object oriented quality models refactor ing identifying extract class refactoring opportunities using structural and semantic cohesion measures approaches for improving class cohesion identify refactoring opportunities using metrics that capture structural relationships between the methods of a class e g attribute references semantic metrics e g c3 metric have also been proposed to measure class cohesion as they seem to complement structural metrics however until now semantic relationships between methods have not been used to identify refactoring opportunities in this paper we propose an extract class refactoring method based on graph theory that exploits structural and semantic relationships between methods the empirical evaluation of the proposed approach highlighted the benefits provided by the combination of semantic and structural measures and the potential usefulness of the proposed method as a feature for software development environments 2010 elsevier inc all rights reserved cohesion coupling empirical studies extract class refactoring graph theory maxflow mincut object oriented inheritance metrics in the context of cognitive complexity it is important to identify modules that are fault prone or exhibit evidence of high cognitive complexity as these modules require corrective actions such as increased source code inspection refactoring or performing more exhaustive testing this can lead to a better quality software system it has been found that inheritance has an impact on the cognitive complexity of a software system in this paper two inheritance metrics based on cognitive complexity one at class level cci class complexity due to inheritance and another at program level aci average complexity of a program due to inheritance have been proposed for object oriented software systems additionally one more metric mc method complexity has been proposed to calculate the complexity of a method these proposed metrics are compared with some well known object oriented inheritance metrics by calculating their values for three random c programs it has been observed that cci and aci are better to represent cognitive complexity due to inheritance than other well known class level and program level inheritance metrics cognitive complexity object oriented systems software metrics search based refactoring based on unfolding of graph transformation systems international conference on graph transformation 2010 doctoral symposium 2010 to improve scalability and understandability of search based refactoring in this paper we propose a formulation based on graph transformation which allows us to make use of partial order semantics and an associated analysis technique the approximated unfolding of graph transformation systems we use graphs to represent object oriented software architectures at the class level and graph transformations to describe their refactoring operations in the unfolding we can identify dependencies and conflicts between refactoring steps leading to an implicit and therefore more scalable representation of the search space an optimisation algorithm based on the ant colony paradigm is used to explore this search space aiming to find a sequence of refactoring steps that leads to the best design at a minimal costs ant colony optimisation meta heuristic search based refactoring unfolding of graph transformation systems run time security traceability for evolving systems security critical systems are challenging to design and implement correctly and securely a lot of vulnerabilities have been found in current software systems both at the specification and the implementation levels this paper presents a comprehensive approach for model based security assurance initially it allows one to formally verify the design models against high level security requirements such as secrecy and authentication on the specification level and helps to ensure that their implementation adheres to these properties if they express a system s run time behaviour as such it provides a traceability link from the design model to its implementation by which the actual system can then be verified against the model while it executes this part of our approach relies on a technique also known as run time verification the extra effort for it is small as most of the computation is automated however additional resources at run time may be required if during run time verification a security weakness is uncovered it can be removed using aspect oriented security hardening transformations therefore this approach also supports the evolution of software since the traceability mapping is updated when refactoring operations are regressively performed using our tool supported refactoring technique the proposed method has been applied to the java based implementation jessie of the internet security protocol ssl in which a security weakness was detected and fixed using our approach we also explain how the traceability link can be transformed to the official implementation of the java secure sockets extension that was recently made open source by sun the author 2009 published by oxford university press on behalf of the british computer society all rights reserved cryptographic protocols formal verification it security monitoring requirements traceability run time verification security analysis software evolution recovering traceability links between unit tests and classes under test an improved method unit tests are valuable as a source of up to date documentation as developers continuously changes them to reflect changes in the production code to keep an effective regression suite maintaining traceability links between unit tests and classes under test can help developers to comprehend parts of a system in particular unit tests show how parts of a system are executed and as such how they are supposed to be used moreover the dependencies between unit tests and classes can be exploited to maintain the consistency during refactoring generally such dependences are not explicitly maintained and they have to be recovered during software development some guidelines and naming conventions have been defined to describe the testing environment in order to easily identify related tests for a programming task however very often these guidelines are not followed making the identification of links between unit tests and classes a time consuming task thus automatic approaches to recover such links are needed in this paper a traceability recovery approach based on data flow analysis dfa is presented in particular the approach retrieves as tested classes all the classes that affect the result of the last assert statement in each method of the unit test class the accuracy of the proposed method has been empirically evaluated on two systems an open source system and an industrial system as a benchmark we compare the accuracy of the dfa based approach with the accuracy of the previously used traceability recovery approaches namely naming convention nc and last call before assert lcba that seem to provide the most accurate results the results show that the proposed approach is the most accurate method demonstrating the effectiveness of dfa however the case study also highlights the limitations of the experimented traceability recovery approaches showing that detecting the class under test cannot be fully automated and some issues are still under study 2010 ieee empirical studies traceability unit testing playing with refactoring identifying extract class opportunities through game theory in software engineering developers must often find solutions to problems balancing competing goals e g quality versus cost time to market versus resources or cohesion versus coupling finding a suitable balance between contrasting goals is often complex and recommendation systems are useful to support developers and managers in performing such a complex task we believe that contrasting goals can be often dealt with game theory techniques indeed game theory is successfully used in other fields especially in economics to mathematically propose solutions to strategic situation in which an individual s success in making choices depends on the choices of others to demonstrate the applicability of game theory to software engineering and to understand its pros and cons we propose an approach based on game theory that recommend extract class refactoring opportunities a preliminary evaluation inspired by mutation testing demonstrates the applicability and the benefits of the proposed approach 2010 ieee game theory quality metrics refactoring do metrics help to identify refactoring many iterative software development methodologies such as for example extreme programming state that refactoring is one of the key activities to be undertaken in order to keep the code base of a project well structured and consistent in such a context poorly structured code may become a significant obstacle in adding new or in enhancing existing functionality however there is some anecdotal evidence that in many software projects the underlying code base is not necessarily refactored post release often due to time constraints or the misconception that refactoring does not add any apparent value in order to get further insights into this problem area we propose to investigate the usage frequency of refactorings in the context of open source object oriented software systems in this work we will outline our approach to detecting refactoring and present results obtained from an initial pilot study 2010 acm evolution metrics open source software refactoring a two step technique for extract class refactoring we propose a novel approach supporting the extract class refactoring the proposed approach analyzes the structural and semantic similarity of the methods in a class in order to identify chains of strongly related methods the identified method chains are used to define new classes with higher cohesion than the original class a preliminary evaluation reveals that the approach is able to identify meaningful refactoring operations 2010 acm design experimentation reducing subjectivity in code smells detection experimenting with the long method guidelines for refactoring are meant to improve software systems internal quality and are widely acknowledged as among software s best practices however such guidelines remain mostly qualitative in nature as a result judgments on how to conduct refactoring processes remain mostly subjective and therefore non automatable prone to errors and unrepeatable the detection of the long method code smell is an example to address this problem this paper proposes a technique to detect long method objectively and automatically using a binary logistic regression model calibrated by expert s knowledge the results of an experiment illustrating the use of this technique are reported 2010 ieee binary logistic regression code smells long method refactoring process linguistic driven refactoring of source code identifiers identifiers are an important source of information during program understanding and maintenance programmers often use identifiers to build their mental models of the software artifacts we have performed a preliminary study to examine the relation between the terms in identifiers their spread in entities and fault proneness we introduced term entropy and context coverage to measure how scattered terms are across program entities and how unrelated are the methods and attributes containing these terms our results showed that methods and attributes containing terms with high entropy and context coverage are more fault prone we plan to build on this study by extracting linguistic information form methods and classes using this information we plan to establish traceability link from domain concepts to source code and to propose linguistic based refactoring 2010 ieee an integrated process for aspect mining and refactoring aspect oriented software development aosd aims at solving the problem of encapsulating crosscutting concerns which orthogonally crosscut the components of a system in units called aspects this encapsulation improves the modularization of a system and in consequence its maintenance and evolution in this work the authors propose a systematic process for the migration of object oriented systems to aspect oriented ones this migration is achieved in two main phases crosscutting concern identification aspect mining and code transformation aspect refactoring the aspect mining phase is based on dynamic analysis and association rules to identify potential crosscutting concerns the aspect refactoring phase on the other hand uses inference rules to identify the refactoring that can be applied the whole process is described and its application on a real system is assessed 2010 igi global ref finder a refactoring reconstruction tool based on logic query templates knowing which parts of a system underwent which types of refactoring between two program versions can help programmers better understand code changes though there are a number of techniques that automatically find refactorings from two input program versions these techniques are inadequate in terms of coverage by handling only a subset of refactoring types mostly simple rename and move refactorings at the level of classes methods and fields this paper presents a ref finder eclipse plug in that automatically identifies both atomic and composite refactorings using a template based refactoring reconstruction approach it expresses each refactoring type in terms of template logic queries and uses a logic programming engine to infer concrete refactoring instances ref finder currently supports sixty three types in the fowler s catalog showing the most comprehensive coverage among existing techniques logic based program representation program differencing refactoring software evolution p3jw 2010 proceedings of the work in progress session at the 8th international conference on the principles and practice of programming in java pppj 2010 the proceedings contain 8 papers the topics discussed include rulam project speculative parallelization for java using software transactional memory a java framework for developing intelligent tutoring systems implementing dynamic mixins for the java virtual machine semantic subtyping for objects and classes specification execution and detection of refactorings for software models bytecode analysis for checking java access modifiers scala java mod jvm on the performance characteristics of scala programs on the java virtual machine and extending java s communication mechanisms for multicore processors visual indicator component software to show component design quality and characteristic good design is one of the prerequisites of high quality product to measure the quality of software design software metrics are used unfortunately in software development practice there are a lot of software developers who are not concerned with the component s quality and characteristic software metrics does not interest them because to understand the measurement of the metrics a deep understanding about degree dimension and capacity of some attribute of the software product is needed this event triggers them to build software s whose quality is below the standard what is more dangerous is that these developers are not aware of quality and do not care with their work product of course these occurrences is concerning and a solution needed to be found through this paper the researcher is trying to formulate an indicator of component software that shows component design quality and characteristic visually this indicator can help software developers to make design decision and refactoring decision detect the design problem more quickly able to decide which area to apply refactoring and enable us to do early or final detection of design defects 2010 ieee detection of design defects indicator component software refactoring software component characteristic software component design quality lightweight executability analysis of graph transformation rules domain specific visual languages dsvls play a cornerstone role in model driven engineering mde where domain specific models are used to automate the production of the final application graph transformation is a formal visual rule based technique which is increasingly used in mde to express in place model transformations like refactorings animations and simulations however there is currently a lack of methods able to perform static analysis of rules taking into account the dsvl meta model integrity constraints in this paper we propose a lightweight efficient technique that performs static analysis of the weak executability of rules the method determines if there is some scenario in which the rule can be safely applied without breaking the meta model constraints if no such scenario exists the method returns meaningful feedback that helps repairing the detected inconsistencies 2010 ieee application of identical degree of set pair analysis on software refactoring set pair analysis possesses many virtues including specific concept convenience calculation and it covers comprehensive information as well in course of software refactoring traditional code locating method mostly relies on developer s observations and subjective perceptions which brings with much inconvenience therefore a new software refactoring scheme optimization model was built up based on identical degree of set pair analysis in virtue of correlation indicators of software metrics which offered a resolution to code locating in software refactoring this paper applied variation coefficient method to calculate the weight of indicators which improves the reliability of scheme evaluation an experimental case argues that the set pair analysis model can locate the iffy code correctly and furthermore it can offer specific refactoring order of each scheme 2010 ieee identical degree scheme optimization set pair analysis software refactoring abstracting abstract machines we describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well established abstract machines to demonstrate the technique and support our claim we transform the cek machine of felleisen and friedman a lazy variant of krivine s machine and the stack inspecting cm machine of clements and felleisen into abstract interpretations of themselves the resulting analyses bound temporal ordering of program events predict return flow and stack inspection behavior and approximate the flow and evaluation of by need parameters for all of these machines we find that a series of well known concrete machine refactorings plus a technique we call store allocated continuations leads to machines that abstract into static analyses simply by bounding their stores we demonstrate that the technique scales up uniformly to allow static analysis of realistic language features including tail calls conditionals side effects exceptions first class continuations and even garbage collection 2010 acm abstract interpretation abstract machines detecting missing thrown exceptions in enterprise systems an empirical study commonly enterprise systems are implemented using the object oriented and relational paradigms among which the communication is performed using various library methods for manipulating the persistent data most of the times the involved library methods throw different exceptions an improper handling mechanism for these exceptions in the source code may bring different problems at runtime and hamper its maintenance in this work we introduce an approach that automatically detects the methods from the source code which reveal an improper mechanism for handling exceptions involving database operations the detected methods should be refactored in order to increase the reliability of the application as well as its maintenance 2010 acm software quality assessment static analysis building empirical support for automated code smell detection identifying refactoring opportunities in software systems is an important activity in today s agile development environments the concept of code smells has been proposed to characterize different types of design shortcomings in code additionally metric based detection algorithms claim to identify the smelly components automatically this paper presents results for an empirical study performed in a commercial environment the study investigates the way professional software developers detect god class code smells then compares these results to automatic classification the results show that even though the subjects perceive detecting god classes as an easy task the agreement for the classification is low misplaced methods are a strong driver for letting subjects identify god classes as such earlier proposed metric based detection approaches performed well compared to the human classification these results lead to the conclusion that an automated metric based pre selection decreases the effort spent on manual code inspections automatic detection accompanied by a manual review increases the overall confidence in the results of metric based classifiers 2010 acm code inspection code smells empirical study god class maintainability abstract interpreters for free in small step abstract interpretations the concrete and abstract semantics bear an uncanny resemblance in this work we present an analysis design methodology that both explains and exploits that resemblance specifically we present a two step method to convert a small step concrete semantics into a family of sound computable abstract interpretations the first step re factors the concrete state space to eliminate recursive structure this refactoring of the state space simultaneously determines a store passing style transformation on the underlying concrete semantics the second step uses inference rules to generate an abstract state space and a galois connection simultaneously the galois connection allows the calculation of the optimal abstract interpretation the two step process is unambiguous but nondeterministic at each step analysis designers face choices some of these choices ultimately influence properties such as flow field and context sensitivity thus under the method we can give the emergence of these properties a graph theoretic characterization to illustrate the method we systematically abstract the continuation passing style lambda calculus to arrive at two distinct families of analyses the first is the well known k cfa family of analyses the second consists of novel environment centric abstract interpretations none of which appear in the literature on static analysis of higher order programs 2010 springer verlag hierarchical clustering for adaptive refactorings identification this paper studies an adaptive refactoring problem it is well known that improving the software systems design through refactoring is one of the most important issues during the evolution of object oriented software systems we focus on identifying the refactorings needed in order to improve the class structure of a software systems in an adaptive manner when new application classes are added to the system we propose an adaptive clustering method based on an hierarchical agglomerative approach that adjusts the structure of the system that was established by applying a hierarchical agglomerative clustering algorithm before the application classes set changed the adaptive method identifies more efficiently the refactorings that would improve the structure of the extended software system without decreasing the accuracy of the obtained results an experiment testing the method s efficiency is also reported a survey on search based software design this survey investigates search based approaches to software design the basics of the most popular meta heuristic algorithms are presented as background to the search based viewpoint software design is considered from a wide viewpoint including topics that can also be categorized as software maintenance or re engineering search based approaches have been used in research from the high architecture design level to software clustering and finally software refactoring enhancing and predicting software quality with search based methods is also taken into account as a part of the design process the background for the underlying software engineering problems is discussed after which search based approaches are presented summarizing remarks and tables collecting the fundamental issues of approaches for each type of problem are given the choices regarding critical decisions such as representation and fitness function when used in meta heuristic search algorithms are emphasized and discussed in detail ideas for future research directions are also given 2010 elsevier inc search algorithms search based software engineering software design software quality the conan tool to identify crosscutting concerns in object oriented systems this paper presents the main features of conan a tool supporting an approach to find scattered and tangled class members in oo systems and to group them in concerns the recovered information is useful for refactoring migration tasks such as towards aspect oriented programming aop 2010 ieee incremental refactoring using seeds refactoring is one major issue to improve the design of software systems increasing the internal software quality it is a disciplined technique for improving the structure of existing code without changing its observable behaviour we have previously introduced a clustering based approach for identifying refactorings in an object oriented software system essentially it takes the existing software system and restructure it using a k means based clustering algorithm kred in order to obtain a better design but in time the software system evolves and new application classes are added for implementing new functional requirements we propose in this paper a k means based incremental clustering method incremental refactoring using seeds irus that is capable to re partition the existing software system when new application classes are added to it the method starts from the clusters obtained by applying kred before the software system s extension the result is reached more efficiently than running kred again from the scratch on the extended software system an experimental evaluation proving the method s efficiency is also reported clustering incremental refactoring software engineering abstracting abstract machines we describe a derivational approach to abstract interpretation that yields novel and transparently sound static analyses when applied to well established abstract machines to demonstrate the technique and support our claim we transform the cek machine of felleisen and friedman a lazy variant of krivine s machine and the stack inspecting cm machine of clements and felleisen into abstract interpretations of themselves the resulting analyses bound temporal ordering of program events predict return flow and stack inspection behavior and approximate the flow and evaluation of by need parameters for all of these machines we find that a series of well known concrete machine refactorings plus a technique we call store allocated continuations leads to machines that abstract into static analyses simply by bounding their stores we demonstrate that the technique scales up uniformly to allow static analysis of realistic language features including tail calls conditionals side effects exceptions first class continuations and even garbage collection copyright 2010 acm abstract interpretation abstract machines ecoop 2010 object oriented programming 24th european conference proceedings the proceedings contain 25 papers the topics discussed include detecting missing method calls in object oriented software debugging model transformation failures using dynamic tainting automatically extracting class diagrams from spreadsheets the essence of javascript verifying executable object oriented specifications with separation logic verifying generics and delegates recency types for analyzing scripting languages correct refactoring of concurrent java code programming coordinated behavior in java doubts about the positive impact of static type systems on programming tasks in single developer projects an empirical study a type system for data centric synchronization type safe eventful sessions in java capabilities for uniqueness and borrowing embedding languages without breaking tools self replicating objects for multicore platforms and falling back on executable specifications a type system for data centric synchronization data centric synchronization groups fields of objects into atomic sets to indicate they must be updated atomically each atomic set has associated units of work code fragments that preserve the consistency of that atomic set we present a type system for data centric synchronization that enables separate compilation and supports atomic sets that span multiple objects thus allowing recursive data structures to be updated atomically the type system supports full encapsulation for more efficient code generation we evaluate our proposal using aj which extends the java programming language with data centric synchronization we report on the implementation of a compiler and on refactoring classes from standard libraries and a multi threaded benchmark to use atomic sets our results suggest that data centric synchronization enjoys low annotation overhead while preventing high level data races 2010 springer verlag berlin heidelberg isolating javascript in dynamic code environments we analyze the source code of four well known large web applications namelywordpress phpbb phpmyadmin and drupal we want to quantify the level of language intermixing in modern web applications and if possible we want to categorize all coding idioms that involve intermixing of javascript with a server side programming language like php our analysis processes more than half of a million of locs and identifies about 1 000 scripts these scripts contain 163 cases where the source code is mixed in a way that is hard to isolate javascript from php we manually investigate all 163 scripts and proceed in a classification scheme of five distinct classes our analysis can be beneficial for all applications that apply operations in the client side part of a web application various xss mitigation schemes as well as code refactoring and optimization tools copyright 2010 acm javascript web security recommending rename refactorings variable names play a major role in program comprehension however their choice is often subject to the intuition or intention of individual programmers although code conventions and style guides may constrain identifier usage programmers are individuals naming program concepts individually especially if different parts of a program are written by different programmers inconsistent naming of program entities may follow this is unfortunate since consistent naming would aid program comprehension in particular if references pointing to same objects used in similar ways are named equally as a first approach we focus on assignments to discover possible inconsistency of naming exploiting that a variable assigned to another likely points to same objects and if declared with the same type is likely used for the same purpose to explore the feasibility of our approach we implemented a tool recommending rename refactorings to harmonize variable names based on an analysis of assignments and static type information evaluated on some open source projects the results seem promising enough to aim for some extensions such as application to method names inferred type information and weakly type checked languages copyright 2010 acm assignment analysis identifiers rename refactoring variable naming isec 10 proceedings of the 2010 india software engineering conference the proceedings contain 22 papers the topics discussed include a tool for software development driven by customer interaction towards software test data generation using discrete quantum particle swarm optimization a scheme to prioritize classes at the early stage for improving observable reliability proving unreachability using bounded model checking modeling ontologies as executable domain specific languages a desiderata for refactoring based software modularity improvement an application synopsis tool for database applications developed using oracle application express medical software a regulatory process framework experience report a knowledge repository centric approach to performance tuning connectedness testing of restful web services using strong conflicts to detect quality issues in component based complex systems and distributed software development projects work breakdown approaches to overcome key coordination challenges are popular classes more defect prone traces of the evolution of software systems are left in a number of different repositories such as configuration management systems bug tracking systems and mailing lists developers use e mails to discuss issues ranging from low level concerns bug fixes refactorings to high level resolutions future planning design decisions thus e mail archives constitute a valuable asset for understanding the evolutionary dynamics of a system we introduce metrics that measure the popularity of source code artifacts i e the amount of discussion they generate in e mail archives and investigate whether the information contained in e mail archives is correlated to the defects found in the system our hypothesis is that developers discuss problematic entities more than unproblematic ones we also study whether the precision of existing techniques for defect prediction can be improved using our popularity metrics 2010 springer verlag cscout a refactoring browser for c despite its maturity and popularity the c programming language still lacks tool support for reliably performing even simple refactoring browsing or analysis operations this is primarily due to identifier scope complications introduced by the c preprocessor the cscout refactoring browser analyses complete program families by tagging the original identifiers with their precise location and classifying them into equivalence classes orthogonal to the c language s namespace and scope extents a web based user interface provides programmers with an intuitive source code analysis and navigation front end while an sql based back end allows more complex source code analysis and manipulation cscout has been successfully applied to many medium and large sized proprietary and open source projects identifying thousands of modest refactoring opportunities 2009 elsevier b v all rights reserved browser c preprocessor refactoring clustering based adaptive refactoring it is well known that maintenance and evolution represent important stages in the lifecycle of any software system about 66 from the total cost of the software systems development improving the software systems design through refactoring is one of the most important issues during the evolution of object oriented software systems refactoring aims at changing a software system in such a way that it does not alter the external behavior of the code but improves its internal structure in this paper we approach the problem of adaptive refactoring and we propose an adaptive method to cope with the evolving structure of any object oriented application namely we handle here the case when new application classes are added to the software system and the current restructuring scheme must be accordingly adapted the approach proposed in this paper extends our previous clustering based approach for identifying refactorings in an object oriented software system we also provide an example illustrating the efficiency of the proposed approach adaptive refactoring clustering restructuring identification of refactoring opportunities introducing polymorphism polymorphism is one of the most important features offered by object oriented programming languages since it allows to extend modify the behavior of a class without altering its source code in accordance to the open closed principle however there is a lack of methods and tools for the identification of places in the code of an existing system that could benefit from the employment of polymorphism in this paper we propose a technique that extracts refactoring suggestions introducing polymorphism the approach ensures the behavior preservation of the code and the applicability of the refactoring suggestions based on the examination of a set of preconditions 2009 elsevier inc all rights reserved object oriented design polymorphism refactoring state strategy design pattern slice based metrics for identifying refactoring in order to improve the efficiency and accuracy of identifying refactoring an automated refactoring identification technology is presented first a measurement method based on program slicing is constructed to quantify the program dependence between the elements secondly the elements with unreasonable location and affiliation in the original code are identified using measurement results and thus program s bad smell is automatically identified compared with previous manual identification the method can automatically analyze the source code and point out the unreasonable code so the efficiency of refactoring identification is improved it is recommended to change bad smell using the corresponding refactoring which may make the code more reasonable and easier to maintain finally three refactoring examples demonstrate that the method can identify some objects of refactoring which verify the feasibility of the method control function distance function metrics program slicing refactoring identification the theory of relative dependency higher coupling concentration in smaller modules recent studies have repeatedly found that smaller modules are proportionally more defect prone in this article the authors formulate and test a hypothesis stating that smaller modules are proportionally more coupled given that dependencies caused by coupling have been consistently associated with defect proneness strong evidence supports this hypothesis furthermore refactoring exacerbates this effect on the basis of this study s highly consistent results the authors state the empirically based theory of relative dependency that is in large scale software systems smaller modules will be proportionally more dependent compared to larger ones these findings have two implications for practice first we now have an empirically supported mechanism explaining the observations that defect concentration is higher in smaller modules practitioners can use this mechanism as evidence while seeking resources and support to revise or amend their organizations quality assurance and quality control practices second particularly for the projects that refactor extensively such as those using agile methods focusing defect detection activities on smaller modules will increase their efficiency and effectiveness even more 2010 ieee product metrics restructuring reverse engineering software engineering software maintainability software metrics and measurement software quality software quality assurance software science sqa validation and verification object oriented program method level clone detection based on similarity measurement code clone detection is important for refactoring and extraction of reusable assets the present code clone detection method is on the basis of detection of similar code segments which brings difficulty for further clone analysis and refactoring aiming at this problem this paper offers a method level clone detection method for object oriented program based on similarity measurement which detects method level cloned code our method utilizes comments of the code method signature and syntactic similarity to measure the degree of the clone based on the method mentioned above further refactoring can be realized by combining similar methods of sub classes into one method and pulling it up into super class our method s effectiveness has been verified by analyzing the result of the experiment on the code of jdk the initial experiment result shows that our method can help developer detect method level code clone both accurately and effectively clone detection code clone object oriented refactoring reverse engineering capabilities and roles of enterprise wikis in organizational communication purpose the article alerts technical communicators to wiki technology an emerging new medium that allows dispersed groups to create shared content via collaborative editing and different time communication wiki based collaborative content creation enables new communication practices and thereby challenges several assumptions of existing media choice theories method analysis of empirical evidence from 32 published case descriptions and reports to evaluate wiki technology in a corporate context based on the defining characteristics of three media choice theories i e media richness theory theory of media synchronicity and common ground theory results wikis meet or exceed capabilities of several other communication and collaboration media and thus provide a credible alternative to other business communication technologies currently in use further distinct media capabilities of wikis are not fully represented by current media choice theories suggesting the need to extend media choice theories to recognize these unique capabilities conclusion the unique features of enterprise wikis enable new collaboration practices and challenge some of the core theoretical assumptions of media choice theories the refactoring capability of wikis is identified as a unique feature that enables new forms of collaboration and communication in organizations an implementation that wishes to successfully leverage wiki enabled collaboration opportunities must carefully consider challenges of human interaction such as free riding or conflict of values business communication collaborative writing content refactoring media capability wiki software refactoring at the function level using new adaptive k nearest neighbor algorithm improving the quality of software is a vital target of software engineering constantly evolving requirements force software developers to enhance modify or adapt software thus increasing internal complexity maintenance effort and ultimately cost in trying to balance between the needs to change software maintain high quality and keep the maintenance effort and cost low refactoring comes up as a solution refactoring aims to improve a number of quality factors among which is understandability enhancing understandability of ill structured software decreases the maintenance effort and cost to improve understandability designers need to maximize cohesion and minimize coupling which becomes more difficult to achieve as software evolves and internal complexity increases in this paper we propose a new adaptive k nearest neighbor a knn algorithm to perform clustering with different attribute weights the technique is used to assist software developers in refactoring at the function method level this is achieved by identifying ill structured software entities and providing suggestions to improve cohesion of such entities we also compare the proposed technique with three function level clustering techniques single linkage algorithm slink complete linkage algorithm clink and weighted pair group method using arithmetic averages wpgma a knn showed competitive performance with the other three algorithms and required less computational complexity clustering code restructuring cohesion function level cohesion software quality software refactoring agile processes in software engineering and extreme programming 11th international conference xp 2010 proceedings the proceedings contain 56 papers the topics discussed include extending refactoring guidelines to perform client and test code adaptation security testing in agile web application development a case study using the east methodology adoption of team estimation in a specialist organizational environment extreme product line engineering refactoring for variability a test driven approach towards understanding communication structure in pair programming applying scrum in an oss development process an empirical evaluation understanding the importance of trust in distributed agile projects a practical perspective introducing agile methods in a large software development team the developers changing perspective structuring complexity issues for efficient realization of agile business requirements in distributed environments and adoption of software engineering process innovations the case of agile software development methodologies the evolution and impact of code smells a case study of two open source systems code smells are design flaws in object oriented designs that may lead to maintainability issues in the further evolution of the software system this study focuses on the evolution of code smells within a system and their impact on the change behavior change frequency and size the study investigates two code smells god class and shotgun surgery by analyzing the historical data over several years of development of two large scale open source systems the detection of code smells in the evolution of those systems was performed by the application of an automated approach using detection strategies the results show that we can identify different phases in the evolution of code smells during the system development and that code smell infected components exhibit a different change behavior this information is useful for the identification of risk areas within a software system that need refactoring to assure a future positive evolution 2009 ieee improving safety when refactoring aspect oriented programs checking correctness with respect to a formal semantics is expensive thus the refactoring tools are commonly implemented in an ad hoc way and may perform transformations that do not preserve behavior the problem becomes still worse when we consider refactoring aspect oriented ao programs we present a practical technique for increasing confidence on whether a given transformation applied to an ao program preserves behavior this technique was evaluated against 12 transformations performed in eclipse which intended to be refactorings it detected that 91 of them do not preserve behavior a second evaluation was accomplished with a 65 kloc real case study containing 475 classes it is implemented in java and was refactored to aspectj both versions are intended to be equivalent but our technique detected a behavioral change aspect oriented programming detecting behavioral changes refactoring the 3rd acm workshop on refactoring tools wrt 09 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of specific transformations that need to be performed tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial program analysis and applying the transformations may affect many locations throughout a program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in modern day ides until recently there has not been a suitable forum for discussions among researchers and developers of such tools our prior refactoring tools workshops initially at ecoop 2007 then at oopsla 2008 clearly met a need and there was strong interest expressed in holding a follow on workshop this workshop features both presentations given by developers and researchers in the field of refactoring as well as demonstrations of practical refactoring tools program analysis program manipulation refactoring transformation maintenance and agile development challenges opportunities and future directions software entropy is a phenomenon where repeated changes gradually degrade the structure of the system making it hard to understand and maintain this phenomenon imposes challenges for organizations that have moved to agile methods from other processes despite agile s focus on adaptability and responsiveness to change we have investigated this issue through an industrial case study and reviewed the literature on addressing software entropy focussing on the detection of code smells and their treatment by refactoring we found that in order to remain agile despite of software entropy developers need better support for understanding planning and testing the impact of changes however it is exactly work on refactoring decision support and task complexity analysis that is lacking in literature based on our findings we discuss strategies for dealing with entropy in this context and present avenues for future research what motivate software engineers to refactor source code evidences from professional developers refactoring is an increasingly practiced method in industry software development however existing research mostly focus on the technical aspect of refactoring we still know little about the human behavior domain on this issue software developer s motivation has been recognized as a key human factor for the software development and maintenance tasks therefore identifying what motivates software developer refactor their or others source code will bring both theoretical and practical implications in this paper we report our case studies in four software development organizations through interviews with 10 professional software developers we identified the major factors that motivate their refactoring activities an empirical model on refactoring motivation is also presented based on the data collected strengthening refactoring towards software evolution with quantitative and experimental grounds refactoring is a process meant to improve the internal quality of software systems however while on one hand the guidelines for this delicate process are still empirical and qualitative on the other hand software product metrics often indicate that this process has the opposite results also there is a lack of evidence regarding improvements on maintainability due to refactoring this means that this process although widely acknowledged as one of the best software practices is difficult to deploy within large scale software systems and can be better grounded to address these challenges we propose a method for refactoring with quantitative and experimental grounds upon the consolidation of this method we will build the necessary blocks to implement and validate it 2009 ieee quality analysis and evaluation techniques review and audit software design software engineering tools and methods software quality tools identifying fragments to be extracted from long methods long and complex methods are hard to read or maintain and thus usually treated as bad smells known as long method on the contrary short and well named methods are much easier to read maintain and extend in order to divide long methods into short ones refactoring extract method was proposed and has been widely used however extracting methods manually is time consuming and error prone though existing refactoring tools can automatically extract a selected fragment from its inclosing method which fragment within a long method should be extracted has to be determined manually in order to facilitate the decision making we propose an approach to recommend fragments within long methods for extraction the approach is implemented as a prototype called automed with the tool we evaluate the approach on a nontrivial open source project the evaluation results suggest that refactoring cost of long methods can be reduced by nearly 40 the main contribution of this paper is an approach to recommending fragments within long methods to be extracted as well as an initial evaluation of the approach 2009 ieee bad smells extract method long method refactoring refactoring of statecharts statecharts are an important tool for specifying the behavior of reactive systems and development tools can automatically generate object oriented code from them as the system is refactored it is necessary to modify the associated statecharts as well performing operations such as grouping or ungrouping states extracting part of a statechartnto a separate class and merging states and transitions refactoring tools embedded in object oriented development environments are makng it much easier for developers to modify their programs however tool support for refactoring statecharts does not yet exist as a result developers avoid making certain changes that are too difficult to perform manually even though design quality deteriorates methodologically statecharts were meant to enable a systems engineer to describe a complete system which would then be refined into a concrete implementation object oriented or other this process is not supported by object oriented development environments which force each statechart to be specified as part of a class automated tool support for refactoring statecharts will also make this kind of refinement possible this paper describes a case study that shows the usefulness of refactoring support for statecharts and presents an initial catalog of relevant refactorings we show that a top down refinement process helps identify the tasks and classes in a natural way 2009 springer verlag berlin heidelberg analysing refactoring dependencies using unfolding of graph transformation systems refactoring has emerged as a successful technique to reduce complexity of object oriented designs but due to implicit dependencies not all sequences of refactorings are appropriate in this paper we model refactoring steps as graph transformation and use the unfolding analysis technique to choose the sequence of refactorings best suited in order to improve the design we use graphs to represent software architectures at the class level and graph transformation to formally describe their refactoring operations this makes it possible to use concepts and techniques from the theory of graph transformation such as unfolding to identify dependencies between refactoring steps copyright 2009 acm graph transformation systems search based refactoring evolving enterprise application using refined use case and refactoring mapping how to effectively evolve enterprise application with the frequently changing requirement is a challenge to software engineering requirement is a noticeable cause of evolution of enterprise application and requirement changes cannot be estimated precisely in many cases therefore the main problem is how to capture requirements and changes and propagate the proper modification to application the traditional method based on model and code re generating is not conducive to management and maintenance refactoring has given guidance to gradual evolution of object oriented software this paper presents a approach using refined use case to capture the requirement to modeling enterprise application and using the refactoring mappings between requirement and models to effectively maintain model and other parts of the application which helps to smooth the evolution process of enterprise applications 2009 ieee change propagation refined use case requirement refactoring software evolution a quantitative evaluation of software quality enhancement by refactoring using dependency oriented complexity metrics the maintainability of software depends on the quality of software software under evolution is modified and enhanced to cater the new requirements due to this the software becomes more complex and deviates from its original design in turn lowering the quality refactoring makes object oriented software systems maintainable effective refactoring requires proper metrics to quantitatively ascertain the improvement in the quality after refactoring in this direction we have made an effort to quantitatively evaluate the quality enhancement by refactoring using dependency oriented complexity metrics in this paper three experimental cases are given the metrics have successfully indicated quantitatively the presence of defects and the improvement in the quality of designs after refactoring these metrics have acted as quality indicators with respect to designs considered under ripple effects before and after refactoring metrics as quality indicators help to estimate the required maintenance efforts 2009 ieee dcoupling dependency oriented complexity metrics design defects quality refactoring proceedings 16th asia pacific software engineering conference apsec 2009 the proceedings contain 63 papers the topics discussed include improving the accuracy of software effort estimation based on multiple least square regression models by estimation error based data partitioning on the relationship between different size measures in the software life cycle investigating the effect of refactoring on software testing effort extracting high level functional design from software requirements identifying fragments to be extracted from long methods a graph based approach to detecting causes of implied scenarios under the asynchronous and synchronous communication styles extracting environmental constraints to make reactive system specifications realizable monitoring composite services with universal modal sequence diagrams the context dynamics matrix cdm an approach to modeling context tool support for component based software architectures and web services composition by i o data structure correspondences escape the waterfall agile for aerospace agile is an umbrella software methodology that incorporates many of the best practices of the last couple of decades in this paper we will examine some of those key techniques for possible application in the aerospace domain starting with a brief literature review to identify the key agile publications and the germane do 178b work virtually all agile practices can be mapped to a do 178b software development process we provide a detailed analysis of the key practices with a preliminary assessment of the ease of implementation for each an analysis of a number of the difficulties involving transitioning from a traditional waterfall software development process to agile practices will show that though difficult a transition is possible the transition to agile development does not require sudden sweeping change but instead can be accomplished through incorporating agile methods into an existing process we will document successful integration of test driven development pair programming refactoring an iterative approach and other agile methods into a traditional do 178b software development process we conclude with a call for a collaborative effort to further explore agile as an answer to the urgent need for new approaches to complex systems that have become increasingly difficult to verify and validate 2009 ieee a study of interorganizational process refactoring based on inheritance technology the formal modeling and correctness analysis of interorganizational business processes is one of the hot topics in business process management this paper focuses on the modeling and refactoring of interorganizational processes with the integrated view of process activities and data the data oriented interorganizational process modeling method is proposed based on the inheritance concept from software engineering two kinds of process inheritance are defined to analyze the proper adjustment of interorganizational processes moreover the refactoring stage and curve of interorganizational processes are identified 2009 ieee inheritance technology interorganizational process petri nets process refactoring figd an open source intellectual property violation detector figd fingerprint generator detector is an open source java application capable of detecting intellectual property violations in compiled java programs without requiring access to the original source files figd uses a modification of the n gram method which is very accurate in discovering everything from blatantly copied source to more advanced attempts of obfuscation such as variable refactoring or white space insertions our improvements to the algorithm allow us to increase the speed of detection and create small fingerprints which can be stored for future comparisons towards a model refactoring conflict resolution algorithm conflict resolution is a key problem in research of model refactoring while the majority of researchers focus on conflicts detection conflict resolution is usually performed manually after being analyzed known conflicts three categories of conflicts could be resolved which include conflicts of parallel applications of the same rule symmetric conflicts and asymmetric conflicts this paper concentrates on automating conflicts resolution so as to realize the automatic model refactoring this method provides an integrated algorithm based on manual analysis of the three categories of conflicts this algorithm could preliminarily realize the automatic resolution of conflicts mentioned which are caused by the parallel application of refactoring rules 2009 ieee algorithm conflict conflict resolution critical pairs model refactoring an empirical investigation of the key factors for refactoring success in an industrial context refactoring is an increasingly practiced method in industrial software development stated simply refactoring is an ongoing software improvement process that simplifies the internal structure of existing software without changing its external behavior the purpose is to improve the software and facilitate future maintenance and enhancement existing studies on refactoring mainly focus on its technical aspects and thus do not consider the team and human factors that influence its success to identify the major facilitating factors for the success of refactoring we interviewed 10 industrial software developers and combined their responses with a study of the existing literature formulated a model of refactoring success the resulting conceptual model comprises both technical and non technical factors technical factors include level testing and debugging and tools while the non technical factors include communication and coordination support activities individual capability skills and programmer participation we propose to verify this model empirically through a survey of professional software developers main body of refactoring practitioners the survey design is provided empirical software engineering human factors maintenance refactoring software development incremental model synchronization in model driven development environments most modern model driven software development environments rely heavily on model transformations for generating various software design artifacts and eventually even source code however during development maintenance and evolution activities these software artifacts are subject to updates and refactoring operations in such model driven development environments these software artifacts need to be re synchronized every time one of them is altered so that they all remain consistent according to some specific rules relations and domain constraints until now the standard approach to model synchronization has been the re application of all transformation rules aiming thus for the complete re generation of all artifacts in all models involved this complete re application is a safe yet computationally expensive way to ensure consistency among models in this paper we present a method for re synchronizing software models in an incremental fashion by utilizing an indexing model in this respect using the proposed methodology the time required for maintaining global model consistency is proportional to the size of the changes and not that of the models involved the proposed approach has been applied for the incremental re synchronization of large and complex models in the eclipse web tools platform wtp results indicate that this solution can significantly reduce the time required to re synchronize models in such comprehensive development environments as wtp copyright 2009 ali razavi kostas kontogiannis ibm canada ltd safer typing of complex api usage through java generics when several incompatible implementations of a single api are in use in a java program the danger exists that instances from different implementations may inadvertently be mixed leading to errors in this paper we show how to use generics to prevent such mixing the core idea of the approach is to add a type parameter to the interfaces of the api and tie the classes that make up an implementation to a unique choice of type parameter in this way methods of the api can only be invoked with arguments that belong to the same implementation we show that the presence of a type parameter in the interfaces does not violate the principle of interface based programming clients can still completely abstract over the choice of implementation in addition we demonstrate how code can be reused between different implementations how implementations can be defined as extensions of other implementations and how different implementations may be mixed in a controlled and safe manner to explore the feasibility of the approach gauge its usability and identify any issues that may crop up in practical usage we have refactored a fairly large existing api based application suite and we report on the experience gained in the process copyright 2009 acm family polymorphism generics interface based programming programming patterns genutest a unit test and mock aspect generation tool unit testing plays a major role in the software development process what started as an ad hoc approach is becoming a common practice among developers it enables the immediate detection of bugs introduced into a unit whenever code changes occur hence unit tests provide a safety net of regression tests and validation tests which encourage developers to refactor existing code with greater confidence one of the major corner stones of the agile development approach is unit testing agile methods require all software classes to have unit tests that can be executed by an automated unit testing framework however not all software systems have unit tests when changes to such software are needed writing unit tests from scratch which is hard and tedious might not be cost effective in this paper we propose a technique which automatically generates unit tests for software that does not have such tests we have implemented genutest a prototype tool which captures and logs interobject interactions occurring during the execution of java programs using the aspect oriented language aspectj these interactions are used to generate junit tests they also serve in generating mock aspects mock object like entities which enable testing units in isolation the generated junit tests and mock aspects are independent of the tool and can be used by developers to perform unit tests on the software comprehensiveness of the unit tests depends on the software execution we applied genutest to several open source projects such as nanoxml and jode we present the results explain the limitations of the tool and point out direction to future work to improve the code coverage provided by genutest and its scalability springer verlag 2009 an application of intelligent data analysis techniques to a large software engineering dataset within the development of large software systems there is significant value in being able to predict changes if we can predict the likely changes that a system will undergo then we can estimate likely developer effort and allocate resources appropriately within object oriented software development these changes are often identified as refactorings very few studies have explored the prediction of refactorings on a wide scale within this paper we aim to do just this through applying intelligent data analysis techniques to a uniquely large and comprehensive software engineering time series dataset our analysis show extremely promising results allowing us to predict the occurrence of future large changes 2009 springer berlin heidelberg hidden markov models software engineering time series analysis local search based refactoring as graph transformation to improve both performance scalability and traceability understandability of search based refactoring in this paper we propose a local formulation of refactoring based on graph transformation we use graphs to represent software architectures at the class level and graph transformation to formally describe their refactoring operations this makes it possible to use concepts and techniques from the theory of graph transformation such as unfolding and critical pair analysis to identify dependencies between refactoring steps as a result we are able to express the search problem as an instance of the ant colony optimisation metaheuristic 2009 ieee using static analysis to extract c 0x concepts using concepts to abstract domain knowledge is the basis for generic programming concept will be a new language feature in c 0x which provides solid base for developing reusable and extendable generic software to make better use of new generic programming features of c 0x it is necessary to identify concepts in legacy c programs and refactor them to c 0x programs this paper presents an automatic method to identify concepts with static analysis analyzes the usages of type parameters in legacy programs to extract valid expression constraints and associate type constraints concepts can be inferred by these constraints the approach is applied to the c standard template library to identify most of the potential concepts in stl the study convinces that this method is helpful to identify concepts in legacy c programs c 0x concept constraint analysis generic programming software refactoring class structure refactoring of object oriented softwares using community detection in dependency networks the quality of a software system is largely determined by its internal structures which always degrade over the software evolution therefore the structures have to be reconditioned from time to time however the existing methods are very complex and resource consuming when doing this task in this paper we present an approach to recondition the class structures of object oriented oo software systems it uses attribute method networks and method method networks to represent attributes methods and dependencies between them it proposes a guided community detection algorithm to obtain the optimized community structures in the method method networks which also correspond to the optimized class structures it also provides a list of refactorings by comparing the optimized class structures with the real class structure in software systems and inspecting the attribute method networks the approach is evaluated using the open source case study jhotdraw 5 1 and the advantages of our approach are illustrated in comparison with existing methods higher education press and springer verlag gmbh 2009 class refactoring community detection complex networks object oriented oo software software dependency networks software refactoring an expert system for determining candidate software classes for refactoring in the lifetime of a software product development costs are only the tip of the iceberg nearly 90 of the cost is maintenance due to error correction adaptation and mainly enhancements as lehman and belady lehman m m belady l a 1985 program evolution processes of software change academic press professional state that software will become increasingly unstructured as it is changed one way to overcome this problem is refactoring refactoring is an approach which reduces the software complexity by incrementally improving internal software quality our motivation in this research is to detect the classes that need to be rafactored by analyzing the code complexity we propose a machine learning based model to predict classes to be refactored we use weighted naïve bayes with infogain heuristic as the learner and we conducted experiments with metric data that we collected from the largest gsm operator in turkey our results showed that we can predict 82 of the classes that need refactoring with 13 of manual inspection effort on the average 2008 elsevier ltd all rights reserved naive bayes refactor prediction refactoring software metrics web services and formal methods 5th international workshop ws fm 2008 revised selected papers the proceedings contain 14 papers the topics discussed include on the expressive power of process interruption and compensation modelling and analysis of time constrained flexible workflows with time recursive ecatnets contract compliance and choreography conformance in the presence of message queues verification of choreographies during execution using the reactive event calculus restful petri net execution validation and discovery of non deterministic semantic e services fault compensation and termination in ws bpel 2 0 a comparative analysis refactoring long running transactions on the fly model based testing of web services with jambition towards a formal framework for workflow interoperability security types for sessions and pipelines why does my service have no partners proof techniques for adapter generation and efficient controllability analysis of open nets concept analysis for class cohesion a concept lattice based approach for analysis of class cohesion is presented the approach facilitates rapid identification of less cohesive classes it also helps identify less cohesive methods attributes and classes in one go further the approach guides refactorings such as extract class move method localize attributes and remove unused attributes the effectiveness of the technique is demonstrated through examples 2009 ieee identification of extract method refactoring opportunities extract method has been recognized as one of the most important refactorings since it decomposes large methods and can be used in combination with other refactorings for fixing a variety of design problems however existing tools and methodologies support extraction of methods based on a set of statements selected by the user in the original method the goal of the proposed methodology is to automatically identify extract method refactoring opportunities and present them as suggestions to the designer of an objectoriented system the suggested refactorings adhere to three principles the extracted code should contain the complete computation of a given variable declared in the original method the behavior of the program should be preserved after the application of the refactoring and the extracted code should not be excessively duplicated in the original method the proposed approach is based on the union of static slices that result from the application of a block based slicing technique the soundness of the identified refactoring opportunities has been evaluated by an independent designer on the system that he developed 2009 ieee a new method for acquisition of boc modulation signal based on refactoring theory to cross correlation a boc modulated signal presents multiple peaks auto correlation function the zeros of cross correlation can make a false judgment by acquisition phase so based on the idea of fractal a new acquisition method has been proposed using a simple folding theory a new cross correlation function was refactored the influence of local zeros was eliminated and the probability of detecting is enhanced comparing to the acquisition method with three parallel tags the simulation was completed the analysis to the simulation result has shown that the method can provide phase information to the track loop and adapt to acquisition for high rank boc modulated signal acquisition boc modulated signal folding arithmetic zeros of cross correlation an integrated crosscutting concern migration strategy and its semi automated application to jhotdraw in this paper we propose a systematic strategy for migrating crosscutting concerns in existing object oriented systems to aspect oriented programming solutions the proposed strategy consists of four steps mining exploration documentation and refactoring of crosscutting concerns we discuss in detail a new approach to refactoring to aspect oriented programming that is fully integrated with our strategy and apply the whole strategy to an object oriented system namely the jhotdraw framework moreover we present a method to semi automatically perform the aspect introducing refactorings based on identified crosscutting concern sorts which is supported by a prototype tool called sair we perform an exploratory case study in which we apply this tool on the same object oriented system and compare its results with the results of manual migration in order to assess the feasibility of automated aspect refactoring both the refactoring tool sair and the results of the manual migration are made available as open source the latter providing the largest aspect introducing refactoring available to date we report on our experiences with conducting both case studies and reflect on the success and challenges of the migration process aspect oriented programming code refactoring concern modeling cross cutting concerns program analysis reverse engineering software engineering adaptive quality forecasting strategy of xml data streams aimed at the currently shortage of xml streams quality detecting an adaptive quality forecasting method of xml data streams xafs is presented it uses the vector matrix built by the xml keys as windows uses vector product wavelet transform to multilevel decompose and refactor the xml streams series and then forecasts the xml streams quality combing squares support vector machines for even more adapting net load it proposes a control strategy by weight and adaptive adjustment to ensure xml streams quality contrasting with other corresponding algorithms a series of emulation experiments shows that this method has proper rather precision and practicability so it is an effective forecasting method of xml streams mining forecasting least squares support vector machines vector product wavelet transform xml data streams xml database identification of move method refactoring opportunities placement of attributes methods within classes in an object oriented system is usually guided by conceptual criteria and aided by appropriate metrics moving state and behavior between classes can help reduce coupling and increase cohesion but it is nontrivial to identify where such refactorings should be applied in this paper we propose a methodology for the identification of move method refactoring opportunities that constitute a way for solving many common feature envy bad smells an algorithm that employs the notion of distance between system entities attributes methods and classes extracts a list of behavior preserving refactorings based on the examination of a set of preconditions in practice a software system may exhibit such problems in many different places therefore our approach measures the effect of all refactoring suggestions based on a novel entity placement metric that quantifies how well entities have been placed in system classes the proposed methodology can be regarded as a semi automatic approach since the designer will eventually decide whether a suggested refactoring should be applied or not based on conceptual or other design quality criteria the evaluation of the proposed approach has been performed considering qualitative metric conceptual and efficiency aspects of the suggested refactorings in a number of open source projects 2009 ieee design quality feature envy jaccard distance move method refactoring object oriented design guidelines for enabling the extraction of aspects from existing object oriented code when extracting crosscutting concerns from object oriented systems to aspects it is often needed to transform the code in order to enable the application of aspects although not extensively documented in the literature object oriented transformations are critical to turn legacy systems ready to aspect oriented refactoring for this reason in this paper we provide a set of guidelines for maintainers and developers interested in preparing object oriented systems to the aspect technology moreover we present a tool that can help developers to identify the need of object oriented transformations we also evaluate the proposed guidelines and supporting tool through two case studies jot 2008 iron and steel mill applications a new and quick method for the chemical analysis of refractories a new quick and portable method of chemical analysis were presented so as to analyses refractories that are used in operations involving the continuous pouring of steel with a description of overall principles of laser induced breakdown spectroscopy libs the method is quite versatile and can be used equally well on solid liquids or gases to provide a qualitative analysis of the chemical composition of the sample or of the analyses product the method also makes it possible to quickly identify different materials on refactories used for continuous steel pouring are shown hereinafter the method also allows to check on line the grades of refractory to approve the parts of new works and or in production along with the use to presort contaminated refractories during the dismantling of glass furnaces an exploratory investigation on refactoring in industrial context refactoring which is an efficient method to improve the quality of the existing code has been widely used in practical software development and maintenance activities the current refactoring researches are more focus on the technical aspect of refactoring but pay little attention to its use in real software development environment however software development and maintenance in their nature are human centric activities the lack of systematic empirical studies has resulted in the gap between current refactoring researches and industrial practices to bridge this research gap we conduct this exploratory study to learn more about the actual use of refactoring in the industrial context using a series of semi controlled interviews as our major research method we gathered first hand information on how the refactoring is used by practitioners we built a three stage framework to describe the overall refactoring process 19 basic factors are identified and categorized we also identify the most important ones and the factors that may trigger potential conflicts between developers and the managers some related issues such as this study s implications are also discussed 2009 springer berlin heidelberg human factors industrial context refactoring refactoring prediction using class complexity metrics in the lifetime of a software product development costs are only the tip of the iceberg nearly 90 of the cost is maintenance due to error correction adoptation and mainly enhancements as belady and lehman lehman and belady 1985 state that software will become increasingly unstructured as it is changed one way to overcome this problem is refactoring refactoring is an approach which reduces the software complexity by incrementally improving internal software quality our motivation in this research is to detect the classes that need to be rafactored by analyzing the code complexity we propose a machine learning based model to predict classes to be refactored we use weighted naïve bayes with infogain heuristic as the learner and we conducted experiments with metric data that we collected from the largest gsm operator in turkey our results showed that we can predict 82 of the classes that need refactoring with 13 of manual inspection effort on the average defect prediction naïve bayes refactor prediction refactoring software metrics weighted naïve bayes systematically refactoring inheritance to delegation in java because of the strong coupling of classes and the proliferation of unneeded class members induced by inheritance the suggestion to use composition and delegation instead has become commonplace the presentation of a corresponding refactoring in the literature may lead one to believe that such a transformation is a straightforward undertaking however closer analysis reveals that this refactoring is neither always possible nor does it necessarily achieve its desired effect we have therefore identified the necessary preconditions and realizable postconditions of the refactoring and built a tool that can perform it completely automatically by applying this tool to all subclasses of several open source projects we have collected evidence of the applicability of the refactoring and of its capability to deliver on its promises the refactoring builds on constraint graphs originally developed for type inference to check the preconditions and to compute the necessary delegation as well as the subtype relationships that must be maintained copyright 2008 acm design experimentation languages is the need to follow chains a possible deterrent to certain refactorings and an inducement to others a current and difficult challenge in the software engineering arena is assessment of code smells and subsequent re engineering decisions the mechanics of seventy two individual object oriented refactorings are specified in the seminal text by fowler providing the steps that need to be undertaken to complete each while it is relatively easy to identify related refactorings i e those that each refactoring itself directly uses as part of those mechanics what is not so clear is the chain of required refactorings that may emerge due to these indirect and composite relationships in this paper we investigate the characteristics of fourteen of the seventy two refactorings identifying for each its related refactorings and the implications this may have for the overall time and effort required to carry out each we supported our analysis with data from a previous empirical analysis the key result was that refactorings inducing long chains tended to be utilized less by developers than refactorings with short chains suggesting that complexity given by long chains may be a real consideration prior to refactoring empirically long chains were found to be composed of sets of smaller inter related refactorings on a general note understanding the composition of refactorings is recognized as an emerging yet under researched area but has significant implications for the amount of effort that a developer might have to invest in any single change to a system involving refactoring chains object oriented refactoring tools a metric based approach for reconstructing methods in bject oriented systems refactoring is an important activity to improve software quality which tends to become worse through repetitive bug fixes and function additions unfortunately it is difficult to perform appropriate refactorings because a refactoring needs certain costs and its effects should be greater than the costs this paper describes an approach for appropriate refactorings the approach identifies spots to be refactored and it suggests how they should be improved moreover the approach estimates the effects of the refactorings the approach requires a lightweight source code analysis for measuring several metrics so that it can be applied to middle or large scale software system the approach can make the refactoring process more effective and efficient one copyright 2008 acm refactoring software maintenance source code analysis on the relation of refactoring and software defects this paper analyzes the influence of evolution activities such as refactoring on software defects in a case study of five open source projects we used attributes of software evolution to predict defects in time periods of six months we use versioning and issue tracking systems to extract 110 data mining features which are separated into refactoring and non refactoring related features these features are used as input into classification algorithms that create prediction models for software defects we found out that refactoring related features as well as non refactoring related features lead to high quality prediction models additionally we discovered that refactorings and defects have an inverse correlation the number of software defects decreases if the number of refactorings increased in the preceding time period as a result refactoring should be a significant part of both bug fixes and other evolutionary changes to reduce software defects copyright 2008 acm mining software archives refactoring software evolution a quantitative method to detect design defects and to ascertain the elimination of design defects after refactoring one of the ways to make object oriented software systems maintainable is refactoring effective refactoring requires a proper method to detect design defects recently some quantitative design defects detection methods which are based on metrics have been developed however there is a scope for a design defects detection method which considers design change propagation probabilities between artifacts that are connected through intermediate artifacts a quantitative method is proposed in this paper considering the above aspect the main advantage of the proposed method is it can be used not only for design defects detection but also to ascertain quantitatively the elimination of design defects after refactoring making use of the proposed method in example designs two different design defects are detected and the elimination of these defects after refactoring from the design is known quantitatively the frame work in which this method is used is given bad smells design change propagation probability matrix design defects divergent change refactoring shotgun surgery clustering based automatic refactorings identification the aim of this paper is to approach the problem of improving the design of an object oriented software system by identifying the appropriate refactorings it is well known that improving the quality of software systems design is an important issue during the evolution of object oriented software systems this improvement can be achieved by refactoring the software system in order to improve its internal structure but without altering the external behavior of the code in this paper we introduce a hierarchical divisive clustering algorithm for automatic identification of refactorings that improve the internal structure of a software system we evaluate our approach using jhotdraw case study and a real software system emphasizing its advantages in comparison with existing similar approaches 2008 ieee clustering refactoring software design hierarchical clustering based automatic refactorings detection the structure of software systems is subject of many changes during the systems lifecycle a continuous improvement of the software systems structure can be made using refactoring that assures a clean and easy to maintain software structure in this paper we are focusing on the problem of restructuring object oriented software systems using hierarchical clustering we propose two hierachical clustering based algorithms which takes an existing software and reassembles it using clustering in order to obtain a better design suggesting the needed refactorings we evaluate the proposed algorithms using the open source case study jhotdraw and a real software system providing a comparison with previous approaches algorithm clustering object oriented systems refactoring software engineering system design sort based refactoring of crosscutting concerns to aspects crosscutting concerns in object oriented programming hinder evolution because of their symptoms tangling and scattering to benefit from the modularisation capabilities for crosscutting concerns provided by aspect oriented programming which prevent tangling and scattering aspect introducing refactoring can be used the first step in aspect introducing refactoring is identifying and documenting crosscutting concerns in existing code the second step is refactoring the identified concerns to aspects this paper describes a tool called sair that can perform the second step of the aspect introducing refactoring for the first step documenting sair uses crosscutting concern sorts of the various possible sorts sair currently supports the two most commonly encountered ones role superimposition and consistent behavior the refactoring towards aspects of concerns of these sorts is illustrated on an open source application jhotdraw 2008 acm cluster analysis of java dependency graphs we present a novel approach to the analysis of dependency graphs of object oriented programs we propose to use the girvan newman clustering algorithm to compute the modular structure of programs this is useful in assisting software engineers to redraw component boundaries in software in order to improve the level of reuse and maintainability the results of this analysis can be used as a starting point for refactoring the software we present barrio an eclipse plugin that can detect and visualise clusters in dependency graphs extracted from java programs by means of source code and byte code analysis these clusters are then compared with the modular structure of the analysed programs defined by package and container specifications two metrics are introduced to measure the degree of overlap between the defined and the computed modular structure some empirical results obtained from analysing non trivial software packages are presented 2008 acm anti pattern detection cluster analysis dependency analysis refactoring documenting and evaluating scattered concerns for framework usability a case study scattered concerns design features whose implementations span multiple program units can pose extra difficulty for developers to locate understand modify and extend in particular since successful application frameworks tend to be widely used by many developers the impact of scattered concerns on framework usability can be especially significant ideally every scattered concern present at the framework interface should be carefully evaluated to justify its introduction if it cannot be avoided it should at least be well documented to facilitate its use to gain insights into how scattered concerns are actually designed and documented in industrial frameworks a method for documenting and evaluating scattered concerns is proposed and a manual pilot study on the jfc swing jtree is performed in this method concerns are identified and documented in a structured manner listing not only those items which an application must directly depend on but other methods and classes that indirectly contribute to the design of a concern the documented concerns are compared with the framework architecture in order to justify their existence concerns that map nicely to the architecture are deemed to be acceptable as they fit within the design and were explicitly traded off for other quality attributes those that show a mismatch indicate a place where the concern could cause problems for application developers and thus should be either refactored or well documented concerns are also evaluated using design criteria like cohesion and coupling while it is not always possible to identify design flaws in a scattered concern at the least documenting these concerns will make them easier to use the jtree study results in 12 concerns 7 of which are missing or only partially documented in the official swing tutorial 4 framework usability flaws are identified which if addressed would lead to the removal of 2 of the 12 documented concerns and improvements to another 2 thus the proposed method has the potential to be useful to framework development teams documenting and evaluating scattered concerns for framework usability a case study scattered concerns design features whose implementations span multiple program units can pose extra difficulty for developers to locate understand modify and extend in particular since successful application frameworks tend to be widely used by many developers the impact of scattered concerns on framework usability can be especially significant ideally every scattered concern present at the framework interface should be carefully evaluated to justify its introduction if it cannot be avoided it should at least be well documented to facilitate its use to gain insights into how scattered concerns are actually designed and documented in industrial frameworks a method for documenting and evaluating scattered concerns is proposed and a manual pilot study on the jfc swing jtree is performed in this method concerns are identified and documented in a structured manner listing not only those items which an application must directly depend on but other methods and classes that indirectly contribute to the design of a concern the documented concerns are compared with the framework architecture in order to justify their existence concerns that map nicely to the architecture are deemed to be acceptable as they fit within the design and were explicitly traded off for other quality attributes those that show a mismatch indicate a place where the concern could cause problems for application developers and thus should be either refactored or well documented concerns are also evaluated using design criteria like cohesion and coupling while it is not always possible to identify design flaws in a scattered concern at the least documenting these concerns will make them easier to use the jtree study results in 12 concerns 7 of which are missing or only partially documented in the official swing tutorial 4 framework us ability flaws are identified which if addressed would lead to the removal of 2 of the 12 documented concerns and improvements to another 2 thus the proposed method has the potential to be useful to framework development teams 2008 ieee overcoming jvm hotswap constraints via binary rewriting java hotspot vm provides a facility for replacing classes at runtime called hotswap one design property of hotswap is that the signature of a replaced class must remain the same between different versions which significantly constrains the programmer modifying a class to be replaced specifically the programmer is precluded from adding new methods constructors or fields or even changing the signatures of existing methods or fields this paper presents a novel approach that overcomes these constraints of hotswap by using binary refactoring a technique that rewrites the binary representation of a program without affecting its functionality a series of micro and macro benchmarks we conducted demonstrate that the approach is extensible and efficient in particular the new binary refactoring technique which enables the approach produces highly efficient refactored application versions outperforming a widely used prior technique by as much as an order of magnitude these initial results indicate that by rewriting the bytecode of a swapped program one can effectively overcome constraints of hotswap with minimal performance overhead copyright 2008 acm binary refactoring hotswap jvm languages virtual superclass verifiable functional purity in java proving that particular methods within a code base are functionally pure deterministic and side effect free would aid verification of security properties including function invertibility reproducibility of computation and safety of untrusted code execution until now it has not been possible to automatically prove a method is functionally pure within a high level imperative language in wide use such as java we discuss a technique to prove that methods are functionally pure by writing programs in a subset of java called joe e a static verifier ensures that programs fall within the subset in joe e pure methods can be trivially recognized from their method signature to demonstrate the practicality of our approach we refactor an aes library an experimental voting machine implementation and an html parser to use our techniques we prove that their top level methods are verifiably pure and show how this provides high level security guarantees about these routines our approach to verifiable purity is an attractive way to permit functional style reasoning about security properties while leveraging the familiarity convenience and legacy code of imperative languages copyright 2008 acm determinism object capabilities pure functions static analysis annotation refactoring inferring upgrade transformations for legacy applications since annotations were added to the java language many frameworks have moved to using annotated plain old java objects pojos in their newest releases legacy applications are thus forced to undergo extensive restructuring in order to migrate from old framework versions to new versions based on annotations version lock in additionally because annotations are embedded in the application code changing between framework vendors may also entail large scale manual changes vendor lock in this paper presents a novel refactoring approach that effectively solves these two problems our approach infers a concise set of semantics preserving transformation rules from two versions of a single class unlike prior approaches that detect only simple structural refactorings our algorithm can infer general composite refactorings and is more than 97 accurate on average we demonstrate the effectiveness of our approach by automatically upgrading more than 80k lines of the unit testing code of four open source java applications to use the latest version of the popular junit testing framework copyright 2008 acm annotations eclipse frameworks java junit metadata refactoring upgrading a study of region extraction and system model on an observation system of time sequenced 3 d ct images for an observation system assisted for diagnosis of 3 d ct images consisting of time sequenced multi slice tomograms the refinement method to obtain the more precise region detection on which noise areas are reduced is proposed the experimental results show that noise areas are reduced effectively and also the system model refined by code refactoring is also proposed to be able to make the system having flexibility also for that the proposed method is implemented the 2nd workshop on refactoring tools wrt 08 refactoring is the process of applying behavior preserving transformations to a program with the objective of improving the program s design a specific refactoring is identified by a name e g extract method a set of preconditions and a set of specific transformations that need to be performed tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial and non local program analysis and applying the transformations may affect many locations in the program in recent years the emergence of light weight programming methodologies such as extreme programming has generated a great amount of interest in refactoring and refactoring support has become a required feature in modern day ides until now there has not been a suitable forum for discussions among researchers and developers of such tools this full day event on refactoring tools fills that need with a strongly practical focus the workshop features both presentations given by developers and researchers in the field of refactoring as well as demonstrations of practical refactoring tools program analysis program manipulation refactoring transformation automated aspect recommendation through clustering based fan in analysis identifying code implementing a crosscutting concern ccc automatically can benefit the maintainability and evolvability of the application although many approaches have been proposed to identify potential aspects a lot of manual work is typically required before these candidates can be converted into refactorable aspects in this paper we propose a new aspect mining approach called clustering based fan in analysis cbfa to recommend aspect candidates in the form of method clusters instead of single methods cbfa uses a new lexical based clustering approach to identify method clusters and rank the clusters using a new ranking metric called cluster fanin experiments on linux and jhotdraw show that cbfa can provide accurate recommendations while improving aspect mining coverage significantly compared to other state of the art mining approaches 2008 ieee conflict aware schedule of software refactorings software refactoring is to restructure the internal structure of object oriented software to improve software quality especially maintainability extensibility and reusability while preserving its external behaviours according to predefined refactoring rules we may find many places in the software where refactorings can be applied applying each refactoring we may achieve some effect quality improvement if we can apply all of the available refactorings we can achieve the greatest effect however the conflicts among refactorings usually make it impossible the application of a refactoring may change or delete elements necessary for other refactorings and thus disables these refactorings as a result the application order schedule of the available refactorings determines which refactorings will be applied and thus determines the total effect achieved by the refactoring activity consequently conflicting refactorings had better be scheduled rationally so as to promote the total effect of refactoring activities however how to schedule conflicting refactorings is rarely discussed in this paper a conflict aware scheduling approach is proposed it schedules refactorings according to the conflict matrix of refactorings and effects of each individual refactoring the scheduling model is a multi objective optimisation model we propose a heuristic algorithm to solve the scheduling model we also evaluate the proposed scheduling approach in non trivial projects evaluation results suggest that refactoring activities with the scheduling approach lead to greater effect quality improvement than refactoring activities without explicit scheduling the institution of engineering and technology 2008 a metric based approach to identifying refactoring opportunities for merging code clones in a java software system a code clone is a code fragment that has other code fragments identical or similar to it in the source code the presence of code clones is generally regarded as one factor that makes software maintenance more difficult for example if a code fragment with code clones is modified it is necessary to consider whether each of the other code clones has to be modified as well removing code clones is one way of avoiding problems that arise due to the presence of code clones this makes the source code more maintainable and more comprehensible this paper proposes a set of metrics that suggest how code clones can be refactored as well the tool aries which automatically computes these metrics is presented the tool gives metrics that are indicators for certain refactoring methods rather than suggesting the refactoring methods themselves the tool performs only lightweight source code analysis hence it can be applied to a large number of code lines this paper also describes a case study that illustrates how this tool can be used based on the results of this case study it can be concluded that this method can efficiently merge code clones copyright 2008 john wiley sons ltd code clone metrics object oriented refactoring software maintenance antlrworks an antlr grammar development environment programmers tend to avoid using language tools resorting to ad hoc methods because tools can be hard to use their parsing strategies can be difficult to understand and debug and their generated parsers can be opaque black boxes in particular there are two very common difficulties encountered by grammar developers understanding why a grammar fragment results in a parser non determinism and determining why a generated parser incorrectly interprets an input sentence this paper describes antlrworks a complete development environment for antlr grammars that attempts to resolve these difficulties and in general make grammar development more accessible to the average programmer the main components are a grammar editor with refactoring and navigation features a grammar interpreter and a domain specific grammar debugger antlrworks primary contributions are a parser non determinism visualizer based on syntax diagrams and a time traveling debugger that pays special attention to parser decision making by visualizing lookahead usage and speculative parsing during backtracking copyright 2008 john wiley sons ltd debugger grammar development gui parser rapid prototyping proceedings 2nd ifip ieee international symposium on theoretical aspects of software engineering tase 2008 the proceedings contain 40 papers the topics discussed include prob gets nauty effective symmetry reduction for b and z models bounded model checking of compositional processes improving encoding efficiency for bounded model checking symbolic model checking apsl an extension to pointer logic for verification a generic model for confinement and its application a fundamental permission interpretation for ownership types structure and interpretation of computer programs a petri net based approach for supporting aspect oriented modeling a model driven method for the development of web applications user interaction layer a conceptual framework to integrate fault prediction sub process for software product lines executable requirements specification formal semantics of live activity diagrams a mde based approach for bridging formal models and uml model refactoring with emphasis on behavior preservation efficient automated marshaling of c data structures for mpi applications we present an automated approach for marshaling c data structures in high performance computing hpc applications our approach utilizes a graphical editor through which the user can express a subset of an object s state to be marshaled and sent across a network our tool mpi serializer then automatically generates efficient marshaling and unmarshaling code for use with the message passing interface mpi the predominant communication middleware for hpc systems our approach provides a more comprehensive level of support for c language features than the existing state of the art and does so in full compliance with the c language standard specifically we can marshal effectively and efficiently non trivial language constructs such as polymorphic pointers dynamically allocated arrays nonpublic member fields inherited members and stl container classes additionally our marshaling approach is also applicable to third party libraries as it does not require any modifications to the existing c source code we validate our approach through two case studies of applying our tool to automatically generate the marshaling functionality of two realistic hpc applications the case studies demonstrate that the automatically generated code matches the performance of typical hand written implementations and surpasses current state of the art c marshaling libraries in some cases by more than an order of magnitude the results of our case studies indicate that our approach can be beneficial for both the initial construction of hpc applications as well as for the refactoring of sequential applications for parallel execution 2008 ieee multidimensional correlation of software source code standard ways of calculating the similarity of different computer programs are needed in computer science such measurements can be useful in many different areas such as clone detection refactoring compiler optimization and run time optimization such standards are particularly important for uncovering plagiarism trade secret theft copyright infringement and patent infringement other uses include locating open source code within a proprietary program and determining the authors of different programs in a previous paper 19 i introduced the concept of source code correlation presented a theoretical basis for such a measure and described a program codematch that compares software source code and calculates correlation that paper compared the described method of source code correlation against existing methods of comparing source code and found it to be significantly superior this paper refines that definition of source code correlation and presents a new more robust definition of multidimensional source code correlation 2008 ieee an empirical study of evolution of inheritance in java oss previous studies of object oriented 00 software have reported avoidance of the inheritance mechanism and cast doubt on the wisdom of deep inheritance levels from an evolutionary perspective the picture is unclear we still know relatively little about how over time changes tend to be applied by developers our conjecture is that an inheritance hierarchy will tend to grow breadth wise rather than depth wise this claim is made on the basis that developers will avoid extending depth in favour of breadth because of the inherent complexity of having to understand the functionality of superclasses thus the goal of our study is to investigate this empirically we conduct an empirical study of seven java open source systems osss over a series of releases to observe the nature and location of changes within the inheritance hierarchies results showed a strong tendency for classes to be added at levels one and two of the hierarchy rather than anywhere else over 96 of classes added over the course of the versions of all systems were at level 1 or level 2 the results suggest that changes cluster in the shallow levels of a hierarchy this is relevant for developers since it indicates where remedial activities such as refactoring should be focused 2008 ieee refactoring effect estimation based on complexity metrics refactoring is a set of operations to improve maintainability or understandability or other attributes of a software system without changing the external behavior of it and it is getting much attention recently however it is difficult to perform appropriate refactorings since the impact of refactoring should justify the cost therefore before a refactoring is really performed the effect and the cost of it should be estimated the estimation makes it possible for us to adequately assess whether each refactoring should be performed or not this paper shows that it is difficult for developers to perform appropriate refactorings and proposes a method estimating refactoring effect the method has been implemented as a software tool and a case study was conducted with it the result of the case study showed that the estimation of the tool helped a developer of the target software system to perform an appropriate refactoring 2008 ieee annotation refactoring inferring upgrade transformations for legacy applications since annotations were added to the java language many frameworks have moved to using annotated plain old java objects pojos in their newest releases legacy applications are thus forced to undergo extensive restructuring in order to migrate from old framework versions to new versions based on annotations version lock in additionally because annotations are embedded in the application code changing between framework vendors may also entail largescale manual changes vendor lock in this paper presents a novel refactoring approach that effectively solves these two problems our approach infers a concise set of semantics preserving transformation rules from two versions of a single class unlike prior approaches that detect only simple structural refactorings our algorithm can infer general composite refactorings and is more than 97 accurate on average we demonstrate the effectiveness of our approach by automatically upgrading more than 80k lines of the unit testing code of four open source java applications to use the latest version of the popular junit testing framework copyright 2008 acm annotations eclipse frameworks java junit metadata refactoring upgrading object oriented software systems restructuring through clustering it is well known that maintenance and evolution represent important stages in the lifecycle of any software system about 66 from the total cost of the software systems development that is why in this paper we are focusing on the problem of automating an essential activity that appears in the maintenance and evolution of software systems the problem of identifying refactorings that would improve the structure of the system refactoring is the process of improving the design of software systems by improving their internal structure without altering the external behavior of the code the aim of this paper is to introduce a new clustering algorithm casyr clustering algorithm for software systems restructuring that can be used for improving software systems design by identifying the appropriate refactorings the proposed approach can be useful for assisting software engineers in their daily work of refactoring software systems we evaluate our approach on a real software system and we also provide a comparison with previous approaches 2008 springer verlag berlin heidelberg alloy as a refactoring checker refactorings are systematic changes made to programs models or specifications in order to improve their structure without changing the externally observable behaviour we will examine how a constraint solver the alloy analyzer can be used to automatically check if refactorings applied to a formal specification written in z meet this requirement furthermore we identify a class of refactorings for which the use of this tool is reasonable in general 2008 elsevier b v all rights reserved alloy behaviour preservation refactoring refinement z using fca to suggest refactorings to correct design defects design defects are poor design choices resulting in a hard to maintain software hence their detection and correction are key steps of a disciplined software process aimed at yielding high quality software artifacts while modern structure and metric based techniques enable precise detection of design defects the correction of the discovered defects e g by means of refactorings remains a manual hence error prone activity as many of the refactorings amount to re distributing class members over a possibly extended set of classes formal concept analysis fca has been successfully applied in the past as a formal framework for refactoring exploration here we propose a novel approach for defect removal in object oriented programs that combines the effectiveness of metrics with the theoretical strength of fca a case study of a specific defect the blob drawn from the azureus project illustrates our approach 2008 springer verlag berlin heidelberg design defects formal concept analysis refactoring detection of clone sequences and classes using ast in order to reduce code redundancy and improve program structure a novel approach based on abstract syntax is presented to detect clone code and several kinds of code clones that occur frequently in programs are outlined corresponding refactoring techniques are also presented abstract syntax of the analyzed program is represented as binary tree bast isomorphism of sub bast is judged statement by statement similar statement sequences are detected as clone sequences 1 tuple clone classes are detected according to isomorphism of sub bast by the join operation of clone classes 2 tuple and other clone classes can be achieved stage by stage the experiment analyzes several open source projects and clone sequences and classes are detected four kinds of code clones are induced from the detection result which have the following characters respectively accessing different properties of the same class s objects at the same program point modifying some variable names applying the same operation to different types modifying variables defined outside the clone area all the four kinds of clone codes are refactored successfully clone class clone detection code clone software maintenance contract specification in java classification characterization and a new marker method design by contract dbc originated in the eiffel programming language is generally accepted as a practical method for building reliable software currently however few languages have built in support for it in recent years several methods have been proposed to support dbc in java we compare eleven dbc tools for java by analyzing their impact on the developer s programming activities which are characterized by seven quality attributes identified in this paper it is shown that each of the existing tools fails to achieve some of the quality attributes this motivates us to develop ezcontract an open source dbc tool for java that achieves all of the seven quality attributes ezcontract achieves streamlined integration with the working environment notably standard java language is used and advanced ide features that work for standard java programs can also work for the contract enabled programs such features include incremental compilation automatic refactoring and code assist copyright 2008 the institute of electronics information and communication engineers characterization classification contract specification design by contract java quality attribute modularity oriented refactoring refactoring in spite of widely acknowledged as one of the best practices of object oriented design and programming still lacks quantitative grounds and efficient tools for tasks such as detecting smells choosing the most appropriate refactoring or validating the goodness of changes this is a proposal for a method supported by a tool for cross paradigm refactoring e g from oop to aop based on paradigm and formalism independent modularity assessment 2008 ieee web application evaluation and refactoring a quality oriented improvement approach rinton press web applications must be usable and accessible at the same time their continuous evolution makes it difficult to keep a high degree of external quality refactoring is a practice of agile methods well suited for the maintenance and evolution of web applications however this practice is mainly intended and used to improve maintainability and extensibility of the design and code rather than external qualities such as usability we believe that the concept of refactoring as behavior preserving transformations can be applied to the navigation and presentation models of a web application with the purpose of improving external quality for this reason we have defined the concept of web model refactoring this paper demonstrates how it is possible to improve the external quality of a web application by combining a mature quality measurement and evaluation method webqem with web model refactoring webqem is used to identify needs for improvement recommend web model refactorings and assess their impact on some defined attributes of a web product entity we present a case study showing how a typical shopping cart in an e commerce site can improve its usability and content quality with our integrated improvement approach external quality incami indicators metrics usability improvement web model refactoring web quality evaluation webqem editorial introduction the special issue of automated software engineering journal covers a wide range of topics and touch on tool support for many parts of the software lifecycle including code development verification and validation maintenance and reverse engineering in practical verification of decision making in agent based autonomous systems dennis fisher lincoln lisitsa and veres bring us a verification method for agent based hybrid systems they describe a model checking approach applicable to agent based logical components the results of which can be combined with a separate analysis of the continuous parts of the system evolution of a code base can lead to decay of the architecture through accumulated violations of the original architectural decisions in preserving architectural decisions through architectural patterns that sadou oquendo and fleurquin describe a technique for automating architectural conformance checking based on encoding architecture decisions into patterns that are combined into a model used for the checking in an approach to prioritize code smells for refactoring vidal marcos and diaz pace study the problem of dealing with the false positives to which existing code smell detection tools are prone fitscale scalability of legacy applications through migration to cloud springer international publishing switzerland 2016 one of the key benefits of cloud computing is elasticity the ability of the system infrastructure to adapt to the workload changes by automatically adjusting the resources on demand horizontal scaling refers to the method of adding or removing resources from the resource pool as such it is appealing to enterprises who seek to migrate their legacy systems as it requires no application rewrite or refactoring vertical scaling approach offers a mechanism to maintain continuous performance while reducing resource cost through reconfiguration of the resource the challenge is however in being able to automatically identify the right size of the target resource such as a vm or a container moreover choice of scalability policies is not intuitive due to application complexity topology and variability in system performance parameters that need to be considered this paper presents a transformation model fitscale which provides scalability with minimum price of resources the paper describes the framework that employs the application functional and operational properties to recommend the target sizing and scalability policies we evaluate proposed approach in an on premise and cloud environments with a dataset of 2023 servers hosting 6737 applications the experimental results show about 5 times cost reduction with minimum performance impact cloud elasticity migration scalability programming environments for blocks need first class software refactoring support a position paper 2015 ieee block based programming languages and their development environments have become a widely used educational platform for novices to learn how to program in addition these languages and environments have been increasingly embraced by domain experts to develop end user software though popular for having a «low floor» easy to get started programs written in block based languages often become unwieldy as projects grow progressively more complex software refactoring improving the design quality of a codebase while preserving its external functionality has been shown highly effective as a means of improving the quality of software written in text based languages unfortunately programming environments for blocks lack systematic software refactoring support in this position paper we argue that first class software refactoring support must become an essential feature in programming environments for blocks we present our research vision and concrete research directions including program analysis to detect «code smells » automated transformations for block based programs to support common refactoring techniques and integration of refactoring into introductory computing curricula block based programming languages code smells computer science curriculum end user software engineering introductory programming metrics refactoring impact of refactoring on code quality by using graph theory an empirical evaluation 2015 ieee refactoring is the process of improving code quality without affecting its external behaviour and by changing its internal structure refactoring is done to improve code quality and structure in this research we have proposed a new method of code refactoring by using graph theory techniques previously manual methods were used to identify the classes with high impact in refactoring the proposed method has been implemented and applied on software projects developed in java validation has been done by surveying software professionals to measure improve in code quality analysability changeability code refactoring graph theory refactoring techniques resource utilization time behavior lines of comments as a noteworthy metric for analyzing fault proneness in methods copyright 2015 the institute of electronics information and communication engineers this paper focuses on the power of comments to predict fault prone programs in general comments along with executable statements enhance the understandability of programs however comments may also be used to mask the lack of readability in the program therefore well written comments are referred to as deodorant to mask code smells in the field of code refactoring this paper conducts an empirical analysis to examine whether lines of comments lcm written inside a method s body is a noteworthy metric for analyzing fault proneness in java methods the empirical results show the following two findings 1 morecommented methods the methods having more comments than the amount estimated by size and complexity of the methods are about 1 6 2 8 times more likely to be faulty than the others and 2 lcm can be a useful factor in fault prone method prediction models along with the method size and the method complexity comments fault prone method prediction product metrics regression model a decision support system to refactor class cycles 2015 ieee many studies show that real world systems are riddled with large dependency cycles among software classes dependency cycles are claimed to affect quality factors such as testability extensibility modifiability and reusability recent studies reveal that most defects are concentrated in classes that are in and near cycles in this paper we 1 propose a new metric ircrss based on the class reachability set size crss to identify the reduction ratio between the crss of a class and its interfaces and 2 presents a cycle breaking decision support system cb dss that implements existing design approaches in combination with class edge contextual data evaluations of multiple systems show that 1 the ircrss metric can be used to identify fewer classes as candidates for breaking large cycles thus reducing refactoring effort and 2 the cb dss can assist software engineers to plan restructuring of classes involved in complex dependency cycles crss decision support system dependency cycle refactoring software quality scripting parametric refactorings in java to retrofit design patterns 2015 ieee retrofitting design patterns into a program by hand is tedious and error prone a programmer must distinguish refactorings that are provided by an integrated development environment ide from those that must be realized manually determine a precise sequence of refactorings to apply and perform this sequence repetitively to a laborious degree we designed implemented and evaluated reflective refactoring r 2 a java package to automate the creation of classical design patterns visitor abstract factory etc their inverses and variants we encoded 18 out of 23 gang of four design patterns as r 2 scripts and explain why the remaining are inappropriate for refactoring engines we evaluate the productivity and scalability of r 2 with a case study of 6 real world applications in one case r 2 automatically created a visitor with 276 visit methods by invoking 554 eclipse refactorings in 10 minutes an achievement that could not be done manually r 2 also sheds light on why refactoring correctness expressiveness and speed are critical issues for scripting in next generation refactoring engines delaydroid reducing tail time energy by refactoring android apps 2015 acm mobile devices with 3g 4g networking often waste energy in the so called tail time during which the radio is kept on even though no communication is occurring prior work has proposed policies to reduce this energy waste by batching network requests however this work is challenging to apply in practice due to a lack of mechanisms in response we have developed delaydroid a framework that allows a developer to add the needed policy to existing unmodified android applications apps with no human effort this allows such prior work as well as our own policies to be readily deployed and evaluated the delaydroid compile time uses static analysis and bytecode refactoring to identify method calls that send network requests and modify such calls to detour them to the delaydroid run time the run time then applies a policy to batch them avoiding the tail time energy waste delaydroid also includes a cross app communication mechanism that supports policies that optimize across multiple apps running together and we propose a policy that does so we evaluated the correctness and universality of the delaydroid mechanisms on 14 popular android apps chosen from the google app store to evaluate our proposed policy we studied three delaydroid enabled apps weather forecasting email client and news client running together finding that the delaydroid mechanisms combined with our policy can reduce 3g 4g tail time energy waste by 36 android energy optimization refactor an empirical study of design degradation how software projects get worse over time 2015 ieee context software decay is a key concern for large long lived software projects systems degrade over time as design and implementation compromises and exceptions pile up goal quantify design decay and understand how software projects deal with this issue method we conducted an empirical study on the presence and evolution of code smells used as an indicator of design degradation in 220 open source projects results the best approach to maintain the quality of a project is to spend time reducing both software defects bugs and design issues refactoring we found that design issues are frequently ignored in favor of fixing defects we also found that design issues have a higher chance of being fixed in the early stages of a project and that efforts to correct these stall as projects mature and the code base grows leading to a build up of problems conclusions from studying a large set of open source projects our research suggests that while core contributors tend to fix design issues more often than non core contributors there is no difference once the relative quantity of commits is accounted for we also show that design issues tend to build up over time design problems project history software decay assessing the refactorability of software clones 2015 ieee the presence of duplicated code in software systems is significant and several studies have shown that clones can be potentially harmful with respect to the maintainability and evolution of the source code despite the significance of the problem there is still limited support for eliminating software clones through refactoring because the unification and merging of duplicated code is a very challenging problem especially when software clones have gone through several modifications after their initial introduction in this work we propose an approach for automatically assessing whether a pair of clones can be safely refactored without changing the behavior of the program in particular our approach examines if the differences present between the clones can be safely parameterized without causing any side effects the evaluation results have shown that the clones assessed as refactorable by our approach can be indeed refactored without causing any compile errors or test failures additionally the computational cost of the proposed approach is negligible less than a second in the vast majority of the examined cases finally we perform a large scale empirical study on over a million clone pairs detected by four different clone detection tools in nine open source projects to investigate how refactorability is affected by different clone properties and tool configuration options among the highlights of our conclusions we found that a clones in production code tend to be more refactorable than clones in test code b clones with a close relative location i e same method type or file tend to be more refactorable than clones in distant locations i e same hierarchy or unrelated types c type 1 clones tend to be more refactorable than the other clone types and d clones with a small size tend to be more refactorable than clones with a larger size clone refactoring code duplication empirical study refactorability assessment software clone management a state tendency measurement for a hydro turbine generating unit based on aggregated eemd and svr 2015 iop publishing ltd the reliable measurement of state tendency for a hydro turbine generating unit hgu is significant in guaranteeing the security of the unit and promoting stability of the power system for this purpose an aggregated ensemble empirical mode decomposition aeemd and optimized support vector regression svr based hybrid model is developed in this paper in order to enhance the measuring accuracy of state tendency for a hgu first of all the non stationary time series of the state signal are decomposed into a collection of intrinsic mode functions imfs by eemd subsequently to obtain the refactored intrinsic mode functions rimfs the imfs with different scales are aggregated with the proposed reconstruction strategy in consideration of the frequency and energy conditions later the phase space matrix in accordance with each rimf is deduced by phase space reconstruction and all the rimfs are predicted through establishing homologous optimal svr forecasting models with a grid search finally the ultimate measuring values of state tendency can be determined through the accumulation of all the rimf forecasting values furthermore the effectiveness of the proposed method is validated in engineering experiments and comparative analyses aggregated ensemble empirical mode decomposition aeemd frequency and energy conditions hydro turbine generating unit hgu state tendency measurement support vector regression svr proceedings 41st euromicro conference on software engineering and advanced applications seaa 2015 the proceedings contain 71 papers the topics discussed include group maturity and agility are they connected a survey study towards customer centric software development a multiple case study towards customer centric software development a multiple case study improving test coverage measurement for reused software test and production classes of an industrial c system a refactoring and fault perspective a shadow structure for modularity of java program evolution efficient fault localization during replay of embedded software using design of experiments to optimize a decision of sufficient testing a power consumption estimation approach for embedded software design using trace analysis on the coherence between comments and implementations in source code and the relationship between depth of inheritance and refactoring an empirical study of eclipse releases detecting antipatterns in android apps 2015 ieee mobile apps are becoming complex software systems that must be developed quickly and evolve continuously to fit new user requirements and execution contexts however addressing these constraints may result in poor design choices known as antipatterns which may incidentally degrade software quality and performance thus the automatic detection of antipatterns is an important activity that eases both maintenance and evolution tasks moreover it guides developers to refactor their applications and thus to improve their quality while antipatterns are well known in object oriented applications their study in mobile applications is still in their infancy in this paper we propose a tooled approach called paprika to analyze android applications and to detect object oriented and android specific antipatterns from binaries of mobile apps we validate the effectiveness of our approach on a set of popular mobile apps downloaded from the google play store androids humanoid robots java measurement mobile applications mobile communication software evaluating quality of primary studies on determining object oriented code refactoring candidates copyright 2015 acm refactoring is a maintenance task that aims at improving the quality of a software source code by restructuring it without altering its external behavior identifying refactoring opportunities by manually inspecting and analyzing the source code of the system under consideration is a time consuming and costly process researchers in this area typically introduce fully or semi automated techniques to determine or predict refactoring candidates and they report related evaluation studies the quality of the performed studies has a great impact on the accuracy of the obtained results in this paper we demonstrate an application for a proposed framework that evaluates published primary studies pss on refactoring prediction identification techniques the framework is applied on 47 selected pss to evaluate the quality of the studies based on their design conduct analysis and conclusion we used the results to comment on the weaknesses of the existing pss and the issues that have to be considered with more attention in future studies object oriented code refactoring activity refactoring opportunity study quality assessment international workshop on principles of software evolution iwpse the proceedings contain 9 papers the topics discussed include localizing faults in test execution traces circumventing refactoring masking using fine grained change recording hierarchical categorization of edit operations for separately committing large refactoring results the driving forces of api evolution the impact of developer team sizes on the structural attributes of software revisiting the applicability of the pareto principle to core development teams in open source software projects software evolution and time series volatility an empirical exploration estimating product evolution graph using kolmogorov complexity and using control flow analysis to improve the effectiveness of incremental mutation testing a first approach on legacy system energy consumption measurement 2015 ieee nowadays software sustainability is growing in importance not only it infrastructure is becoming greener but also software it is possible to find methods and methodologies intended to produce more sustainable software with lower power consumption in spite the slow evolution of software engineering towards green software there exist a huge amount of legacy systems still running in organizations is then necessary to develop such systems from scratch in order to make them more sustainable probably the most logical and appropriate answer for this question is no since existing software can be refactored in order to improve its green ability quality characteristic as a first step towards power consumption improvement the authors propose a tool to analyze legacy systems in order to detect parts of the system with higher energy consumption using the profiling technique the proposed tool instrument legacy java systems in order to keep track of its execution this information together with the energy consumption logged by means a data logger hardware enables the engineer to analyze legacy system consumption detecting energy peaks in the system e g the pc the analysis gives the engineer evidences about candidates to be refactored in order to reduce energy consumption energy consumption energy data logger profiling reverse engineering software energy consumption software sustainability automatic code locations identification for replacing temporary variable with query method 2015 ieee automatic application of refactoring techniques can help developer save effort for removing bad smells from their code which improves software maintainability to remove automatically long method bad smell which is one of the most serious bad smells we need an automatic application of six refactoring techniques however only one refactoring technique extract method can be automated in this research we propose an algorithm to identify code locations which will be extracted for creating a query method we performed an experiment to conclude the workability and correctness of our algorithm this is the most important step towards an automatic application of refactoring technique replace temp with query bad smell program dependency graph program slicing refactoring application software maintenance unlocking blocked communicating processes a francalanza m giunti and a ravara we study the problem of disentangling locked processes via code refactoring we identify and characterise a class of processes that is not lock free then we formalise an algorithmthat statically detects potential locks and propose refactoring procedures that disentangle detected locks our development is cast within a simple setting of a finite linear ccs variant although it suffices to illustrate the main concepts we also discuss how our work extends to other language extensions extract package refactoring in aries 2015 ieee software evolution often leads to the degradation of software design quality in object oriented oo systems this often results in packages that are hard to understand and maintain as they group together heterogeneous classes with unrelated responsibilities in such cases state of the art re modularization tools solve the problem by proposing a new organization of the existing classes into packages however as indicated by recent empirical studies such approaches require changing thousands of lines of code to implement the new recommended modularization in this demo we present the implementation of an extract package refactoring approach in aries automated refactoring in eclipse a tool supporting refactoring operations in eclipse unlike state of the art approaches aries automatically iden tifies and removes single low cohesive packages from software systems which represent localized design flaws in the package organization with the aim to incrementally improve the overall quality of the software modularisation an approach to detect android antipatterns 2015 ieee mobile applications are becoming complex software systems that must be developed quickly and evolve regularly to fit new user requirements and execution contexts however addressing these constraints may result in poor design choices known as antipatterns which may degrade software quality and performance thus the automatic detection of antipatterns is an important activity that eases the future maintenance and evolution tasks moreover it helps developers to refactor their applications and thus to improve their quality while antipatterns are well known in object oriented applications their study in mobile applications is still in their infancy in this paper we presents a tooled approach called paprika to analyze android applications and to detect object oriented and android specific antipatterns from binaries of applications does automated refactoring obviate systematic editing 2015 ieee when developers add features and fix bugs they often make systematic edits similar edits to multiple locations systematic edits may indicate that developers should instead refactor to eliminate redundancy this paper explores this question by designing and implementing a fully automated refactoring tool called rase which performs clone removal rase 1 extracts common code guided by a systematic edit 2 creates new types and methods as needed 3 parameterizes differences in types methods variables and expressions and 4 inserts return objects and exit labels based on control and data flow to our knowledge this functionality makes rase the most advanced refactoring tool for automated clone removal we evaluate rase with real world systematic edits and compare to method based clone removal rase successfully performs clone removal in 30 of 56 method pairs n 2 and 20 of 30 method groups n 3 with systematic edits we find that scoping refactoring based on systematic edits 58 rather than the entire method 33 increases the applicability of automated clone removal automated refactoring is not feasible in the other 42 cases which indicates that automated refactoring does not obviate the need for systematic editing prioritization of classes for refactoring a step towards improvement in software quality 2015 acm bad smells are certain structures in the software which violates the design principles and ruin the software quality in order to deals with the bad smells often refactoring treatment is provided in the code which further improves the software quality however it s not possible to refactor each and every class of the software in maintenance phase due to certain deadlines prioritization of classes helps the developer to identify the software portions requiring urgent refactoring in the current study we propose a framework to identify the potential classes which immediately require refactoring based on the bad smells as well as design characteristics we evaluate our approach on medium sized open source systems ordrumbox four types of code smells feature envy long method god class and type checking were identified and well known chidamber and kemerer metric suite is used to evaluate the object oriented characteristics both are combined in certain ratio to calculate new proposed metric quality depreciation index rule qdir for each class classes are further arranged as per their qdir values to identify the severely affected classes requiring immediate refactoring treatment this study works on 80 20 principles conveying 80 of the code quality can be improved by just providing refactoring treatment to 20 of the severely affected classes results reflects that the bad smells and design metrics can be used as an important source of information to quantify the flaws in the classes thus helpful to maintainers in performing their task under strict time constraints while maintaining the overall software quality bad smell object oriented metrics refactoring software maintenance software quality a proof system for adaptable class hierarchies 2014 elsevier inc abstract the code base of a software system undergoes changes during its life time for object oriented languages classes are adapted e g to meet new requirements customize the software to specific user functionalities or refactor the code to reduce its complexity however the adaptation of class hierarchies makes reasoning about program behavior challenging even classes in the middle of a class hierarchy can be modified this paper develops a proof system for analyzing the effect of operations to adapt classes in the context of method overriding and late bound method calls the proof system is incremental in the sense that reverification is avoided for methods that are not explicitly changed by adaptations furthermore the possible adaptations are not unduly restricted i e flexibility is retained without compromising on reasoning control to achieve this balance we extend the mechanism of lazy behavioral subtyping originally proposed for reasoning about inheritance when subclasses are added to a class hierarchy to deal with the more general situation of adaptable class hierarchies and changing specifications the reasoning system distinguishes guaranteed method behavior from requirements toward methods and achieves incremental reasoning by tracking guarantees and requirements in adaptable class hierarchies we show soundness of the proposed proof system class updates dynamic code modification object orientation proof systems software evolution verification the eureka programming model for speculative task parallelism shams imam and vivek sarkar in this paper we describe the eureka programming model eupm that simplifies the expression of speculative parallel tasks and is especially well suited for parallel search and optimization applications the focus of this work is to provide a clean semantics for and efficiently support such eureka style computations euscs in general structured task parallel programming models in euscs a eureka event is a point in a program that announces that a result has been found a eureka triggered by a speculative task can cause a group of related speculative tasks to become redundant and enable them to be terminated at well defined program points our approach provides a bound on the additional work done in redundant speculative tasks after such a eureka event occurs we identify various patterns that are supported by our eureka construct which include search optimization convergence and soft real time deadlines these different patterns of computations can also be safely combined or nested in the eupm along with regular task parallel constructs thereby enabling high degrees of composability and reusability as demonstrated by our implementation the eupm can also be implemented efficiently we use a cooperative runtime that uses delimited continuations to manage the termination of redundant tasks and their synchronization at join points in contrast to current approaches eupm obviates the need for cumbersome manual refactoring by the programmer that may for example require the insertion of if checks and early return statements in every method in the call chain experimental results show that solutions using the eupm simplify programmability achieve performance comparable to hand coded speculative task based solutions and out perform non speculative task based solutions async finish model delimited continuations eureka model parallel programming speculative parallelism task cancellation task termination advanced hybrid transient stability and emt simulation for vsc hvdc systems 1986 2012 ieee this paper deals with advanced hybrid transient stability and electromagnetic transient emt simulation of combined ac dc power systems containing large amounts of renewable energy sources interfaced through voltage source converter high voltage direct current vsc hvdc the concerning transient stability studies require the dynamic phenomena of interest to be included with adequate detail and reasonable simulation speed hybrid simulation offers this functionality and this contribution focuses on its application to multiterminal vsc hvdc systems existing numerical interfacing methods have been evaluated and improved for averaged vsc modeling these innovations include 1 ac system equivalent impedance refactorization after faults 2 amended interaction protocols for improved thévenin equivalent source updating inside the emt type simulation and 3 a special new interaction protocol for improved phasor determination during faults the improvements introduced in this contribution lead to more accurate ac vsc hvdc transient stability assessment compared to conventional interfacing techniques hybrid simulation multiterminal transient stability voltage source converter high voltage direct current vsc hvdc an exploration of the introduce explaining variable refactoring 2015 acm while we know much about refactoring trends and their occurrence in open source and proprietary systems we still know little about their association with defects or the nature of classes where refactoring is applied in this paper we explore one such refactoring introduce explaining variable iev a low level code based refactoring which simplifies a complex expression through the introduction of added variables we explore the possibility that this type of refactoring requiring manipulation of variables and constructs will have a greater association with defects than other types of refactoring classes where they are applied will have lower coupling levels five releases from two projects of eclipse were used to support this analysis and tools to extract both the set of class refactorings and class coupling and size metrics supported the analysis results showed that for four out of the five releases studied classes where the iev refactoring had been applied were more defect prone than other classes coupling in the same set of classes was higher in all five releases size on the other hand may be a confounding factor but tentative results suggest that areas of code where this refactoring had been applied are indicative of defect prone code coupling defects refactoring variable test coverage and impact analysis for detecting refactoring faults a study on the extract method refactoring copyright 2015 acm refactoring validation by automated testing is a common practice in agile development processes however this practice can be misleading when the test suite is not adequate particularly refactoring faults can be tricky and difficult to detect while coverage analysis is a standard practice to evaluate a test suite s fault detection capability there is usually low correlation between coverage and fault detection in this paper we present an exploratory study on coverage of refactoring impacted code in order to identify shortcomings of test suites focusing on the extract method refactoring we consider three open source projects and their test suites the results show that in most cases the lacking of test case calling the method changed in the refactoring increases the chance of missing faults also a high proportion of test cases that do not cover the callers of that method does not reveal the fault either additional analysis of branch coverage on the test cases exercising impacted elements show a higher chance of detecting a fault when branch coverage is also high it seems reasonable to conclude that a combination of impact analysis with branch coverage could be highly effective in detecting faults introduced by extract method coverage refactoring testing detecting and refactoring code smells in spreadsheet formulas 2014 springer science business media new york spreadsheets are used extensively in business processes around the world and just like software spreadsheets are changed throughout their lifetime causing understandability and maintainability issues this paper adapts known code smells to spreadsheet formulas to that end we present a list of metrics by which we can detect smelly formulas a visualization technique to highlight these formulas in spreadsheets and a method to automatically suggest refactorings to resolve smells we implemented the metrics visualization and refactoring suggestions techniques in a prototype tool and evaluated our approach in three studies firstly we analyze the euses spreadsheet corpus to study the occurrence of the formula smells secondly we analyze ten real life spreadsheets and interview the spreadsheet owners about the identified smells finally we generate refactoring suggestions for those ten spreadsheets and study the implications the results of these evaluations indicate that formula smells are common that they can reveal real errors and weaknesses in spreadsheet formulas and that in simple cases they can be refactored code smells refactoring spreadsheets autorefactoring a platform to build refactoring agents 2014 elsevier ltd all rights reserved software maintenance may degrade the software quality one of the primary ways to reduce undesired effects of maintenance is refactoring which is a technique to improve software code quality without changing its observable behavior to safely apply a refactoring several issues must be considered i identify the code parts that should be improved ii determine the changes that must be applied to the code in order to improve its iii evaluate the corrections impacts on code quality and iv check that the observable behavior of the software will be preserved after applying the corrections given the amount of issues to consider refactoring by hand has been assumed to be an expensive and error prone task therefore in this paper we propose an agent based platform that enables to implement an agent able to autonomously deal with the above mentioned refactoring issues to evaluate our approach we performed an empirical study on code smells detection and correction code quality improvement and preservation of the software observable behavior to answer our research questions we analyze 5 releases of java open source projects ranging from 166 to 711 classes autonomous agents code quality smells correction smells detection software refactoring identifying refactoring opportunities in object oriented code a systematic literature review 2014 elsevier b v all rights reserved context identifying refactoring opportunities in object oriented code is an important stage that precedes the actual refactoring process several techniques have been proposed in the literature to identify opportunities for various refactoring activities objective this paper provides a systematic literature review of existing studies identifying opportunities for code refactoring activities method we performed an automatic search of the relevant digital libraries for potentially relevant studies published through the end of 2013 performed pilot and author based searches and selected 47 primary studies pss based on inclusion and exclusion criteria the pss were analyzed based on a number of criteria including the refactoring activities the approaches to refactoring opportunity identification the empirical evaluation approaches and the data sets used results the results indicate that research in the area of identifying refactoring opportunities is highly active most of the studies have been performed by academic researchers using nonindustrial data sets extract class and move method were found to be the most frequently considered refactoring activities the results show that researchers use six primary existing approaches to identify refactoring opportunities and six approaches to empirically evaluate the identification techniques most of the systems used in the evaluation process were open source which helps to make the studies repeatable however a relatively high percentage of the data sets used in the empirical evaluations were small which limits the generality of the results conclusions it would be beneficial to perform further studies that consider more refactoring activities involve researchers from industry and use large scale and industrial based systems refactoring activity refactoring opportunity systematic literature review a learning based method for detecting defective classes in object oriented systems 2015 ieee code or design problems in software classes reduce understandability flexibility and reusability of the system performing maintenance activities on defective components such as adding new features adapting to the changes finding bugs and correcting errors is hard and consumes a lot of time unless the design defects are corrected by a refactoring process these error prone classes will most likely generate new errors after later modifications therefore these classes will have a high error frequency ef which is defined as the ratio between the number of errors and modifications early estimate of error prone classes helps developers to focus on defective modules thus reduces testing time and maintenance costs in this paper we propose a learning based decision tree model for detecting error prone classes with structural design defects the main novelty in our approach is that we consider efs and change counts chc of classes to construct a proper data set for the training of the model we built our training set that includes design metrics of classes by analyzing numerous releases of real world software products and considering efs of classes to mark them as error prone or non error prone we evaluated our method using two long standing software solutions of ericsson turkey we shared and discussed our findings with the development teams the results show that our approach succeeds in finding error prone classes and it can be used to decrease the testing and maintenance costs bug prediction decision tree software defects software quality identification of opportunities for move method refactoring using decision theory springer verlag berlin heidelberg 2015 the early versions of object oriented software system may function correctly but sometimes its internal structure may not be well designed some classes may be god classes with several different behaviors god classes have low cohesion in which some of their methods should be moved to another class finding a target method of a class to be moved to another class is a challenging problem this paper proposes an approach to identity opportunity for move method using decision theory the approach searches for candidate classes and chooses only one class with the highest coupling value which is used as decision criteria of laplace method a preliminary evaluation is performed on object oriented software to demonstrate the effectiveness of the proposed approach the results show that the proposed method can improve the design quality of the source code cohesion coupling decision theory move method refactoring software metric clear class level software refactoring using evolutionary algorithms the original design of a software system is rarely prepared for every new requirement software systems should be updated frequently which is usually accompanied by the decline in software modularity and quality although many approaches have been proposed to improve the quality of software a majority of them are guided by metrics defined on the local properties of software in this article we propose to use a global metric borrowed from the network science to detect the moving method refactoring first our approach uses a bipartite network to represent classes features i e methods and fields and their dependencies second a new metric is introduced to quantify the modularity of a software system as a whole finally a crossover only evolutionary algorithm that uses the metric as its fitness function is introduced to optimize the class structure of a software system and detect the methods that should be moved empirical results on the benchmark java projects show that our approach can find meaningful methods that should be moved with a high stability the advantages of our approach are illustrated in comparison with some other approaches specifically one refactoring approach namely search based refactoring approach sbra and two community detection algorithms namely a graph theoretic clustering algorithm mcode and a fast algorithm for community detection fg our approach provides a new way to do refactoring from the perspective of software structure evolutionary algorithm modularity refactoring class software network software quality measurement and improvement using refactoring and square metric methods 2005 2015 jatit lls all rights reserved software requirement is one of critical factors in a successful software development based on some existing researches a good or poor design of software relies heavily on the quality of software requirements as a definition of software requirements is certainly an early stage in software development in an it project such as a development of school of social network ssn some problems concerning software quality requirements may occur any time the changes occurring in the software requirements and the mismatch among the needs designs and final result of the project can lead to poor quality of the software produced to minimize the problems it is necessary to measure the quality of software requirements based on square metrics using refactoring first it is to determine the characteristics of software quality requirements the determination of quality characteristics of ssn is based on an expert experience and eventually sets 4 attributes of software quality requirements that are considered very important namely correctness completeness consistency and non ambiguity second it is to give a weight on each quality characteristic to obtain the irq value third the process of refactoring is conducted to improve the usecase scenarios and the last step is to re measure the quality of re factored software requirement the early measurements showed that the quality requirements of the ssn reached 39 through refactoring process the improvement of software requirements caused an increase of 6 use cases and after repair by using refactoring it increased the quality of the requirements of ssn by 62 refactoring is definitely helpful for enhancing the understanding on software requirements without changing the software business process refactoring software quality software requirements square metrics use case scenario a comparison of some soft computing methods for software fault prediction 2014 elsevier ltd all rights reserved the main expectation from reliable software is the minimization of the number of failures that occur when the program runs determining whether software modules are prone to fault is important because doing so assists in identifying modules that require refactoring or detailed testing software fault prediction is a discipline that predicts the fault proneness of future modules by using essential prediction metrics and historical fault data this study presents the first application of the adaptive neuro fuzzy inference system anfis for the software fault prediction problem moreover artificial neural network ann and support vector machine svm methods which were experienced previously are built to discuss the performance of anfis data used in this study are collected from the promise software engineering repository and mccabe metrics are selected because they comprehensively address the programming effort roc auc is used as a performance measure the results achieved were 0 7795 0 8685 and 0 8573 for the svm ann and anfis methods respectively adaptive neuro fuzzy systems artificial neural networks mccabe metrics software fault prediction support vector machines size and cohesion metrics as indicators of the long method bad smell an empirical study 2015 acm source code bad smells are usually resolved through the application of well defined solutions i e refactorings in the literature software metrics are used as indicators of the existence and prioritization of resolving bad smells in this paper we focus on the long method smell i e one of the most frequent and persistent bad smells that can be resolved by the extract method refactoring until now the identification of long methods or extract method opportunities has been performed based on cohesion size or complexity metrics however the empirical validation of these metrics has exhibited relatively low accuracy with regard to their capacity to indicate the existence of long methods or extract method opportunities thus we empirically explore the ability of size and cohesion metrics to predict the existence and the refactoring urgency of long method occurrences through a case study on java open source methods the results of the study suggest that one size and four cohesion metrics are capable of characterizing the need and urgency for resolving the long method bad smell with a higher accuracy compared to the previous studies the obtained results are discussed by providing possible interpretations and implications to practitioners and researchers case study cohesion long method metrics size an efficient approach to identify multiple and independent move method refactoring candidates 2014 elsevier b v all rights reserved context application of a refactoring operation creates a new set of dependency in the revised design as well as a new set of further refactoring candidates in the studies of stepwise refactoring recommendation approaches applying one refactoring at a time has been used but is inefficient because the identification of the best candidate in each iteration of refactoring identification process is computation intensive therefore it is desirable to accurately identify multiple and independent candidates to enhance efficiency of refactoring process objective we propose an automated approach to identify multiple refactorings that can be applied simultaneously to maximize the maintainability improvement of software our approach can attain the same degree of maintainability enhancement as the method of the refactoring identification of the single best one but in fewer iterations lower computation cost method the concept of ma ximal independent set mis enables us to identify multiple refactoring operations that can be applied simultaneously each mis contains a group of refactoring candidates that neither affect i e enable or disable nor influence maintainability on each other refactoring effect delta table quantifies the degree of maintainability improvement each elementary candidate for each iteration of the refactoring identification process multiple refactorings that best improve maintainability are selected among sets of refactoring candidates miss results we demonstrate the effectiveness and efficiency of the proposed approach by simulating the refactoring operations on several large scale open source projects such as jedit columba and jgit the results show that our proposed approach can improve maintainability by the same degree or to a better extent than the competing method choosing one refactoring candidate at a time in a significantly smaller number of iterations thus applying multiple refactorings at a time is both effective and efficient conclusion our proposed approach helps improve the maintainability as well as the productivity of refactoring identification maintainability improvement multiple simultaneous refactorings refactoring effect dependency refactoring identification process refactoring selection a method based on permutation entropy for instantaneous voltage disturbances signal de noising and location 2015 taylor francis group london a new method was proposed based on permutation entropy toward detection to the instantaneous voltage disturbances signal at first it used the ceemd to decompose the signals to get the intrinsic mode function imf components and then figured out the permutation entropy of each imf component to test the randomness to estimate whether the imf component is an abnormal signal afterwards refactoring the normal imf components to get the de noised signals of the instantaneous voltage disturbances it can be preferable to persist the disturbance characteristics of the disturbance signal permutation entropy curve can get mutations of power quality at the beginning and ending of the perturbation moment the results of simulation show that the method has advantages such as antinoise ability small waveform distortion and exact extraction of disturbance characteristics it can be applied in de noising and location of the instantaneous voltage disturbances a compound de noising method for operational modal identification of offshore wind turbine structure 2015 tianjin university all right reserved to solve the problem in identifying modal parameters accurately and retraining false modes induced by severe disruption due to the electromagnetic frequency signals rotational frequency signals and environmental noise usually mixed in the acceleration data observed from prototype test of offshore wind turbine structure a compound de noising method combining self adaptive filter and ensemble empirical mode decomposition was put forward to achieve filtering noise reduction and modal identification for the first time by means of testing signal processing in the new way including filtering decomposing de noising and refactoring much noise interference was reduced and full information of the structural vibration was reserved then the modal information will be identified preliminarily using both random decrement technique and eigensystem realization algorithm and the false modes were eliminated by vibration mode analysis in order to obtain the operation modal parameters of offshore wind power structure correctly besides the method presented here not only shows better accuracy and higher efficiency in noise reduction compared to the classic approaches which are lack of the statistical characteristics of noise but also provides operational modal identification of wind turbine structure with a preferable applied value in engineering based on measured signals ensemble empirical mode decomposition eemd modal identification mode shape analysis offshore wind power self adaptive filtering code smells detection and visualization of software systems 2015 the authors and ios press all rights reserved bad smells are symptoms in the source code that indicate possible deeper problems and may serve as drivers for code refactoring although efforts have been made on measuring code complexity in object oriented systems such as ck metrics little emphasis has been put on analyzing code smells through a visualization manner in this paper we present a system for detecting and visualizing three kinds of code smells of software systems long method large class and long parameter list thresholds for identifying the code smells are calculated based on statistics analysis on the source code of 50 open source projects code smells are visualized as graphs with colored nodes according to their different severity degrees code analysis code smell code visualization feature envy factor a metric for automatic feature envy detection 2015 ieee as a software system evolves its design get deteriorated and the system becomes difficult to maintain in order to improve such an internal quality the system must be restructured without affecting its external behavior the process involves detecting the design flaws or code smells and applying appropriate refactorings that could help remove such flaws one of the design flaws in many object oriented systems is placing members in the wrong class this code smell is called feature envy and it is a sign of inappropriate coupling and cohesion this work proposes a metric to detect feature envy code smell that can be removed by relocating the method our evaluation shows promising results as the overall system s complexity is reduced after suggested move method refactorings are applied code smells design flaws feature envy refactoring software metric software quality the effect of refactoring on change and fault proneness in commercial c software 2015 elsevier b v all rights reserved refactoring is a process for improving the internal characteristics and design of software while preserving its external behaviour refactoring has been suggested as a positive influence on the long term quality and maintainability of software and as a result we might expect benefits of a lower future change or fault propensity by refactoring software conversely many studies show a correlation between change and future faults so application of a refactoring may in itself increase future fault propensity negating any benefit of the refactoring in this paper we determine whether the refactoring process reaps future maintenance benefits and as a consequence results in software with a lower propensity for both faults and change we studied a large commercial software system over a twelve month period and identified a set of refactored classes during the middle four months of the study a bespoke tool was used to detect occurrences of fifteen types of refactoring we then examined the fault and change proneness of the same set of refactored classes in the four months prior to during and after the period of refactoring to determine if change or fault activity was reduced either during or after the period of refactoring studied we also compared these trends with remaining classes in the system that had not been refactored over the same periods results revealed that refactored classes experienced a lower change proneness in the period after refactoring and were significantly less fault prone during and after the period of refactoring even when accounting for the effects of change the study therefore presents concrete evidence of the benefits of refactoring in these two senses change proneness evolution fault analysis refactoring safely managing data variety in big data software development 2015 ieee we consider the task of building big data software systems offered as software as a service these applications are commonly backed by nosql data stores that address the proverbial vs of big data processing nosql data stores can handle large volumes of data and many systems do not enforce a global schema to account for structural variety in data thus software engineers can design the data model on the go a flexibility that is particularly crucial in agile software development however nosql data stores commonly do not yet account for the veracity of changes when it comes to changes in the structure of persisted data yet this is an inevitable consequence of agile software development in most nosql based application stacks schema evolution is completely handled within the application code usually involving object mapper libraries yet simple code refactorings such as renaming a class attribute at the source code level can cause data lossor runtime errors once the application has been deployed to production we address this pain point by contributing type checking rules that we have implemented within an ide plug in our plug in contro vol statically type checks the object mapper class declarations against the code release history contro vol is thus capable of detecting common yet risky cases of mismatched data and schema and can even suggest automatic fixes nosql data stores object mapping schema evolution type checking ttc 2015 case refactoring java programs using spoon 2015 g szárnyas et al ttc 2015 is the 8th transformation tool contest for users and developers of transformation tools in this paper we present the use of spoon an open source library to transform and analyze java source code for the code refactoring track of ttc 2015 we use spoon to implement pull up method and create super class refactorings the implementation uses an unmodified revision of spoon and is done in 125 lines weighted multi factor multi layer identification of potential causes for events of interest in software repositories copyright 2015 by the paper s authors change labelling is a fundamental challenge in software evolution certain kinds of changes can be labeled based on directly measurable characteristics labels for other kinds of changes such as changes causing subsequent fixes need to be estimated retrospectively in this article we present a weight based approach for identifying potential causes for events of interest based on a cause fix graph supporting multiple factors such as causing a fix or a refactoring and multiple layers reflecting different levels of granularity such as project file class method we outline different strategies that can be employed to refine the weights distribution across the different layers in order to obtain more specific labelling at finer levels of granularity an experimental investigation on the innate relationship between quality and refactoring 2015 elsevier inc all rights reserved previous studies have investigated the reasons behind refactoring operations performed by developers and proposed methods and tools to recommend refactorings based on quality metric profiles or on the presence of poor design and implementation choices i e code smells nevertheless the existing literature lacks observations about the relations between metrics code smells and refactoring activities performed by developers in other words the characteristics of code components increasing decreasing their chances of being object of refactoring operations are still unknown this paper aims at bridging this gap specifically we mined the evolution history of three java open source projects to investigate whether refactoring activities occur on code components for which certain indicators such as quality metrics or the presence of smells as detected by tools suggest there might be need for refactoring operations results indicate that more often than not quality metrics do not show a clear relationship with refactoring in other words refactoring operations are generally focused on code components for which quality metrics do not suggest there might be need for refactoring operations finally 42 of refactoring operations are performed on code entities affected by code smells however only 7 of the performed operations actually remove the code smells from the affected class code smells empirical study refactoring a duplicated code refactoring advisor springer international publishing switzerland 2015 refactoring is one of the key practices in extreme programming and other agile methods duplicated code is one of the most pervasive and pungent smells to remove from source code through refactoring duplicated code has been largely studied in the literature and different types of duplications or clones have been identified some studies analyzed in details the problems caused by clones in the code others outlined also the difficulties in removing clones and the cases in which it could be better not removing them the refactoring cost for removing clones can be very high also due to the different choices on the possible refactoring steps in this paper we describe our approach and tool developed with the aim to suggest the best refactorings to remove clones in java code our approach is based on the classification of the clones in terms of their location in a class hierarchy and allows to choose among a restricted set of refactorings which are then evaluated using multiple criteria we provide a validation of the effectiveness of the approach clone refactoring empirical study refactoring advisor non source code refactoring a systematic literature review 2015 sersc since software refactoring techniques were introduced the process is commonly applied to alter the structure of source code however there is also increasing popularity in the topic of refactoring in other software artifacts at non source code level this paper provides a systematic literature review of existing studies in non source code refactoring we use two digital libraries as publication source ieeexplore and science direct to obtain published articles in non source code refactoring topic published in between 2002 2014 with certain keywords the 20 selected literatures then processed based on certain criteria including the refactoring method and refactoring identification source then we use this information to provide categorization of non source code refactoring activity and the advantages and disadvantages of each category the systematic literature review performed has provided categorization of non source code refactoring method and has shown that each method has certain advantages and disadvantages refactoring detection at non source code level can be done in the software design model source code with non conventional detection and other software artifacts the methods used can be categorized as heuristic method where the refactoring identification is done based on certain rules and non heuristic method where the refactoring identification is done with a certain algoritm that explores every possibility of refactoring opportunities the advantage of heuristic method is the speed and precision the disadvantage of this method is the needed effort to produce the rules and the possibility of the non optimal result the advantage of non heuristic method is it can yield a generally more optimal result the disadvantage of non heuristic method is that the result depends strongly on the robustness of each algorithm high level refactoring non source code refactoring software refactoring towards a unifying approach for performance driven software model refactoring performance is a pervasive quality attribute of software systems since it plays a key role in the success of many projects it is important to introduce approaches aimed at satisfying performance requirements from the early phases of software life cycle however this is a complex problem because a large gap exists between performance analysis results and the feedback expected by software designers some approaches proposed in the last few years aim at reducing such gap based on automated model driven engineering techniques but they are fragmented across different paradigms languages and metamodels the goal of this paper is to work towards an approach that enables performance problems detection and solution within an unique supporting environment we rely on the epsilon platform which provides an ecosystem of task specific languages interpreters and tools for mde we describe the approach that we are implementing and we show how some of these languages nicely fit the needs of a unifying paradigm for performance driven software model refactoring model driven engineering performance antipatterns software performance engineering software refactoring 27th ifip wg 6 1 international conference on testing software and systems ictss 2015 the proceedings contain 18 papers the special focus in this conference is on model based testing and test derivation methods the topics include checking experiments for finite state machines with symbolic inputs using multiple adaptive distinguishing sequences for checking sequence generation model based testing from input output symbolic transition systems enriched by program calls and contracts graph methods for generating test cases with universal and existential constraints reducing the cost of grammar based testing using pattern coverage automated test design for boundaries of product line variants guiding testersߣ hands in monitoring tools application of testing approaches on sip testing for distinguishing repair candidates in spreadsheets the mussco approach novel insights on cross project fault prediction applied to automotive software inferring finite state machines without reset using state identification sequences a refactoring based mutation testing framework for erlang a survey on testing for cyber physical system test data generation for testing parallel real time systems selective test generation approach for testing dynamic behavioral adaptations heuristics for deriving adaptive homing and distinguishing sequences for nondeterministic finite state machines genetic algorithm application for enhancing state sensitivity partitioning a negative input space complexity metric as selection criterion for fuzz testing and a practical evaluation method of network traffic load for capacity planning hermite orthogonal basis neural network based on improved teaching learning based optimization algorithm for chaotic time series prediction 2015 chinese physical society chaos phenomenon which exists widely in nature and society affects people s production and life it has great important significance to find out the regularity of chaotic time series from a chaotic system since chaotic system has extremely complex dynamic characteristics and unpredictability and chaotic time series prediction through traditional methods has low prediction precision slow convergence speed and complex model structure a prediction model about hermite orthogonal basis neural network based on improved teaching learning based optimization algorithm is proposed firstly according to the chaotic time series autocorrelation method and cao method are used to determine the best delay time and the minimum embedding dimension respectively then a phase space is reconstructed to obtain the refactoring delay time vector secondly on the basis of phase space reconstruction and best square approximation theory combined with the neural network topology a prediction model about hermite orthogonal basis neural network with excitation functions based on the hermite orthogonal basis functions is put forward thirdly in order to optimize the parameters of the prediction model an improved teaching learning based optimization algorithm is proposed where a feedback stage is introduced at the end of the learning stage based on the teaching learning based optimization algorithm finally the parameter optimization problem is transformed into a function optimization problem in the multidimensional space then the improved teaching learning based optimization algorithm is used for parameter optimization of the prediction model so as to establish it and analyze it lorenz and liu chaotic systems are taken as models respectively then the chaotic time series which will be used as simulation object is produced by the fourth order runge kutta method the comparison experiments with other prediction models are conducted on single step and multi step prediction for the chaotic time series the simulation results and numerical analysis show that compared with radial basis function neural network echo state network least square support vector machine prediction model and hermite orthogonal basis neural network based on teaching learning based optimization algorithm the proposed prediction model has the mean absolute error and root mean square error reduced significantly has a decision coefficient close to 1 meanwhile has a mean modeling time shortened greatly so the proposed prediction model can improve the prediction precision accelerate the convergence speed and simplify the model structure thus the prediction model is effective and feasible which makes it promoted and applied easily chaotic time series hermite orthogonal basis neural network improved teaching learning based optimization algorithm prediction checking refactoring using model transformation we propose a method for checking the behavior preservation property of refactoring based on static analysis of source code our method detects difference of program structure using ast based models that are extracted from the source code and transformed according to the refactoring patterns we also built a tool named pom eq that checks c c source code as a result of the case study using the tool we successfully judged the validity of 56 of the refactoring changes that are performed to an industrial product 15th international conference on algorithms and architectures for parallel processing ica3pp 2015 the proceedings contain 52 papers the special focus in this conference is on big data and its applications the topics include preference aware hdfs for hybrid storage urban traffic congestion prediction using floating car trajectory data a metadata cooperative caching architecture based on ssd and dram for file systems parallel training gbrt based on kmeans histogram approximation for big data an intelligent clustering algorithm based on mutual reinforcement an effective method for gender classification with convolutional neural networks a highly efficient indexing and retrieving method for astronomical big data of time series images specialized fpga based accelerator architecture for data intensive k means algorithms effectively identifying hot data in large scale i o streams with enhanced temporal locality a search efficient hybrid storage system for massive text data enhancing parallel data loading for large scale scientific database tradeoff between the price of distributing a database and its collusion resistance based on concatenated codes a mapreduce reinforced distributed sequential pattern mining algorithm a fast documents classification method based on simhash identification of natural images and computer generated graphics using multi fractal differences of prnu enriching document representation with the deviations of word co occurrence frequencies big data analytics and visualization with spatio temporal correlations for traffic accidents a novel app recommendation method based on svd and social influence a segmentation hybrid index structure for temporal data and a refactored content aware host side ssd cache sequential ordering of code smells and usage of heuristic algorithm the process of removing the bad smell results in introduction of new smells due to dependency between the codes in the program this process increases human effort and time automated tools are used for detecting the bad smells in the program this problem is called as ripple effect and we aim in reducing and removing this effect in the program we apply refactoring process for reducing the amount of bad smells in the code since there exist more number of code smells in the program we generate a sequence in which the refactoring has to be applied by which the evolution of new bad smells is enormously decreased the refactoring methods that have to be applied to the source code are also ordered using a heuristic algorithm code smells heuristic algorithm refactoring ripple effect the application of frequency slice wavelet transform in ecg signal feature extraction 2015 binary information press textile bioengineering and informatics society according to the difference of time frequency characteristics of ecg electrocardiogram signal and jamming signal fswt frequency slice wavelet transform is used to deal with the ecg signal denoising and feature extraction fswt algorithm has a good time frequency aggregation and can freely choose the frequency range for signal reconstruction to extract characteristic information flexibly and accurately firstly ecg signal is decomposed to get the whole time frequency distribution characteristic by using fswt and carries on the detailed analysis frequency section interval is determined according to frequency distribution characteristics of the jamming signal disturbance signal is refactored and isolated through the time frequency filter and the inverse transformation of fswt so it can realize the ecg signal denoising and feature extraction the proposed algorithm is compared with wavelet threshold denoising method empirical mode decomposition emd and average empirical mode decomposition aimf the simulation results show that the denoising effect of fswt is superior to other methods for ecg signal and gives the time frequency distribution characteristics of ecg signal ecg signal feature extraction fswt time frequency analysis manual detection of feature envy bad smell in software code research india publications good software is considered to be well design in terms of low coupling and high cohesion but still we are lack in design quality of the software and also it is the important one for development of the software code because lots of difficulties with this because some people may create it some other involved to develop the project in such situation maintenance or development cost is more than production cost for avoiding this code must contain good software design but it is not possible at the time of coding it will be done after software coding refactoring is a methodology to change the software code without any change in the output of the system many refactoring methodologies are available here we propose move method refactoring methodology to remove feature envy bad smell feature envy bad smell is a major design fault when programmers create software by removing this smell we can enhance the design quality so the refactored code will be made easy to develop already lots of plugins and tools are available to perform move method refactoring in this paper we proposed manual step by step manner to identify and understand what is feature envy bad smell how it will affect design quality and how it will be solved based on the famous video rental store application design quality eclipse plug in feature envy bad smell move method refactoring refactoring improving conceptual data models through iterative development 2015 elsevier b v all rights reserved agile methods promote iterative development with short cycles where user feedback from the previous iteration is used to refactor and improve the current version to facilitate agile development of information systems this paper offers three contributions first we introduce the concept of evolvability as a model quality characteristic evolvability refers to the expected implications of future model refactorings both in terms of complexity of the required database evolution algorithm and in terms of the expected volume of data to evolve second we propose extending the agile development cycle by using database profiling information to suggest adaptations to the conceptual model to improve performance for every software release the database profiler identifies and analyses navigational access patterns and proposes model optimisations based on data characteristics access patterns and a cost benefit model based on an experimental evaluation of the profiler we discuss why the quality of conceptual models can generally benefit from profiling and how performance measurements convey semantic information third we discuss the flow of semantic information when developing and using information systems beyond these contributions we also make a case for using object databases in agile development environments however most of the presented concepts are also applicable to other database paradigms agile development conceptual models database profiling evolvability model quality object database semantic verification moving target defense against cross site scripting attacks position paper springer international publishing switzerland 2015 we present a new method to defend against cross site scripting xss attacks our approach is based on mutating symbols in the javascript language and leveraging commonly used load balancing mechanisms to deliver multiple copies of a website using different versions of the javascript language a xss attack that injects unauthorized javascript code can thus be easily detected our solution achieves similar benefits in xss protection as content security policy csp a leading web standard to prevent cross site scripting but can be much more easily adopted because refactoring of websites is not required application security cross site scripting moving target defense web security active control and nonlinear numerical simulation for oscillating pressure of high speed aircraft cavity 2014 aaas press of chinese society of aeronautics and astronautics all right reserved prediction of oscillating pressure is a key technology for the weapon bay of high speed aircraft cavity nonlinear numerical simulation is proposed as a new method to analyze noise recently in order to evaluate the prediction performance of cavity noise nonlinear numerical simulation solver is combined with reynolds averaged navier stokes rans equation firstly the flow field around cavity is solved by rans and the average solution of initial turbulent statistics is obtained which contains the basic characteristics of average flow field and statistics description of turbulence fluctuation after that noise source is refactored and the spreading of pressure fluctuation is simulated precisely by the nonlinear acoustics solution according to the comparison of the cavity noise calculation and experimental results under ma 1 5 and ma 5 it indicates that nonlinear numerical solution is able to well predict cavity flow noise at high speed based on that the contribution to noise suppression made by active control such as adding jet screen at the leading edge of cavity under ma 1 5 and ma 5 is investigated it is found that jet screen is suitable for suppression of oscillating pressure under supersonic condition as well as in hypersonic state active control cavity nonlinear oscillating turbulence performance comparison of query based techniques for anti pattern detection 2015 elsevier b v context program queries play an important role in several software evolution tasks like program comprehension impact analysis or the automated identification of anti patterns for complex refactoring operations a central artifact of these tasks is the reverse engineered program model built up from the source code usually an abstract semantic graph asg which is traditionally post processed by dedicated hand coded queries objective our paper investigates the costs and benefits of using the popular industrial eclipse modeling framework emf as an underlying representation of program models processed by four different general purpose model query techniques based on native java code ocl evaluation and incremental graph pattern matching method we provide in depth comparison of these techniques on the source code of 28 java projects using anti pattern queries taken from refactoring operations in different usage profiles results our results show that general purpose model queries can outperform hand coded queries by 2 3 orders of magnitude with the trade off of an increased in memory consumption and model load time of up to an order of magnitude conclusion the measurement results of usage profiles can be used as guidelines for selecting the appropriate query technologies in concrete scenarios anti patterns columbus emf incquery ocl performance measurements refactoring 15th international conference on algorithms and architectures for parallel processing ica3pp 2015 the proceedings contain 59 papers the special focus in this conference is on applications of parallel and distributed computing the topics include on exploring a virtual agent negotiation inspired approach for route guidance in urban traffic networks optimization of binomial option pricing on intel mic heterogeneous system stencil computations on hpc oriented armv8 64 bit multi core processor a particle swarm optimization algorithm for controller placement problem in software defined network a streaming execution method for multi services in mobile cloud computing economy oriented deadline scheduling policy for render system using iaas cloud towards detailed tissue scale 3d simulations of electrical activity and calcium handling in the human cardiac ventricle task parallel implementation of matrix multiplication on multi socket multi core architectures refactoring for separation of concurrent concerns exploiting scalable parallelism for remote sensing analysis models by data transformation graph resource efficient vibration data collection in cyber physical systems a new approach for vehicle recognition and tracking in multi camera traffic system a scalable distributed fingerprint identification system energy saving and load balancing for sdn based on multi objective particle swarm optimization pre stack kirchhoff time migration on hadoop and spark a cyber physical system with gpu for cnc applications a solution of the controller placement problem in software defined networks parallel column subset selection of kernel matrix for scaling up support vector machines real time deconvolution with gpu and spark for big imaging data analysis and parallel kirchhoff pre stack depth migration on large high performance clusters use of recombinant factor viia utilization among a hospitalized pediatric population 2015 iranian society of pediatrics background recombinant activated factor vii rfviia novoseven rt novo nordisk bagsvaerd denmark is a synthetic pro coagulation factor derived from hamster kidney cells objectives the purpose of this study was to evaluate the prescribing patterns of recombinant factor viia rfviia at a single tertiary care pediatric hospital by indication of usage and dose administered materials and methods retrospective data was queried from the centralized pharmacy medication computer system all patients receiving rfviia between september 2009 and september 2012 were included in the analysis results over the three year period 887 doses of rfviia were administered to 186 patients only 4 of patients received rfviia for an fda approved indication the most common indication for off label usage was refactory bleeding either during or following cardiothoracic surgery accounting for 83 of all doses administered off label despite being only a small portion of all patients receiving rfviia the group receiving rfviia for an fda approved indication received the majority of doses dispensed 72 6 of all doses a significant difference p 0 0001 was noted in the dose administered to patients in the on label versus off label groups patients in the on label group received a median dose of 113 6 mcg kg iqr 54 5 mcg kg 172 7 mcg kg versus a median dose of 74 4 mcg kg iqr 20 0 mcg kg 128 8 mcg kg in the off label group conclusions prospective pediatric studies are needed to evaluate rfviia efficacy and safety in populations receiving the medication for off label indications given increasing concerns involving the potential adverse effect profile of the medication as well as to develop evidence based dosing parameters for these indications blood coagulation factor viia fda 2015 ieee 9th international workshop on software clones iwsc 2015 proceedings the proceedings contain 10 papers the topics discussed include code clone detection using wavelets an execution semantic and content and context based code clone detection and analysis an empirical study of identical function clones in cran on the level of code suggestion for reuse performance impact of lazy deletion in metric trees for incremental clone analysis on the level of code suggestion for reuse source code reuse evaluation by using real potential copy and paste tool support for managing method clones analysis and visualization for clone refactoring what do practitioners ask about code clone a preliminary investigation of stack over and what do we need to know about clones deriving information needs from user goals an empirical study on retrieving structural clones using sequence pattern mining algorithms copyright 2014 acm many clone detection techniques focus on fragments of duplicated code i e simple clones structural clones are simple clones within a syntactic boundary that are good candidates for refactoring in this paper a new approach for detection of structural clones in source code is presented the proposed approach is parse tree based and is enhanced by frequent subsequence mining it comprises three stages preprocessing mining frequent statement sequences and fine matching for structural clones using a modified longest common subsequence lcs algorithm the lengths of control statements in a programming language and method identifiers differ thus a conventional lcs algorithm does not return the expected length of matched identifiers we propose an encoding algorithm for control statements and method identifiers retrieval experiments were conducted using the java swing source code the results show that the proposed data mining algorithm detects clones comprising 51 extracted statements our modified lcs algorithm retrieves a number of structural clones with arbitrary statement gaps control statement frequent subsequence mining java source code method identifier structural clone refdistiller a refactoring aware code review tool for inspecting manual refactoring edits copyright 2014 acm manual refactoring edits are error prone as refactoring requires developers to coordinate related transformations and understand the complex inter relationship between affected types methods and variables we present refdistiller a refactoring aware code review tool that can help developers detect potential behavioral changes in manual refactoring edits it first detects the types and locations of refactoring edits by comparing two program versions based on the reconstructed refactoring information it then detects potential anomalies in refactoring edits using two techniques 1 a template based checker for detecting missing edits and 2 a refactoring separator for detecting extra edits that may change a program s behavior by helping developers be aware of deviations from pure refactoring edits refdistiller can help developers have high confidence about the correctness of manual refactoring edits refdistiller is available as an eclipse plug in at https sites google com site refdistiller and its demonstration video is available at http youtu be 0iseoc5hrpu refactoring software evolution comparing four approaches for technical debt identification 2013 springer science business media new york software systems accumulate technical debt td when short term goals in software development are traded for long term goals e g quick and dirty implementation to reach a release date versus a well refactored implementation that supports the long term health of the project some forms of td accumulate over time in the form of source code that is difficult to work with and exhibits a variety of anomalies a number of source code analysis techniques and tools have been proposed to potentially identify the code level debt accumulated in a system what has not yet been studied is if using multiple tools to detect td can lead to benefits that is if different tools will flag the same or different source code components further these techniques also lack investigation into the symptoms of td interest that they lead to to address this latter question we also investigated whether td as identified by the source code analysis techniques correlates with interest payments in the form of increased defect and change proneness comparing the results of different td identification approaches to understand their commonalities and differences and to evaluate their relationship to indicators of future td interest we selected four different td identification techniques code smells automatic static analysis issues grime buildup and modularity violations and applied them to 13 versions of the apache hadoop open source software project we collected and aggregated statistical measures to investigate whether the different techniques identified td indicators in the same or different classes and whether those classes in turn exhibited high interest in the form of a large number of defects and higher change proneness the outputs of the four approaches have very little overlap and are therefore pointing to different problems in the source code dispersed coupling and modularity violations were co located in classes with higher defect proneness we also observed a strong relationship between modularity violations and change proneness our main contribution is an initial overview of the td landscape showing that different td techniques are loosely coupled and therefore indicate problems in different locations of the source code moreover our proxy interest indicators change and defect proneness correlate with only a small subset of td indicators asa code smells grime modularity violations software maintenance software quality source code analysis technical debt an empirical study of refactoring challenges and benefits at microsoft it is widely believed that refactoring improves software quality and developer productivity however few empirical studies quantitatively assess refactoring benefits or investigate developers perception towards these benefits this paper presents a field study of refactoring benefits and challenges at microsoft through three complementary study methods a survey semi structured interviews with professional software engineers and quantitative analysis of version history data our survey finds that the refactoring definition in practice is not confined to a rigorous definition of semantics preserving code transformations and that developers perceive that refactoring involves substantial cost and risks we also report on interviews with a designated refactoring team that has led a multi year centralized effort on refactoring windows the quantitative analysis of windows 7 version history finds the top 5 percent of preferentially refactored modules experience higher reduction in the number of inter module dependencies and several complexity measures but increase size more than the bottom 95 percent this indicates that measuring the impact of refactoring requires multi dimensional assessment 1976 2012 ieee churn component dependencies defects empirical study refactoring software evolution a decision support system approach to economics driven modularity evaluation 2014 elsevier inc all rights reserved modularity debt is the most difficult kind of technical debt to quantify and manage modularity decay thus modularity debt causes huge losses over time in terms of reduced ability to provide new functionality and fix bugs operational failures and even canceled projects as modularity debt accumulates over time software system managers are often faced with a challenging task of deciding when and whether to refactor for example choosing to improve modularity or not while the costs of refactoring are significant and immediate their benefits are largely invisible intangible and long term existing research lacks effective methods to quantify the costs and benefits of refactoring to support refactoring decision making in this chapter we present a decision support system dss approach to the modularity debt management using such a system managers would be able to play out various what if scenarios to make informed decisions regarding refactoring our dss approach is built on a scientific foundation for explicitly manifesting the economic implications of software refactoring activities so that the costs and benefits of such activities can be understood analyzed and predicted we discuss our contributions and current progress in developing the building blocks and the underpinning framework an integrated economics driven modularization evaluation framework for the modularity debt management decision support system mdm dss complexity metrics effort measures real options refactoring software architecture software modularity technical debt a new metric for predicting software change using gene expression programming copyright 2014 acm software metrics help in determining the quality of a software product they can be used for continuous inspection of a software to assist software developers in improving its quality we can also use metrics to develop quality models which predict important quality attributes like change proneness determination of change prone classes in an object oriented software will help software developers to focus their time and resources on the weak portions of the software in this paper we validate the chidamber and kemerer metric suite for building an efficient software quality model which predict change prone classes with the help of gene expression programming the model is developed using an open source software we further propose a new metric which can be used for identifying change prone classes in the early phases of software development life cycle the proposed metric is validated on another open source software and the results show that it can be effectively used by the software industry to classify change prone classes identification of change prone classes may help in efficient refactoring and rigorous testing of these classes in the forthcoming releases of the software product change proneness empirical validation gene expression programming object oriented metrics software quality alternate refactoring paths reveal usability problems 2014 acm modern integrated development environments ides support many refactorings yet programmers greatly underuse automated refactorings recent studies have applied traditional usability testing methodologies such as surveys lab studies and interviews to find the usability problems of refactoring tools however these methodologies can identify only certain kinds of usability problems the critical incident technique cit is a general methodology that uncovers usability problems by analyzing troubling user interactions we adapt cit to refactoring tools and show that alternate refactoring paths are indicators of the usability problems of refactoring tools we define an alternate refactoring path as a sequence of user interactions that contains cancellations reported messages or repeated invocations of the refactoring tool we evaluated our method on a large corpus of refactoring usage data which we collected during a field study on 36 programmers over three months this method revealed 15 usability problems 13 of which were previously unknown we reported these problems and proposed design improvements to eclipse developers the developers acknowledged all of the problems and have already fixed four of them this result suggests that analyzing alternate paths is effective at discovering the usability problems of interactive program transformation ipt tools critical incident empirical evaluation refactoring usability introduction to this special issue on understanding design thinking the special issue of the 2014 journal of human computer interaction presents articles on understanding design thinking bauer newman and kientz report on interviews with designers of context aware systems finding that shifts in both types of context transform prototyping practices and the authors use these data to refactor the developer designer relationship snyder and colleagues provide three case studies illustrating the use of visual narratives in the design process miller bailey and kirlik introduce a peer assessment scheme that increases reliability by asking student raters to estimate the distribution of their peers responses their article shows the application of their truth serum approach in a design class kim and ryu s article also looks at assessment but focuses on the ideation aspect of the design process they explore differences between the way professional designers and design students evaluate and revise design ideas as they create them investigating the evolution of code smells in object oriented systems software design problems are known and perceived under many different terms such as code smells flaws non compliance to design principles violation of heuristics excessive metric values and anti patterns signifying the importance of handling them in the construction and maintenance of software once a design problem is identified it can be removed by applying an appropriate refactoring improving in most cases several aspects of quality such as maintainability comprehensibility and reusability this paper taking advantage of recent advances and tools in the identification of non trivial code smells explores the presence and evolution of such problems by analyzing past versions of code several interesting questions can be investigated such as whether the number of problems increases with the passage of software generations whether problems vanish by time or only by targeted human intervention whether code smells occur in the course of evolution of a module or exist right from the beginning and whether refactorings targeting at smell removal are frequent in contrast to previous studies that investigate the application of refactorings in the history of a software project we attempt to analyze the evolution from the point of view of the problems themselves to this end we classify smell evolution patterns distinguishing deliberate maintenance activities from the removal of design problems as a side effect of software evolution results are discussed for two open source systems and four code smells 2013 springer verlag london code smell evolution refactoring software history software repositories towards a refactoring catalogue for knowledge discovery metamodel 2014 ieee refactorings are a well known technique that assist developers in reformulating the overall structure of applications aiming to improve internal quality attributes while preserving their original behavior one of the most conventional uses of refactorings are in reengineering processes whose goal is to change the structure of legacy systems aiming to solve previously identified structural problems architecture driven modernization adm is the new generation of reengineering processes relying just on models rather than source code as the main artifacts along the process however although adm provides the general concepts for conducting model driven modernizations it does not provide instructions on how to create or apply refactorings in the knowledge discovery metamodel kdm metamodel this leads developers to create their own refactoring solutions which are very hard to be reused in other contexts one of the most well known and useful refactoring catalogue is the fowler s one but it was primarily proposed for source code level in order to fill this gap in this paper we present a model oriented version of the fowler s catalogue so that it can be applied to kdm metamodel in this paper we have focused on four categories of refactorings j renaming w moving features between objects iii organizing data and iv dealing with generalization we have also developed an environment to support the application of our catalogue to evaluate our solution we conducted an experiment using eight open source java application the results showed that our catalogue can be used to improve the cohesion and coupling of the legacy system adm empirical study kdm refactoring how changes affect software entropy an empirical study context software systems continuously change for various reasons such as adding new features fixing bugs or refactoring changes may either increase the source code complexity and disorganization or help to reducing it aim this paper empirically investigates the relationship of source code complexity and disorganization measured using source code change entropy with four factors namely the presence of refactoring activities the number of developers working on a source code file the participation of classes in design patterns and the different kinds of changes occurring on the system classified in terms of their topics extracted from commit notes method we carried out an exploratory study on an interval of the life time span of four open source systems namely argouml eclipse jdt mozilla and samba with the aim of analyzing the relationship between the source code change entropy and four factors refactoring activities number of contributors for a file participation of classes in design patterns and change topics results the study shows that i the change entropy decreases after refactoring ii files changed by a higher number of developers tend to exhibit a higher change entropy than others iii classes participating in certain design patterns exhibit a higher change entropy than others and iv changes related to different topics exhibit different change entropy for example bug fixings exhibit a limited change entropy while changes introducing new features exhibit a high change entropy conclusions results provided in this paper indicate that the nature of changes in particular changes related to refactorings the software design and the number of active developers are factors related to change entropy our findings contribute to understand the software aging phenomenon and are preliminary to identifying better ways to contrast it 2012 springer science business media llc mining software repositories software complexity software entropy steps towards the synthetic biology of polyketide biosynthesis nature is providing a bountiful pool of valuable secondary metabolites many of which possess therapeutic properties however the discovery of new bioactive secondary metabolites is slowing down at a time when the rise of multidrug resistant pathogens and the realization of acute and long term side effects of widely used drugs lead to an urgent need for new therapeutic agents approaches such as synthetic biology are promising to deliver a much needed boost to secondary metabolite drug development through plug and play optimized hosts and refactoring novel or cryptic bacterial gene clusters here we discuss this prospect focusing on one comprehensively studied class of clinically relevant bioactive molecules the polyketides extensive efforts towards optimization and derivatization of compounds via combinatorial biosynthesis and classical engineering have elucidated the modularity flexibility and promiscuity of polyketide biosynthetic enzymes hence a synthetic biology approach can build upon a solid basis of guidelines and principles while providing a new perspective towards the discovery and generation of novel and new to nature compounds we discuss the lessons learned from the classical engineering of polyketide synthases and indicate their importance when attempting to engineer biosynthetic pathways using synthetic biology approaches for the introduction of novelty and overexpression of products in a controllable manner 2013 the authors fems microbiology letters published by john wiley sons ltd on behalf of federation of european microbiological societies combinatorial biosynthesis drug discovery plug and play biology refactoring secondary metabolites bad smells in software product lines a systematic review 2014 ieee software product line spl is a set of software systems that share a common managed set of features satisfying the specific needs of a particular market segment bad smells are symptoms that something may be wrong in system design bad smells in spl are a relative new topic and need to be explored this paper performed a systematic literature review slr to find and classify published work about bad smells in spls and their respective refactoring methods based on 18 relevant papers found in the slr we identified 70 bad smells and 95 refactoring methods related to them the main contribution of this paper is a catalogue of bad smells and refactoring methods related to spl bad smells refactoring software product lines making refactoring safer through impact analysis currently most developers have to apply manual steps and use test suites to improve confidence that transformations applied to object oriented oo and aspect oriented ao programs are correct however it is not simple to do manual reasoning due to the nontrivial semantics of oo and ao languages moreover most refactoring implementations contain a number of bugs since it is difficult to establish all conditions required for a transformation to be behavior preserving in this article we propose a tool saferefactorimpact that analyzes the transformation and generates tests only for the methods impacted by a transformation identified by our change impact analyzer safira we compare saferefactorimpact with our previous tool saferefactor with respect to correctness performance number of methods passed to the automatic test suite generator change coverage and number of relevant tests generated in 45 transformations saferefactorimpact identifies behavioral changes undetected by saferefactor moreover it reduces the number of methods passed to the test suite generator finally saferefactorimpact has a better change coverage in larger subjects and generates more relevant tests than saferefactor 2013 elsevier b v all rights reserved change impact analysis refactoring reengineering of object oriented software into aspect oriented ones supported by class models springer international publishing switzerland 2014 object oriented software reengineering oo into aspect oriented software ao is a challenging task mainly when it is done by means of refactorings in the code level the reason is that direct transformation from oo code to ao one needs of several design decisions due to differences of both paradigms to make this transformation more controlled and systematic we propose the use of concern based refactorings supported by class models it allows design decisions to be made during the reengineering process improving the quality of the final models an example is presented to assess the applicability of the proposed refactorings moreover we also present a case study in which ao class models created based on the refactorings are compared with another obtained without the aid of them the data obtained indicated that the use of the proposed refactorings improved the efficacy and productivity of maintenance groups during the process of software reengineering aspect orientation class models concern based refactorings reengineering a graph mining approach for detecting identical design structures in object oriented design models 2013 elsevier b v all rights reserved the object oriented approach has been the most popular software design methodology for the past twenty five years several design patterns and principles are defined to improve the design quality of object oriented software systems in addition designers can use unique design motifs that are designed for the specific application domains another commonly used technique is cloning and modifying some parts of the software while creating new modules therefore object oriented programs can include many identical design structures this work proposes a sub graph mining based approach for detecting identical design structures in object oriented systems by identifying and analyzing these structures we can obtain useful information about the design such as commonly used design patterns most frequent design defects domain specific patterns and reused design clones which could help developers to improve their knowledge about the software architecture furthermore problematic parts of frequent identical design structures are appropriate refactoring opportunities because they affect multiple areas of the architecture experiments with several open source and industrial projects show that we can successfully find many identical design structures within a project intra project and between different projects inter project we observe that usually most of the detected identical structures are an implementation of common design patterns however we also detect various anti patterns domain specific patterns reused design parts and design level clones graph mining identical design structures pattern extraction software design models software motifs detection of software anomalies using object oriented metrics the development of quality software has always been the aim of many studies in past years in which the focus was on seeking for better software production with high effectiveness and quality in order to evaluate software quality software metrics were proposed providing an effective tool to analyze important features such as maintainability reusability and testability the chidamber and kemerer metrics ck metrics are frequently applied to analyze object oriented programming oop features related to structure inheritance and message calls the main purpose of this article is to gather results from studies that used the ck metrics for source code evaluation and based on the ck metrics perform a review related to software metrics and the values obtained results on the mean and standard deviation obtained in all the studied papers is presented both for java and c projects therefore software anomalies are identified comparing the results of software metrics described in those studies this article contributes by suggesting values for software metrics that according to the literature can present high probabilities of failures another contribution is to analyze which ck metrics are successfully used or not in some activities such as to predict proneness error analyze the impact of refactoring on metrics and examine the facility of white box reuse based on metrics we discovered that in most of the studied articles cbo rfc and wmc are often useful and hierarchical metrics as dit and noc are not useful in the implementation of such activities the results of this paper can be used to guide software development helping to manage the development and preventing future problems copyright 2014 scitepress science and technology publications ck metrics error proneness object oriented programming software anomalies software metrics proceedings of the conference on object oriented programming systems languages and applications oopsla the proceedings contain 52 papers the topics discussed include checking correctness of typescript interfaces for javascript libraries determinacy in static analysis for jquery eventbreak analyzing the responsiveness of user interfaces through performance guided test generation tardis affordable time travel debugging in managed runtimes phosphor illuminating dynamic data flow in commodity jvms rubah dsu for java on a stock jvm fast conservative garbage collection region based memory management for gpu programming languages enabling rich data structures on a spartan host streamjit a commensal compiler for high performance stream programming surveyman programming and automatically debugging surveys refactoring java generics by inferring wildcards in practice continuously measuring critical section pressure with the free lunch profiler understanding energy behaviors of thread management constructs and distributed rescala an update algorithm for distributed reactive programming estrangement between classes test coverage based assessment of coupling strength between pairs of classes 2014 ieee this work discusses a new metric estrangement between classes ebc that is derived by executing tests this metric is based on the statement coverage of tests and provides assessment of the strength of associations between classes we demonstrate with an illustrative example of the popular apache email component that this new metric can provide additional information in reverse engineered class diagrams by highlighting missing associations in these diagrams the strength of existing associations and utility classes it can also be effective in indicating the important design elements in cases of over engineered or dead code the proposed metric can be potentially used in the context of agile methods of software development during refactoring and program maintenance as comprehension aid since ebc is based on tests no additional effort is required by developers who follow the test driven approach or generally develop tests agile methods coupling metrics dynamic metrics software design test coverage uml automating extract class refactoring an improved method and its evaluation 2013 springer science business media new york during software evolution the internal structure of the system undergoes continuous modifications these continuous changes push away the source code from its original design often reducing its quality including class cohesion in this paper we propose a method for automating the extract class refactoring the proposed approach analyzes structural and semantic relationships between the methods in a class to identify chains of strongly related methods the identified method chains are used to define new classes with higher cohesion than the original class while preserving the overall coupling between the new classes and the classes interacting with the original class the proposed approach has been first assessed in an artificial scenario in order to calibrate the parameters of the approach the data was also used to compare the new approach with previous work then it has been empirically evaluated on real blobs from existing open source systems in order to assess how good and useful the proposed refactoring solutions are consi dered by software engineers and how well the proposed refactorings approximate refactorings done by the original developers we found that the new approach outperforms a previously proposed approach and that developers find the proposed solutions useful in guiding refactorings cohesion coupling extract class refactoring graph clustering algorithms identifying extract class refactoring opportunities for internetware the quality of internetware software is significantly associated with class structure as software evolves changes often introduce many unrelated responsibilities to the same classes or distribute tightly related methods in different classes these changes make the classes difficult to understand and maintain extract class refactoring is an effective technique to improve the quality of software structure by decomposing unrelated methods in one class to create new classes or extracting tightly related methods from different classes in this paper we propose a novel approach for class extraction from internetware source codes this approach leverages a community structure detection technique to partition software into clusters and extracts classes from the resulting clusters our experimental results which investigate the public well known internetware pkuas indicate that 1 the proposed approach is much faster than existing search based clustering approaches hillclimbing and genetic algorithm and is thus applicable for large scale internetware 2 the proposed approach can identify meaningful class extractions for internetware and 3 extract class refactoring candidates identified by the proposed approach significantly improve class cohesion of internetware 2014 science china press and springer verlag berlin heidelberg community structure extract class internetware refactoring software modularity esa the exclusive similarity algorithm for identifying extract class refactoring candidates automatically refactoring has become an essential part of software development process especially for large and long lasting projects extract class is one of the vital refactorings that is used to improve cohesion of a class by splitting large in cohesive classes into more cohesive ones providing automated means of identifying opportunities for extract class refactoring could make the software maintenance effecient in this paper a novel algorithm viz esa exclusive similarity algorithm is proposed to identify extract class refactoring candidates automatically the algorithm proposes new metrics viz exclusive similarity metric esm cohesion among method clusters cmc and method similarity with attribute clusters msac the proposed algorithm has been realized into a tool as an add in to visual studio and the tool is exercised with 3 open source projects to demonstrate applicability copyright 2014 acm esa exclusive similarity algorithm extract class refactoring refactoring candidate identi cation scout in medio stat virtus extract class refactoring through nash equilibria extract class refactoring ecr is used to divide large classes with low cohesion into smaller more cohesive classes however splitting a class might result in increased coupling in the system due to new dependencies between the extracted classes thus ecr requires that a software engineer identifies a trade off between cohesion and coupling such a trade off may be difficult to identify manually because of the high complexity of the class to be refactored in this paper we present an approach based on game theory to identify refactoring solutions that provide a compromise between the desired increment in cohesion and the undesired increment in coupling the results of an empirical evaluation indicate that the approach identifies meaningful ecrs from a developer s point of view 2014 ieee design quality game theory refactoring are the methods in your data access objects daos in the right place a preliminary study 2014 ieee isolating code that deals with system infrastructure from code that deals with domain rules is a good practice when developing applications code that deals with the database for example is often isolated in classes following a data access object dao pattern developers often create a dao for each domain entity in the system however as some pieces of code deal with more than one entity table developers need to decide in which dao they will place the code and sometimes choose a less intuitive location in this paper we present a heuristic to identify methods that may have been written in an ambiguous place to validate the idea we tested it on three industrial projects from a brazilian company the heuristic selected on average 13 to 18 of the methods in daos after evaluating such methods we concluded that the heuristic was correct in 50 to 75 of cases therefore we believe that the heuristic can indicate possible technical debt where the developers may inspect and possibly refactor data access objects mining software repositories analyzing the harmful effect of god class refactoring on power consumption energy efficiency and other sustainability issues are common concerns in the material production industries but rarely addressed in software development efforts instead traditional software development life cycles and methodologies place an emphasis on maintainability and other intrinsic software quality features one standard practice is to improve maintainability by detecting bad smells in a system s architecture and then applying refactoring transformations to deal with those smells the refactoring research area is sufficiently mature for most techniques to achieve more maintainable system architectures but the authors argue that they can also lead to both decreased sustainability and increased power consumption accordingly this article analyzes the relationship between architecture sustainability and maintainability by providing empirical evidence of how power consumption increases after refactoring 1984 2012 ieee architecture sustainability green software maintainability power consumption refactoring agile methods large scale development refactoring testing and estimation xp 2014 international workshops rome italy may 26 30 2014 revised selected papers methodbook recommending move method refactorings via relational topic models during software maintenance and evolution the internal structure of the software system undergoes continuous changes these modifications drift the source code away from its original design thus deteriorating its quality including cohesion and coupling of classes several refactoring methods have been proposed to overcome this problem in this paper we propose a novel technique to identify move method refactoring opportunities and remove the feature envy bad smell from source code our approach coined as methodbook is based on relational topic models rtm a probabilistic technique for representing and modeling topics documents in our case methods and known relationships among these methodbook uses rtm to analyze both structural and textual information gleaned from software to better support move method refactoring we evaluated methodbook in two case studies the first study has been executed on six software systems to analyze if the move method operations suggested by methodbook help to improve the design quality of the systems as captured by quality metrics the second study has been conducted with eighty developers that evaluated the refactoring recommendations produced by methodbook the achieved results indicate that methodbook provides accurate and meaningful recommendations for move method refactoring operations 1976 2012 ieee empirical studies refactoring relational topic models an efficient method for assessing the impact of refactoring candidates on maintainability based on matrix computation 2014 ieee for automating refactoring identification previous methods for assessing the impact of a large number of refactoring candidates may be computationally expensive in our paper we propose an efficient method for assessing the impact of refactoring candidates on maintainability based on matrix computation which is approximate but fast this proposed method is evaluated on a refactoring identification approach for jedit and columba two large scale open source projects the experiments show that the proposed method requires less time for assessing refactoring candidates and that the refactoring identification approach using our proposed method also improves maintainability maintainability improvement refactoring effect assessment method refactoring identification process recommending automated extract method refactorings copyright 2014 acm extract method is a key refactoring for improving program comprehension however recent empirical research shows that refactoring tools designed to automate extract methods are often underused to tackle this issue we propose a novel approach to identify and rank extract method refactoring opportunities that are directly automated by ide based refactoring tools our approach aims to recommend new methods that hide structural dependencies that are rarely used by the remaining statements in the original method we conducted an exploratory study to experiment and define the best strategies to compute the dependencies and the similarity measures used by the proposed approach we also evaluated our approach in a sample of 81 extract method opportunities generated for junit and jhotdraw achieving a precision of 48 junit and 38 jhotdraw extract method program comprehension supporting tools refactoring self documenting methods method level code clone modification environment using clonemanager springer international publishing switzerland 2014 the primary objective of code clone research is to provide techniques and tools through which the topics such as clone detection and clone management a number of techniques have been proposed for clone detections and sure to have even more detectors in future some limited methods have been proposed for clone modifications a technique that helps for clone modification is refactoring but this is not possible for all the clones as there are clones which cannot be modified moreover some of the clones have to exist to maintain the consistency of the problem most of the programmers modify the clone and need to make the modification throughout all the identical clones we propose a method which provide a modification environment of the clones for the programmer we use the clone detection tool clonemanager we embedded this feature as an enhancement of the clone detection tool clonemanager clone detection refactoring software clones software metrics a cross simulation method for large scale traffic evacuation with big data springer international publishing switzerland 2014 microscopic traffic simulation is one of the effective tools for transportation forecast and decision support it is a challenge task to make reasonable prediction of traffic scenarios during emergency big data technology provides a new solution for this issue this paper proposes a cross simulation method to apply the mass data collected in normal situations into large scale traffic evacuations to provide better supporting information for emergency decision the method consists of three processes acquisition analysis and adaptation it captures the dynamic distance speed relation of every vehicles on the real roads and build a database of driving behaviors according to the existing car following models after calibration and analysis various driving behaviors can be identified during emergency the distribution of driving behaviors will be refactored to adapt the fast changing situation automatically so that the simulation system gains the adaptive ability in emergency situations an experimental result on a real road preliminarily validates the practicability of the method and shows the supporting information which it can provide the new method will make contributions on enhancing the predictive ability of traffic simulation systems in emergency situations big data cross simulation large scale evacuation transportation system a method for detecting bad smells and its application to software engineering education 2014 ieee in order to extend and maintenance software systems it is necessary to remove factors behind bad smells from source code through refactoring however it is time consuming process to detect and remove factors behind bad smells manually from large source code and learning how to refactor bad smells can be difficult for students because they are not yet software development experts therefore we propose a method for detecting bad smells using declarative meta programming that can be applied to software development training in this manner software development training is facilitated declarative meta programming detectiong bad smells program refactorings software engineering education recode software package refactoring via community detection in bipartite software networks 2014 world scientific publishing company it is an intrinsic property of real world software to evolve which is usually accompanied by the increase of software complexity and deterioration of software quality so successful software has to be reconditioned from time to time though many refactoring approaches have been proposed only a few of them are performed at the package level in this paper we present a novel approach to refactor the package structure of object oriented oo software it uses weighted bipartite software networks to represent classes packages and their dependencies it proposes a guidance community detection algorithm guida to obtain the optimized package structure and it finally provides a list of classes as refactoring candidates by comparing the optimized package structure with the real package structure through a set of experiments we have shown that the proposed approach is able to identify a majority of classes that experts recognize as refactoring candidates and the benefits of our approach are illustrated in comparison with other two approaches community detection complex network object oriented design package refactoring software network feasibility study of aspect mining at requirement level modularity is categorized as quality characteristic which can increase the maintainability of a software program although modularity is gaining popularity yet it is hard to be realized since there are many crosscutting concerns scattered and tangled in object oriented programs thus more efforts are needed to maintain the software program which uses object oriented approach on the other hand aspect oriented approach has been viewed as it can encourage modularization since majority of the existing application is using object oriented approach restructuring process known as refactoring become essential in increasing the program modularity refactoring means the process of restructuring the internal section without changing the system behaviour even though refactoring becomes the solution for this yet it does not seem to increase the modularity of a software program this is due to lack of a comprehensive aspect mining method which helps in extracting the crosscutting concern from the existing applications before the refactoring takes place at the present time software practitioner preferred to conduct aspect mining at coding level which resulted in incomplete crosscutting concern extraction since the requirement stage being the initial stage before coding it is believed to have the ability to extract more crosscutting concerns thus it creates a space for aspect mining at requirement level as an alternative to aspect mining at coding level in that case the feasibility of aspect mining at requirement level becomes a need this study aims to demonstrate the opportunity of conducting aspect mining at requirement level interview conducted among the certified professional requirement engineers cpre has revealed that aspect mining at the requirement level is feasible and needed the result of this study represented in swot analysis matrix is useful in justifying the alternative method of aspect mining this alternative analysis also highlighted on the frequency of crosscutting concern that used among the cpre indicating the worthiness of aspect mining at the requirement level aspect mining feasibility study refactoring revealing purity and side effects on functions for reusing java libraries springer international publishing switzerland 2014 reuse of software components requires the comprehension of the behavior and possible side effects among apis of program components meanwhile identifying problematic usage of these components is difficult with conventional static analysis purity and side effects are important properties of methods that often are neglected by the documentations of the object oriented languages such as java in this paper we studied these properties by using a static analysis technique to automatically infer the state dependencies for the return value and side effects of methods as a result the effect information reveals purity of methods as well as well defined state interactions between objects we have implemented the analyzer targeting java bytecode and tested it on some open source java software libraries with different scale and characteristic from our experimental results we found that 24 44 of the methods in the evaluated open source java libraries are pure which indicates that a large percentage of the methods are suitable for high level refactoring our study can help programmers to understand and reuse these libraries design by contract object oriented pure function state boundary state dependency static analysis the data parallelism under java paralleltask a simple and efficient approach 2014 ieee with the advent of multicore general public systems a new perspective of parallel processing is available to application developers adapting old sequential applications to performance of parallel systems proves imperative the task parallel java compiler paratask is a solution for the development of object oriented parallel applications based on the concept of different types of tasks it is easily exploitable for the change refactoring of existing sequential applications by using simple keywords parallelism is introduced either in the form of parallel data and parallel task or as a mixed parallel data tasks it comes to performed in this work the parallelization of the sequential algorithm of canny contour detection on images of different sizes cyclic data data blocks multicore parallel paratask refactoring toward a new aspect mining approach for multi agent systems 2014 elsevier inc all rights reserved many aspect mining techniques have been proposed for object oriented systems unfortunately aspect mining for multi agent systems is an unexplored research area the inherent specificities of multi agent systems such as autonomy pro activity reactivity and adaptability make it difficult to understand reuse and maintain their code we propose in this paper a semi automatic hybrid aspect mining approach for agent oriented code the technique is based on both static and dynamic analyzes the main motivations of this work are 1 identifying cross cutting concerns in existing agent oriented code and 2 making them explicitly available to software engineers involved in the evolution of agent oriented code in order to facilitate its refactoring and consequently to improve its understandability reusability and maintainability the proposed approach is supported by a software tool called mamit mas aspect mining tool that we developed the approach and the associated tool are illustrated using a concrete case study multi agent systems aspect mining aspect oriented programming proceedings 2014 14th ieee international working conference on source code analysis and manipulation scam 2014 the proceedings contain 35 papers the topics discussed include effect of clone information on the performance of developers fixing cloned bugs a comparative study of bug patterns in java cloned and non cloned code a change type based empirical study on the stability of cloned code toolset and program repository for code coverage based test suite analysis and manipulation the ekeko x program transformation tool flowgen flowchart based documentation framework for c pesto a tool for migrating dom based to visual web tests pangea a workbench for statically analyzing multi language software corpora source meter sonar qube plug in total ads automated software anomaly detection system bulk fixing coding issues and its effects on software quality is it worth refactoring instrumentation of annotated c programs for test generation and impact of code refactoring using object oriented methodology on a scientific computing application distance metric based divergent change bad smell detection and refactoring scheme analysis bad smells are signs of potential problems in codes bad smells decrease the design quality of software so the codes are hard to analyze understand test or reuse divergent change is a common and classical bad smell in object oriented programs the detection of this bad smell is difficult because the features of divergent change are not obvious and the detecting and refactoring of this bad smell are on the later steps of software life cycle in this paper the detection method of divergent change bad smell based on distance metric and k nearest neighbor clustering technology is proposed the features of divergent change are analyzed and transformed to distances between enti ties divergent change bad smells are detected with the results of k nearest neighbor clustering and targeted refactoring schemes are provided after comparisons with sim ilar researches the experiments results on open source programs show that the proposed method behaves well on refactoring evaluation with low time complexity 2014 icic international bad smell detection entity distance k nearest neighbor clustering refactoring scheme a platform specific code smell alert system for high performance computing applications 2014 ieee a code smell is any part of an application code that might indicate a code or design problem which makes the application code hard to evolve and maintain automatic detection of code smells has been studied to help programmers find which parts of their application codes should be refactored however code smells have not been defined in a formal manner moreover existing detection tools are designed for object oriented applications but rarely provided for high performance computing hpc applications hpc applications are usually optimized for a particular platform to achieve a high performance and hence have special code smells called platform specific code smells pscss the purpose of this work is to develop a code smell alert system to help programmers find pscss of hpc applications to improve the performance portability across different platforms this paper presents a pscs alert system that is based on an abstract syntax tree ast and xml code patterns of pscss are defined in a formal way using the ast information represented in xml xml path language xpath is used to describe those patterns the evaluation results obtained by using real applications show that the proposed system can alert potential pscss to programmers ast code smell detection hpc xml representation recovering test to code traceability using slicing and textual analysis test suites are a valuable source of up to date documentation as developers continuously modify them to reflect changes in the production code and preserve an effective regression suite while maintaining traceability links between unit test and the classes under test can be useful to selectively retest code after a change the value of having traceability links goes far beyond this potential savings one key use is to help developers better comprehend the dependencies between tests and classes and help maintain consistency during refactoring despite its importance test to code traceability is not common in software development and when needed traceability information has to be recovered during software development and evolution we propose an advanced approach named scotch source code and concept based test to code traceability hunter to support the developer during the identification of links between unit tests and tested classes given a test class represented by a junit class the approach first exploits dynamic slicing to identify a set of candidate tested classes then external and internal textual information associated with the classes retrieved by slicing is analyzed to refine this set of classes and identify the final set of candidate tested classes the external information is derived from the analysis of the class name while internal information is derived from identifiers and comments the approach is evaluated on five software systems the results indicate that the accuracy of the proposed approach far exceeds the leading techniques found in the literature 2013 elsevier inc all rights reserved dynamic slicing information retrieval test to code traceability two level dynamic approach for feature envy detection 2014 ieee refactoring leads to more maintainable software to refactor the code it must be known which part of code needs to be refactored for this purpose code smells are used detecting code smells in itself is a challenging task in this paper we propose a technique based on dynamic analysis for the detection of feature envy code smell feature envy is a method level smell and occurs when a method is more interested in another class than its own class previous approaches detects feature envy by analyzing each method in the system which incurs an overhead as those methods which are closely bounded to their classes are included in the detection mechanism to tackle this problem we have devised a two level mechanism first level filters out the methods which are suspects of being feature envious and second level analyzes those suspects to identify the actual culprits the proposed technique has been evaluated and compared with existing techniques code smell dynamic analysis object oriented programming software maintenance a comparative study of bug patterns in java cloned and non cloned code 2014 ieee code cloning via copy and paste is a common practice in software engineering traditionally this practice has been considered harmful and a symptom that some important design abstraction is being ignored as such many previous studies suggest approaches to facilitate the discovery removal and refactoring of clones however not many studies exist that empirically investigate the relationship of code clones with code quality in this paper we conduct an empirical study of 31 open source java projects 1 7 msloc to explore the relationship between code clones and a set of bug patterns reported by find bugs we found that i the defect density in cloned code is 3 7 times less than that of the rest of the code ii 66 of the bug patterns associated with code clones are related to issues in coding style and practice the two least problematic of the find bugs categories while that number is 49 for non cloned code and iii 75 of the bug patterns in cloned code are duplicated without any changes while 25 are only present in one of the clones these results show that when using find bugs to detect bug patterns there is a positive differentiation of cloned code with respect to the rest of the code the cloned code has considerably less and less problematic bug patterns while our study does not unveil any explanation for this results from other more qualitative studies indicate that developers use copy and paste intentionally and wisely which may explain the quantitative observations of our study overall these research results suggest that the practice of code cloning in java and possibly in all other object oriented languages needs to be given serious consideration on the part of tool designers bug patterns code clones code quality distribution rule based bad smell detection and refactoring scheme bad smells are signs of potential problems in code which may reduce the design quality of software detecting bad smells however remains time consuming for software engineers despite proposals on bad smell detection and refactoring tools large class is a kind of bad smells whose specific characteristics are hard to determine and the detection are hard to achieve automatically in this paper a large class bad smell detection approach based on class length distribution model and cohesion metrics is proposed in programs the lengths of classes are confirmed according to the certain distributions the class length distribution model is generalized to detect programs after grouping meanwhile cohesion metrics are analyzed for bad smell detection the bad smell detection experiments of open source programs show that large class bad smell can be detected effectively and accurately with this approach and refactoring scheme can be proposed for design quality improvements of programs 2014 binary information press bad smell detection class length distribution model cohesion metrics distribution rule refactoring scheme detecting deadlock in programs with data centric synchronization gessellschaft für informatik bonn 2014 writing concurrent programs that operate on shared memory is error prone as it requires reasoning about the possible interleavings of threads that access shared locations if programmers make mistakes two kinds of software faults may occur data races and atomicity violations may arise when shared locations are not consistently protected by locks deadlock may occur as the result of undisciplined lock acquisition preventing an application from making progress previously vtd06 vtd 10 dhm 12 we proposed a data centric approach to synchronization to raise the level of abstraction in concurrent object oriented programming and prevent concurrency related errors with data centric synchronization fields of classes are grouped into atomic sets each atomic set has associated units of work code fragments that preserve the consistency of their atomic sets our compiler inserts synchronization that is sufficient to guarantee that for each atomic set the associated units of work are serializable hdvt08 thus preventing data races and atomicity violations by construction our previous work reported on the implementation of atomic sets as an extension of java called aj we demonstrated that atomic sets enjoy low annotation overhead and that realistic java programs can be refactored into a j without significant loss of performance dhm 12 however our previous work did not address the problem of deadlock which may arise in aj when two threads attempt to execute the units of work associated with different atomic sets in different orders this talk presents a static analysis for detecting possible deadlock in aj programs the analysis is a variation on existing deadlock prevention strategies mas93 ea03 that impose a global order on locks and check that all locks are acquired in accordance with that order however we benefit from the declarative nature of data centric synchronization in aj to infer the locks that threads may acquire we rely on two properties of aj i all locks are associated with atomic sets and ii the memory locations associated with different atomic sets will be disjoint unless they are explicitly merged by the programmer our algorithm computes a partial order on atomic sets if such an order can be found a program is deadlock free for programs that use recursive data structures the approach is extended to take into account a programmer specified ordering between different instances of an atomic set we implemented this analysis and evaluated it on 10 aj programs these programs were converted from java as part of our previous work dhm 12 and cover a range of programming style s the analysis was able to prove all 10 programs deadlock free minor refactorings were needed in 2 cases and a total of 4 ordering annotations were needed all in 1 program in summary this talk presents the following contributions of our latest work mhd 13 • we present a static analysis for detecting possible deadlock in aj programs it leverages the declarative nature of atomic sets to check that locks are acquired in a consistent order if so the program is guaranteed to be deadlock free otherwise possible deadlock is reported • to handle recursive data structures we extend aj with ordering annotations that are enforced by a small extension of aj s type system we show how these annotations are integrated with our analysis in a straightforward manner • we implemented the analysis and evaluated it on a set of aj programs the analysis found all programs to be deadlock free requiring minor refactorings in two cases only 4 ordering annotations were needed in 1 program icsoft pt 2014 proceedings of the 9th international conference on software paradigm trends the proceedings contain 21 papers the topics discussed include propagating model refactorings to graph transformation rules an ltl semantics of business workflows with recovery real time reconfigurable scheduling of aperiodic os tasks on multiprocessor systems the impact of agile approaches on software quality attributes an empirical study developing user interfaces with emf parsley modeling micro services in email marketing concepts implementation and experiences a meta modeling approach for extending the instructional design semantics of learning management systems model weaving and pedagogy mapping abstraction levels in instructional design languages automated quantitative attributes prediction from architectural description language semantic resource adaptation based on generic ontology models and traditional vs agile development a comparison using chaos theory effort estimation for architectural refactoring to introduce module isolation the decomposition of software architecture into modular units is driven by both functional and quality concerns dependability and security are among quality concerns that require a software to be decomposed into separate units isolated from each other however it appears that this decomposition is usually not aligned with the decomposition based on functional concerns as a result introducing module isolation forced by quality attributes while preserving the existing decomposition is not trivial and requires a substantial refactoring effort in this work we introduce an approach and a toolset to predict this effort prior to refactoring activities as such a selection can be made among potential decomposition alternatives based on quantitative estimations these estimations are obtained from scalable analysis of module dependencies based on a graph database and reusable query templates we discuss our experiences and evaluate our approach on a code base used in a commercial digital tv and set top box software 2014 springer international publishing switzerland dependability effort estimation module isolation refactoring reverse engineering security software architecture traversing the fungal terpenome 2014 the partner organisations fungi ascomycota and basidiomycota are prolific producers of structurally diverse terpenoid compounds classes of terpenoids identified in fungi include the sesqui di and triterpenoids biosynthetic pathways and enzymes to terpenoids from each of these classes have been described these typically involve the scaffold generating terpene synthases and cyclases and scaffold tailoring enzymes such as e g cytochrome p450 monoxygenases nad p and flavin dependent oxidoreductases and various group transferases that generate the final bioactive structures the biosynthesis of several sesquiterpenoid mycotoxins and bioactive diterpenoids has been well studied in ascomycota e g filamentous fungi little is known about the terpenoid biosynthetic pathways in basidiomycota e g mushroom forming fungi although they produce a huge diversity of terpenoid natural products specifically many trans humulyl cation derived sesquiterpenoid natural products with potent bioactivities have been isolated biosynthetic gene clusters responsible for the production of trans humulyl cation derived protoilludanes and other sesquiterpenoids can be rapidly identified by genome sequencing and bioinformatic methods genome mining combined with heterologous biosynthetic pathway refactoring has the potential to facilitate discovery and production of pharmaceutically relevant fungal terpenoids automated pattern directed refactoring for complex conditional statements complex conditional statement is one of the bad code smells which affects the quality of the code and design of software in the proposed approach two commonly used design patterns for handling complex conditional statements are selected and they are the factory method pattern and the strategy pattern two pattern directed refactoring approaches based on the two design patterns are proposed each approach contains a refactoring opportunities identification algorithm and an automated refactoring algorithm after parsing the abstract syntax tree generated from source code the refactoring opportunities are identified effectively and automatically then for candidate code refactoring algorithms are executed automatically which are used to simplify or remove complex conditional statements by empirical analysis and quality assessment the code after refactoring has better maintainability and extensibility and the proposed approach for automated pattern directed refactoring succeeds to reduce code size and complexity of classes 2014 central south university press and springer verlag berlin heidelberg abstract syntax tree complex conditional statements design patterns factory method pattern refactoring strategy pattern software refactoring under uncertainty a robust multi objective approach refactoring large systems involves several sources of uncertainty related to the severity levels of code smells to be corrected and the importance of the classes in which the smells are located due to the dynamic nature of software development these values cannot be accurately determined in practice leading to refactoring sequences that lack robustness to address this problem we introduced a multiobjective robust model based on nsga ii for the software refactoring problem that tries to find the best trade off between quality and robustness code smells robust optimization search based software engineering software quality recommending refactorings based on team co maintenance patterns 2014 acm refactoring aims at restructuring existing source code when undisciplined development activities have deteriorated its comprehensibility and maintainability there exist various approaches for suggesting refactoring opportunities based on different sources of information e g structural semantic and historical in this paper we claim that an additional source of information for identifying refactoring opportunities sometimes orthogonal to the ones mentioned above is team development activity when the activity of a team working on common modules is not aligned with the current design structure of a system it would be possible to recommend appropriate refactoring operations e g extract class method package to adjust the design according to the teams activity patterns results of a preliminary study conducted in the context of extract class refactoring show the feasibility of the approach and also suggest that this new refactoring dimension can be complemented with others to build better refactoring recommendation tools developers refactoring teams clonepedia summarizing code clones by common syntactic context for software maintenance 2014 ieee code clones have to be made explicit and be managed in software maintenance researchers have developed many clone detection tools to detect and analyze code clones in software systems these tools report code clones as similar code fragments in source files however clone related maintenance tasks e g refactorings often involve a group of code clones appearing in larger syntactic context e g code clones in sibling classes or code clones calling similar methods given a list of low level code fragment clones developers have to manually summarize from bottom up low level code clones that are relevant to the syntactic context of a maintenance task in this paper we present a clone summarization technique to summarize code clones with respect to their common syntactic context the clone summarization allows developers to locate and maintain code clones in a top down manner by type hierarchy and usage dependencies we have implemented our approach in the clonepedia tool and conducted a user study on jhotdraw with 16 developers our results show that clonepedia users can better locate and refactor code clones compared with developers using the clonedetective tool clone summarization code clone syntactic pattern high mcc functions in the linux kernel 2013 springer science business media new york mccabe s cyclomatic complexity mcc is a widely used metric for the complexity of control flow common usage decrees that functions should not have an mcc above 50 and preferably much less however the linux kernel includes more than 800 functions with mcc values above 50 and over the years 369 functions have had an mcc of 100 or more moreover some of these functions undergo extensive evolution indicating that developers are successful in coping with the supposed high complexity functions with similarly high mcc values also occur in other operating systems and domains including windows for example the highest mcc value in freebsd is 1316 double the highest mcc in linux we attempt to explain all this by analyzing the structure of high mcc functions in linux and showing that in many cases they are in fact well structured albeit we observe some cases where developers indeed refactor the code in order to reduce complexity moreover human opinions do not correlate with the mcc values of these functions a survey of perceived complexity shows that there are cases where high mcc functions were ranked as having a low complexity we characterize these cases and identify specific code attributes such as the diversity of constructs not only a switch but also ifs and nesting that correlate with discrete increases in perceived complexity these observations indicate that a high mcc is not necessarily an impediment to code comprehension and support the notion that complexity cannot be fully captured using simple syntactic code metrics in particular we show that regularity in the code meaning repetitions of the same pattern of control structures correlates with low perceived complexity code regularity linux kernel mccabe cyclomatic complexity perceived complexity software complexity 2014 international symposium on software testing and analysis issta 2014 proceedings the proceedings contain 49 papers the topics discussed include virtual dom coverage for effective testing of dynamic web applications performance regression testing of concurrent classes hybrid security analysis of web javascript code via dynamic partial evaluation verification aided regression testing verifying atomicity via data independence runtime prevention of concurrency related type state violations in multithreaded applications dom based test adequacy criteria for web applications cross platform feature matching for web applications a type system for format strings covrig a framework for the analysis of code test and coverage evolution in real software corebench studying complexity of regression errors arc effective typestate and lifetime dependency analysis tailored source code transformations to synthesize computationally diverse program variants scalable detection of missed cross function refactorings and using test case reduction and prioritization to improve symbolic execution a robust multi objective approach for software refactoring under uncertainty refactoring large systems involves several sources of uncertainty related to the severity levels of code smells to be corrected and the importance of the classes in which the smells are located due to the dynamic nature of software development these values cannot be accurately determined in practice leading to refactoring sequences that lack robustness to address this problem we introduced a multi objective robust model based on nsga ii for the software refactoring problem that tries to find the best trade off between quality and robustness we evaluated our approach using six open source systems and demonstrated that it is significantly better than state of the art refactoring approaches in terms of robustness in 100 of experiments based on a variety of real world scenarios our suggested refactoring solutions were found to be comparable in terms of quality to those suggested by existing approaches and to carry an acceptable robustness price our results also revealed an interesting feature about the trade off between quality and robustness that demonstrates the practical value of taking robustness into account in software refactoring 2014 springer international publishing switzerland identifying refactoring opportunities from code clones based on som clustering code clones are regarded as typical bad smell because they usually make software maintenance more difficult and may even propagate bugs code clones almost exist in all kinds of source programs of any nontrivial software in order to reduce the harmful impacts on software quality caused by code clones some clones satisfying certain conditions should be removed by refactoring however for subsequent refactoring those refactor able code clones should be identified first in this paper a method based on som self organizing map clustering is proposed to identify code clones which can satisfy certain conditions for refactoring the method has 5 basic steps code clone detection refactoring sample selection data preprocessing som modeling and refactoring opportunity identification the results of related experiments on 6 open source software show that the method has better precision than the method using single metric and has better validity than the method using multiple metrics 2014 icic international code clone refactoring opportunity software quality som clustering proceedings 2014 6th international workshop on empirical software engineering in practice iwesep 2014 the proceedings contain 10 papers the topics discussed include the effect of moving windows on software effort estimation comparative study with cart automatic unsupervised bug report categorization an exploratory analysis for studying software evolution time delayed correlation analysis class responsibility assignment as fuzzy constraint satisfaction extraction of conditional statements for understanding business rules what kinds of refactorings are co occurred an analysis of eclipse usage datasets a cross project evaluation of text based fault prone module prediction assessing mcr discussion usefulness using semantic similarity and industry questions about open source software in business research directions and potential answers modularization compass navigating the white waters of feature oriented modularity successful software systems have to adapt to the evolving needs of their users however adding and extending functional features often becomes more difficult over time due to aggregated complexity and eroded modularity this erosion can be quantified by measuring scattering and tangling of feature implementations in the source code to track long term regressions and to plan refactorings this paper argues that the traditional usage of only the absolute values of modularity metrics is however insufficient and proposes to use their relative values instead these relative values are referred to as the drift of featureoriented modularity and are defined as the distance between the actual metric values for a given source code and their values achievable for the source code s ideally modularized counterpart the proposed approach called modularization compass computes the modularity drift by optimizing the feature oriented modularization of source code based on traceability links between features and source code the optimized modularizations are created automatically by transforming the groupings of classes into packages which is guided by a multi objective grouping genetic algorithm the proposed approach was evaluated by application to long term release histories of three open source java applications features measurement modularity software evolution supporting requirements to code traceability through refactoring in this paper we hypothesize that the distorted traceability tracks of a software system can be systematically re established through refactoring a set of behavior preserving transformations for keeping the system quality under control during evolution to test our hypothesis we conduct an experimental analysis using three requirements to code datasets from various application domains our objective is to assess the impact of various refactoring methods on the performance of automated tracing tools based on information retrieval results show that renaming inconsistently named code identifiers using rename identifier refactoring often leads to improvements in traceability in contrast removing code clones using extract method xm refactoring is found to be detrimental in addition results show that moving misplaced code fragments using move method refactoring has no significant impact on trace link retrieval we further evaluate rename identifier refactoring by comparing its performance with other strategies often used to overcome the vocabulary mismatch problem in software artifacts in addition we propose and evaluate various techniques to mitigate the negative impact of xm refactoring an effective traceability sign analysis is also conducted to quantify the effect of these refactoring methods on the vocabulary structure of software systems 2013 springer verlag london information retrieval refactoring traceability automatic ranking of clones for refactoring through mining association rules in this paper we present an in depth empirical study on identifying clone fragments that can be important refactoring candidates we mine association rules among clones in order to detect clone fragments that belong to the same clone class and have a tendency of changing together during software evolution the idea is that if two or more clone fragments from the same class often change together i e are likely to co change preserving their similarity they might be important candidates for refactoring merging such clones into one if possible can potentially decrease future clone maintenance effort we define a particular clone change pattern the similarity preserving change pattern spcp and consider the cloned fragments that changed according to this pattern i e the spcp clones as important candidates for refactoring for the purpose of our study we implement a prototype tool called marc that identifies spcp clones and mines association rules among these the rules as well as the spcp clones are ranked for refactoring on the basis of their change proneness we applied marc on thirteen subject systems and retrieved the refactoring candidates for three types of clones type 1 type 2 and type 3 separately our experimental results show that spcp clones can be considered important candidates for refactoring clones that do not follow spcp either evolve independently or are rarely changed by considering spcp clones for refactoring we not only can minimize refactoring effort considerably but also can reduce the possibility of delayed synchronizations among clones and thus can minimize inconsistencies in software systems 2014 ieee association rule clone change pattern clone class clone refactoring identifying accurate refactoring opportunities using metrics springer india 2014 cloned code also known as duplicated code is among the bad code smells refactoring can be used to remove clones and makes a software system more maintainable however there is a problem that causes the output results of the clone code detection tool cannot be directly refactored the problem is not all the clone groups are suitable for refactoring to address it we propose a metric method to identify clone groups that are suitable for refactoring the results of several large scale software system studies indicate that our method can significantly increase the accuracy of identifying clone groups that are suitable for refactoring it is not only beneficial to the following study of refactoring but also it connects the entire process from clone detection to clone refactoring cloned code metric refactoring transition and defect patterns of components in dependency cycles during software evolution the challenge to break existing cyclically connected components of running software is not trivial since it involves planning and human resources to ensure that the software behavior is preserved after refactoring activity therefore to motivate refactoring it is essential to obtain evidence of the benefits to the product quality this study investigates the defect proneness patterns of cyclically connected components vs noncyclic ones when they transition across software releases we have mined and classified software components into two groups and two transition states the cyclic and the non cyclic ones next we have performed an empirical study of four software systems from evolutionary perspective using standard statistical tests on formulated hypotheses we have determined the significance of the defect profiles and complexities of each group the results show that during software evolution components that transition between dependency cycles have higher probability to be defect prone than those that transition outside of cycles furthermore out of the three complexity variables investigated we found that an increase in the class reachability set size tends to be more associated with components that turn defective when they transition between dependency cycles lastly we found no evidence of any systematic cycle breaking refactoring between releases of the software systems thus these findings motivate for refactoring of components in dependency cycle taking into account the minimization of metrics such as the class reachability set size 2014 ieee defect proneness dependency cycle refactoring scalable detection of missed cross function refactorings copyright 2014 acm refactoring is an important way to improve the design of existing code identifying refactoring opportunities i e code fragments that can be refactored in large code bases is a challenging task in this paper we propose a novel automated and scalable technique for identifying cross function refactoring opportunities that span more than one function e g extract method and inline method the key of our technique is the design of efficient vector inlining operations that emulate the effect of method inlining among code fragments so that the problem of identifying cross function refactoring can be reduced to the problem of finding similar vectors before and after inlining we have implemented our technique in a prototype tool named redex which encodes java programs to particular vectors we have applied the tool to a large code base 4 5 million lines of code comprising of 200 bundle projects in the eclipse ecosystem e g eclipse jdt eclipse pde apache commons hamcrest etc also different from many other studies on detecting refactoring redex only searches for code fragments that can be but have not yet been refactored in a way similar to some refactoring that happened in the code base our results show that redex can find 277 cross function refactoring opportunities in 2 minutes and 223 cases were labelled as true opportunities by users and cover many categories of cross function refactoring operations in classical refactoring books such as self encapsulate field decompose conditional expression hide delegate preserve whole object etc refactoring software evolution vector based representation distilling structure in taverna scientific workflows a refactoring approach 2014 cohen boulakia et al background scientific workflows management systems are increasingly used to specify and manage bioinformatics experiments their programming model appeals to bioinformaticians who can use them to easily specify complex data processing pipelines such a model is underpinned by a graph structure where nodes represent bioinformatics tasks and links represent the dataflow the complexity of such graph structures is increasing over time with possible impacts on scientific workflows reuse in this work we propose effective methods for workflow design with a focus on the taverna model we argue that one of the contributing factors for the difficulties in reuse is the presence of antipatterns a term broadly used in program design to indicate the use of idiomatic forms that lead to over complicated design the main contribution of this work is a method for automatically detecting such anti patterns and replacing them with different patterns which result in a reduction in the workflow s overall structural complexity rewriting workflows in this way will be beneficial both in terms of user experience easier design and maintenance and in terms of operational efficiency easier to manage and sometimes to exploit the latent parallelism amongst the tasks results we have conducted a thorough study of the workflows structures available in taverna with the aim of finding out workflow fragments whose structure could be made simpler without altering the workflow semantics we provide four contributions firstly we identify a set of anti patterns that contribute to the structural workflow complexity secondly we design a series of refactoring transformations to replace each anti pattern by a new semantically equivalent pattern with less redundancy and simplified structure thirdly we introduce a distilling algorithm that takes in a workflow and produces a distilled semantically equivalent workflow lastly we provide an implementation of our refactoring approach that we evaluate on both the public taverna workflows and on a private collection of workflows from the biovel project conclusion we have designed and implemented an approach to improving workflow structure by way of rewriting preserving workflow semantics future work includes considering our refactoring approach during the phase of workflow design and proposing guidelines for designing distilled workflows the emd analysis ae signals of rock failure under uniaxial compression the wavelet packet basis is difficult to be extracted by wavelet analysis at present to solve this problem an experiment of acoustic emission under uniaxial compression is conducted by saeu2s acoustic emission system and electro hydraulic servo universal testing machine and the method of empirical mode analysis is adopted to explore the acoustic emission signal in this paper firstly with the method of empirical mode decomposition the acoustic emission signal is decomposed into the forms of intrinsic mode function with several local time scale and residual components and then these data is analyzed after the noise reducing imf and residual components are refactored the error between the final and the initial reconstruction signals is less than 10 6 the experiment indicates that the emd method is effective in processing the local rock acoustic emission signals the emd method also provides an efficient way to predict deformation trend of rock damage through deformation of waveform analysis 2014 trans tech publications switzerland acoustic emission signal emd signal processing uniaxial compression apievolutionminer keeping api evolution under control during software evolution source code is constantly refactored in real world migrations many methods in the newer version are not present in the old version e g 60 of the methods in eclipse 2 0 were not in version 1 0 this requires changes to be consistently applied to reflect the new api and avoid further maintenance problems in this paper we propose a tool to extract rules by monitoring api changes applied in source code during system evolution in this process changes are mined at revision level in code history our tool focuses on mining invocation changes to keep track of how they are evolving we also provide three case studies in order to evaluate the tool 2014 ieee uncovering errors in atl model transformations using static analysis and constraint solving 2014 ieee model transformations play a prominent role in model driven engineering mde where they are used to transform models between languages to refactor and simulate models or to generate code from models however while the reliability of any mde process depends on the correctness of its transformations methods helping in detecting errors in transformations and automate their verification are still needed to improve this situation we propose a method for the static analysis of one of the most widely used model transformation languages atl the method proceeds in three steps firstly it infers typing information from the transformation and detects potential errors statically then it generates ocl path conditions for the candidate errors stating the requirements for a model to hit the problematic statements in the transformation last it relies on constraint solving to generate a test model fragment or witness that exercises the transformation making it execute the problematic statement our method is supported by a prototype tool that integrates a static analyzer a testing tool and a constraint solver we have used the tool to analyse medium and large size third party atl transformations discovering a wide number of errors constraint solving model transformation model driven engineering static analysis verification and testing repurposing user oriented artifacts as outside in refactoring tools refactoring now regarded as an essential practice in agile software development provides a disciplined methodology to prevent evolving code from degrading in quality refactoring strives to improve the structure and readability of code often through standard code transformations increasingly ides have added refactoring tools to assist developers by automating increasingly complex refactorings unfortunately perhaps because of usability issues studies have shown that automated refactoring tools are used much less than what might be hoped for we propose to take an agile approach to refactoring tools and make use of existing user oriented artifacts to promote refactorings that improve the code s ability to convey its intent artifacts related to the application ui user interface domain models user demos etc are re purposed as refactoring tools to bring the outside world into the code intuitive agile and already available this provides a different type of refactoring tool which focuses more on expressing the intent of the code rather than on automatic code transformations we expect the resulting code will have a better alignment of objects methods and identifiers with user concepts and vocabulary incorporating this method into how agile software development is taught can also provide students with a more outside in perspective spurring better customer communication and resulting in code which more clearly captures and expresses user concerns agile modeling refactoring software development user interaction design refactoring structure semantics similar clones combining standardization with metrics springer india 2014 eliminating code clones is good for improving the quality and maintainability of software structure semantics similar code clones are more difficult to be refactored than other types of clones this paper presents an algorithm for refactoring structure semantics similar clones structure semantics similar clones are the clones that have similar program dependence graph pdgs after semantic equivalent standardization transformation the graph based standardization method can identify the semantically similar code clones effectively with a high computation complexity the metrics based method has a lower computation complexity but also has a lower accuracy of identification to solve this problem this paper first uses the metrics based method to filter out most candidate clones not suitable for refactoring and then further confirms the structure semantics similar clones that are suitable for refactoring by code standardization pdgs matching and similarity comparison structure semantics we propose a new approach for refactoring structure semantics similar clones combining standardization with metrics the experiments results in open source codes show that this method behaves well in refactoring structure semantics similar clones code standardization metrics program refactoring structure semantics similar clone evaluation of flexibility to changes focusing on the variable structures in legacy software light weight development processes like agile have emerged in response to rapidly changing market requirements however such processes are inadequate for software in embedded systems as embedded software undergoes frequent refactoring targeting only immediate requirements as a result maintainability decreases because the system is not designed to respond to changes in the associated hardware in this paper we propose a method for detection of variation points and variability mechanisms we also propose a technique for evaluation of flexibility to changes our approach is based on analyses of the call graph and the inheritance structure of source code to identify a layer structure that is specific to embedded software these techniques provide us with objective and quantitative information about costs of adding functionality we applied the proposal method to an actual product s code before and after the refactoring and could verify an improvement in system s variability springer international publishing switzerland 2014 evaluation flexibility legacy code variability quantum inspired remote sensing image denoising with double density dual tree complex wavelet transform 2014 spie considering that double density dual tree dd dt complex wavelet has translation invariance anti aliasing properties and more compact space intervals based on the quantum inspired parameter estimation this paper proposed a new quantum inspired noise reduction method based on dd dt complex wavelet transform for remote sensing images especially the sar images the general process is addressed as below conduct a logarithmic transformation for the sar images convert the multiplicative speckle noises to additive noises then decompose the dd dt complex wavelets for each image thus to get the wavelet coefficient for each layer in all detailed directions consider the inter scale correlation of wavelet coefficient utilize the bayesian estimation theory along with the quantum mechanics principle of superposition calculate the estimated wavelet coefficient and then process the data layer by layer refactor the sar images using the processed coefficients then conduct a anti logarithmic transformation to get the noise reduction result compare with the results of traditional methods the resulting images have a significant improvement in different evaluation functions such as the peak signal noise ratio edge preserve index etc the results have also shown better noise reduction quality in the images bayesian estimation theory double density dual tree complex wavelet transform image noise reduction quantum inspired jcsd visual support for understanding code control structure copyright 2014 acm program comprehension is a vital mental process in any maintenance activity it becomes decisive as functions get larger such functions are burdened with very many programming constructs as lines of code loc strongly correlate with the mccabe s cyclomatic complexity mcc this makes it hard to capture the whole code of such functions and as a result hinders grasping their structural properties that might be essential for maintenance program visualization is known as a key solution that assists in comprehending complex systems as a matter of fact we have shown in a recent work that control structure diagrams csd could be useful to better understand and discover structural properties of such functions for example we found that the code regularity property and even cloning can be easily identified by csds this paper presents jcsd which is an eclipse plug in that implements csd diagrams for java methods in particular it visualizes the control structure and nesting of a java method and by this it easily conveys structural characteristics of the code to the programmer and helps him to better understand and refactor code complexity code regularity loc mcc visualization functionally equivalent c code clone refactoring by combining static analysis with dynamic testing springer india 2014 software with code clones is difficult for maintenance it increases the cost of software maintenance to solve the key problems of function optimization and parameter matching during the process of functionally equivalent code clone refactoring this paper puts forward an approach for restructuring the fourth type functionally equivalent code clone by combining static analysis and dynamic testing first two kinds of function optimization strategy are proposed i e running time and static characteristics then determine the optimization function in each functionally equivalent code clone group according to the proposed optimization strategy finally use the method of static analysis and dynamic testing tomatch the parameter matching for the replacement of procedure on the basis of parameter matching replace other clones with the optimization function and then complete the c code clone refactoring functionally equivalent c code clone refactoring system prototype is developed experimental results on the open source program show that the method can be accurately and effectively refactor the functionally equivalent c clone code code clone code refactoring dynamic testing static analysis hierarchical control system for pv microgrid applications 2014 trans tech publications switzerland dc microgrid can effectively play to the value and benefits of the distributed power supply communication than micro grid connected have the ability to stronger more flexible refactoring and therefore become a new trend micro grid connected technology research based on photovoltaic dc microgrid as example this paper aimed at the dc microgrid voltage stability problem proposes a layered coordination control dc bus voltage the method is based on the detection and control of dc bus voltage variation to coordinate photovoltaic battery energy storage interface net side interface and the interface converter works ensure that under different conditions can keep the grid connected in active power balance using matlab simulink simulation and experimental verification the results verified the effectiveness and feasibility of the method dc microgrid photovoltaic generation voltage hierarchical coordinated control refactoringscript a script and its processor for composite refactoring copyright 2014 by knowledge systems institute graduate school refactoring is widely recognized as a method to improve the internal qualities of source code however manual refactoring is time consuming and error prone consequently many tools to support automated refactoring have been suggested but most support only unit and simple refactoring making it difficult to perform composite refactoring e g introducing a design pattern where a refactoring set is applied at one position or the same refactoring operation is applied at multiple positions in this paper we propose a novel script language and its processor to describe how and where to refactor by a model expressing source code∗ sup 1 sup evaluations indicate that our language and processor allow refactoring steps to be described as scripts which can be easily replayed and reused for multiple projects code manipulation refactoring research on wavelet singularity detection based fault tolerant federated filtering algorithm for ins gps dvl integrated navigation system copyright 2014 jianhua cheng et al soft faults in navigation sensors will lead to the degradation of the accuracy and reliability of integrated navigation system to solve this problem a wavelet analysis and signal singularities based soft fault detection method are given out to find signal singularities and detect the faults the modulus maxima values are calculated after the wavelet transform of original signal by calculating the lipschitz exponent using themodulusmaxima value at the fault point the fault types are distinguished then a fault tolerant federated filtering algorithm for the calibration of ins gps dvl integrated navigation system is proposed simulations are conducted and results show that sensor soft faults can be detected accurately by effectively isolating the fault and refactoring information the accuracy and reliability of navigation system are improved international conference on soft computing techniques and engineering application icsctea 2013 the proceedings contain 69 papers the special focus in this conference is on soft computing techniques and engineering application the topics include research on hierarchical clustering algorithm based on cluster outline exploration of fault diagnosis technology for air compressor based on internet of things an enhancement algorithm based on fuzzy sets algorithm using computer vision system for chip image processing development of ddos attack defense system based on ikev2 protocol power data network dynamic simulation platform an emotional model based on multiple factors multi source and heterogeneous knowledge organization and representation for knowledge fusion in cloud manufacturing research of dynamics and deploying control method on tethered satellite using auto associative neural networks for signal recognition technology on sky screen research on the hotspot information push system for the online journal based on open source framework development of control system of wheel type backhoe loader some results on fuzzy weak boolean filters of non commutative residuated lattice cgps a fuzzy based context aware privacy preserving scheme for mobile computing services research and application of trust management system ranaad xek identifying accurate refactoring opportunities using metrics research on neural network predictive control of induction motor servo system for robot research on scale out workloads and optimal design of multicore processors study of modified montgomery s algorithm and its application to 1 024 bit rsa a mvs based object relational model of the internet of things and rateless code based unequal loss protection for layer coded media delivery how do code refactorings affect energy usage 2014 acm context code refactoring s benefits to understandability maintainability and extensibility are well known enough that automated support for refactoring is now common in ides however the decision to apply such transformations is currently performed without regard to the impacts of the refactorings on energy consumption this is primarily due to a lack of information and tools to provide such relevant information to developers unfortunately concerns about energy efficiency are rapidly becoming a high priority concern in many environments including embedded systems laptops mobile devices and data centers goal we aim to address the lack of information about the energy efficiency impacts of code refactorings method we conducted an empirical study to investigate the energy impacts of 197 applications of 6 commonly used refactorings results we found that refactorings can not only impact energy usage but can also increase and decrease the amount of energy used by an application in addition we also show that metrics commonly believed to correlate with energy usage are unlikely to be able to fully predict the impact of applying a refactoring conclusion the results from this and similar studies could be used to augment ides to help software developers build more energy efficient software code refactoring empirical study energy usage model refactoring using examples a search based approach one of the important challenges in model driven engineering is how to improve the quality of the models design in order to help designers understand them refactoring represents an efficient technique to improve the quality of a design while preserving its behavior most of existing work on model refactoring relies on declarative rules to detect refactoring opportunities and to apply the appropriate refactorings however a complete specification of refactoring opportunities requires a huge number of rules in this paper we consider the refactoring mechanism as a combinatorial optimization problem where the goal is to find good refactoring suggestions starting from a small set of refactoring examples applied to similar contexts our approach named model refactoring by example takes as input an initial model to refactor a set of structural metrics calculated on both initial model and models in the base of examples and a base of refactoring examples extracted from different software systems and generates as output a sequence of refactorings a solution is defined as a combination of refactoring operations that should maximize as much as possible the structural similarity based on metrics between the initial model and the models in the base of examples a heuristic method is used to explore the space of possible refactoring solutions to this end we used and adapted a genetic algorithm as a global heuristic search the validation results on different systems of real world models taken from open source projects confirm the effectiveness of our approach copyright 2014 john wiley sons ltd copyright 2014 john wiley sons ltd genetic algorithm heuristic method model evolution model refactoring refactoring by example software maintenance an investigation into the characteristics of merged code clones during software evolution although code clones i e code fragments that have similar or identical code fragments in the source code are regarded as a factor that increases the complexity of software maintenance tools for supporting clone refactoring i e merging a set of code clones into a single method or function are not commonly used to promote the development of refactoring tools that can be more widely utilized we present an investigation of clone refactoring carried out in the development of open source software systems in the investigation we identified the most frequently used refactoring patterns and discovered how merged code clone token sequences and differences in token sequence lengths vary for each refactoring pattern 2014 the institute of electronics information and communication engineers code clone open source software refactoring doceng 2014 proceedings of the 2014 acm symposium on document engineering the proceedings contain 33 papers the topics discussed include activetimesheets extending web based multimedia documents with dynamic modification and reuse features automated refactoring for size reduction of css style sheets flexifont a flexible system to generate personal font libraries circular coding with interleaving phase a new sentence similarity assessment measure based on a three layer sentence representation paper stitching using maximum tolerant seam under local distortions abstract argumentation for reading order detection generating summary documents for a variable quality pdf document collection transforming graph based sentence representations to alleviate overfitting in relation extraction ruling analysis and classification of torn documents on automatic text segmentation and p gtm privacy preserving google tri gram method for semantic text similarity impact of process conformance on the effects of test driven development 2014 acm context one limitation of the empirical studies about test driven development tdd is knowing whether the developers followed the advocated test code refactor cycle research dealt with the issue of process conformance only in terms of internal validity while investigating the role of other confounding variables that might explain the controversial effects of tdd none of the research included process conformance as a fundamental part of the analysis goal we aim to examine the impact of process conformance on the claimed effects of tdd on external quality developers productivity and test quality method we used data collected during a previous study to create regression models in which the level of process conformance was used to predict external quality productivity and tests thoroughness result based on our analysis of the available data n 22 we observe that neither quality p value 0 21 productivity p value 0 80 number of tests p value 0 39 nor coverage p value 0 09 was correlated with the level of tdd process conformance conclusion while based on a small sample we raise concerns about how tdd is interpreted we also question whether the cost of strictly following tdd will pay off in terms of external quality productivity and tests thoroughness developers productivity regression models software quality test driven development semi automatic refactoring to aspect oriented platform refactoring is necessary in large software projects and an aspect oriented approach can help to maintain concerns in the source code while tools for object oriented refactoring are the usual part of development environments support for aspect oriented refactoring is minimal we analyzed object oriented bad smells applicable for an aspect oriented approach and propose a method for the detection of crosscutting concerns and consecutive refactoring 2013 ieee a study of cyclic dependencies on defect profile of software components background empirical evidence shows that dependency cycles among software components are pervasive in real life software systems although such cycles are known to be detrimental to software quality attributes such as understandability testability reusability build ability and maintainability research goals can the use of extended object oriented metrics make us better understand the relationships among cyclic related components and their defect proneness approach first we extend such metrics to mine and classify software components into two groups the cyclic and the non cyclic ones next we have performed an empirical study of six software applications using standard statistical tests on four different hypotheses we have determined the significance of the defect profiles of both groups results our results show that most defects and defective components are concentrated in cyclic dependent components either directly or indirectly discussion and conclusion these results have important implications for software maintenance and system testing by identifying the most defect prone set in a software system it is possible to effectively allocate testing resources in a cost efficient manner based on these results we demonstrate how additional structural properties could be collected to understand component s defect proneness and aid decision process in refactoring defect prone cyclic related components 2013 elsevier inc all rights reserved defect prone components defects dependency cycle identification of refused bequest code smells accumulated technical debt can be alleviated by means of refactoring application aiming at architectural improvement a prerequisite for wide scale refactoring application is the automated identification of the corresponding refactoring opportunities or code smells one of the major architectural problems that has received limited attention is the so called refused bequest which refers to inappropriate use of inheritance in object oriented systems this code smell occurs when subclasses do not take advantage of the inherited behavior implying that replacement by delegation should be used instead in this paper we propose a technique for the identification of refused bequest code smells whose major novelty lies in the intentional introduction of errors in the inherited methods the essence of inheritance is evaluated by exercising the system s functionality through the corresponding unit tests in order to reveal whether inherited methods are actually employed by clients based on the results of this approach and other structural information an indication of the smell strength on a thermometer is obtained the proposed approach has been implemented as an eclipse plugin 2013 ieee code smell refactoring refused bequest software maintenance unifying clone analysis and refactoring activity advancement towards c applications refactoring involves improve the quality of software and reduce the software complexity without affecting its external behavior the research focuses code clones is a vital target of refactoring and code clones increase the internal complexity maintenance effort and reduce the quality of software a clone consists of two or more segments of code that duplicates with each other on the basis of distinct type of similar measurements the developed algorithm insist a new semantic based clone management and refactoring system to detect and manage as well as refactor both exact and near miss code clones the major goal has to remove the clones in source code fragments by unifying the process of clone detection and refactoring the implemented clone refactoring technique detects and fixes the clones in multiple classes using graph structure and methods the code analyzer analyzes the user typed code by separating the auto generated code based on a graph structure a new abstract semantic graph refactoring algorithm for detecting the clones in multiple classes of source code fragments have been experimented in this research 2013 ieee abstract syntax tree ast clone detection code clones parsing refactoring software maintenance source code fragments research on the model of legacy software reuse based on code clone detection the construction of large scale engineering project usually relies on the development of many new software systems whereas it would be very expensive and time consuming if these new software systems are completely developed anew in order to solve the problem a model of legacy software reuse is proposed in this paper the model is based on code clone detection firstly code clone in source code of legacy software is detected by means of code clone detection tool secondly abstract syntax trees of the functions which contain code clone are created thirdly the degree of variation between the functions which contain the code clone belongs to the same clone set is calculated according to their abstract syntax trees and then some functions whose similarities of abstract syntax trees are in the allowed range are combined finally the combined functions and other frequently invoked functions are refactored into new functions or encapsulated into new classes and all of these functions or classes can be reused as components in the development of new software systems the test result shows that the reuse method based on this model can shrink the scope for searching the reusable component in legacy software systems and thus improve the efficiency of legacy software reuse 2013 ieee code clone legacy system refactoring refactoring clones an optimization problem the refactoring of software clones is achieved by extracting their common functionality into a single method any differences in identifiers and literals between the clones have to become parameters in the extracted method obviously a large number of differences leads to an extracted method with limited reusability due to the large number of introduced parameters we support that minimizing the differences between the matched statements of clones is crucial for the purpose of refactoring and propose an algorithm that treats the matching process as an optimization problem 2013 ieee maximum common subgraph optimization program dependence graph refactoring software clones constructing defect predictors and communicating the outcomes to practitioners background an alternative to expert based decisions is to take data driven decisions and software analytics is the key enabler for this evidence based management approach defect prediction is one popular application area of software analytics however with serious challenges to deploy into practice goal we aim at developing and deploying a defect prediction model for guiding practitioners to focus their activities on the most problematic parts of the software and improve the efficiency of the testing process method we present a pilot study where we developed a defect prediction model and different modes of information representation of the data and the model outcomes namely commit hotness ranking error probability mapping to the source and visualization of interactions among teams through errors we also share the challenges and lessons learned in the process result in terms of standard performance measures the constructed defect prediction model performs similar to those reported in earlier studies e g 80 of errors can be detected by inspecting 30 of the source however the feedback from practitioners indicates that such performance figures are not useful to have an impact in their daily work pointing out most problematic source files even isolating error prone sections within files are regarded as stating the obvious by the practitioners though the latter is found to be helpful for activities such as refactoring on the other hand visualizing the interactions among teams based on the errors introduced and fixed turns out to be the most helpful representation as it helps pinpointing communication related issues within and across teams conclusion the constructed predictor can give accurate information about the most error prone parts creating practical representations from this data is possible but takes effort the error prediction research done in elektrobit wireless ltd is concluded to be useful and we will further improve the presentations made from the error prediction data 2013 ieee data driven decisions error prediction machine learning algorithms prediction algorithms software testing agent based tool for topologically sorting badsmells and refactoring by analyzing complexities in source code code smells are smells found in source code as the source code becomes larger and larger we find bad smells in the source code these bad smells are removed using refactoring hence experts say the method of removing bad smells without changing the quality of code is called as refactoring 1 but this refactoring if not done properly is risky and can take time i e might be days or weeks hence here we provide a technique to arrange these bad smells analyze the complexities found in the source code and then refactor them these bad smell detection and scheduling has been done manually or semi automatically this paper provides a method of automatically detecting theses bad smells this automatic detection of bad smells are done with the help of java agent development jade 2013 ieee refactoring scheduling badsmells software engineering an initial investigation into change based reconstruction of floss refactorings today it is widely accepted that if refactoring is applied in practice it is mainly interweaved with normal software development so called floss refactoring unfortunately the current state of the art is poorly equipped to mine floss refactoring from version histories mainly because they infer refactorings by comparing two snapshots of a system and making educated guesses about the precise edit operations applied in between in this paper we propose a solution that reconstructs refactorings not on snapshots of a system but using the actual changes as they are performed in an integrated development environment we compare our solution against reffinder and demonstrate that on a small yet representative program the well known video rental system our approach is more accurate in identifying occurrences of the move method and rename method refactorings 2013 ieee first class changes floss refactoring refactoring detection design based re engineering of biosynthetic gene clusters plug and play in practice synthetic biology is revolutionizing the way in which the biosphere is explored for natural products through computational genome mining thousands of biosynthetic gene clusters are being identified in microbial genomes which constitute a rich source of potential novel pharmaceuticals new methods are currently being devised to prioritize these gene clusters in terms of their potential for yielding biochemical novelty high potential gene clusters from any biological source can then be activated by refactoring their native regulatory machinery replacing it by synthetic orthogonal regulation and optimizing enzyme expression to function effectively in an industry compatible target host various part libraries and assembly technologies have recently been developed which facilitate this process 2013 elsevier ltd extracting identifying and visualisation of the content users and authors in software projects the paper proposes a method for extracting identifying and visualisation of topics code tiers users and authors in software projects in addition to standard information retrieval techniques we use ast for source code and wordnet ontology to enrich document vectors extracted from parsed code lsi to reduce its dimensionality and the swarm intelligence in the bee behaviour inspired algorithms to cluster documents contained in it we extract topics from the identified clusters and visualise them in 3d graphs developers within and outside the teams can receive and utilize visualized information from the code and apply them to their projects this new level of aggregated 3d visualization improves refactoring source code reusing implementing new features and exchanging knowledge 2013 springer verlag berlin heidelberg ast authorship bee behaviour inspired algorithms latent semantic indexing software project source code swarm intelligence topic identification and extraction visualisation wordnet ontology concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones reengineering object oriented software oo into aspect oriented software ao is a challenging task mainly when it is done by means of refactorings in the code level the reason for it is that direct transformations from oo code to ao one involve several design decisions due to syntactic and semantic differences of both paradigms to make this task more controlled and systematic we can make use of concern based refactorings supported by models this type of refactorings concentrates on transforming broader scenarios into a set of context dependent scenarios rather than specific ones as in code level refactorings in this paper we propose a set of concern based refactorings that allows design decisions to be made during the reengineering process improving the quality of the final models two of them are presented in more details in this paper an example is presented to assess the applicability of the proposed refactorings moreover we also present a case study in which ao class models created based on the refactorings are compared with ao class models obtained without the aid of these refactorings the data obtained in this case study indicated to us that the use of the proposed refactorings can improve the efficacy and productivity of a maintenance group during the process of software reengineering aspect orientation class models concern based refactorings reengineering iceis 2013 proceedings of the 15th international conference on enterprise information systems the proceedings contain 189 papers the topics discussed include fairtrace a semantic web oriented traceability solution applied to the textile traceability selecting adequate samples for approximate decision support queries a data adaptive trace abstraction approach to the prediction of business process performances bridging the gap between multidimensional business problem formulation and the implementation of multidimensional data models deriving the conceptual model of a data warehouse from information requirements predicting fault proneness of object oriented system developed with agile process using learned bayesian network concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones evolutionary learning of business process models from legacy systems using incremental process mining multi perspective enterprise modelling as a foundation of method engineering and self referential enterprise systems and log analysis of human computer interactions regarding break the glass accesses to genetic reports iceis 2013 proceedings of the 15th international conference on enterprise information systems the proceedings contain 189 papers the topics discussed include fairtrace a semantic web oriented traceability solution applied to the textile traceability selecting adequate samples for approximate decision support queries a data adaptive trace abstraction approach to the prediction of business process performances bridging the gap between multidimensional business problem formulation and the implementation of multidimensional data models deriving the conceptual model of a data warehouse from information requirements predicting fault proneness of object oriented system developed with agile process using learned bayesian network concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones evolutionary learning of business process models from legacy systems using incremental process mining multi perspective enterprise modelling as a foundation of method engineering and self referential enterprise systems and log analysis of human computer interactions regarding break the glass accesses to genetic reports iceis 2013 proceedings of the 15th international conference on enterprise information systems the proceedings contain 189 papers the topics discussed include fairtrace a semantic web oriented traceability solution applied to the textile traceability selecting adequate samples for approximate decision support queries a data adaptive trace abstraction approach to the prediction of business process performances bridging the gap between multidimensional business problem formulation and the implementation of multidimensional data models deriving the conceptual model of a data warehouse from information requirements predicting fault proneness of object oriented system developed with agile process using learned bayesian network concern based refactorings supported by class models to reengineer object oriented software into aspect oriented ones evolutionary learning of business process models from legacy systems using incremental process mining multi perspective enterprise modelling as a foundation of method engineering and self referential enterprise systems and log analysis of human computer interactions regarding break the glass accesses to genetic reports measuring architecture quality by structure plus history analysis this case study combines known software structure and revision history analysis techniques in known and new ways to predict bug related change frequency and uncover architecture related risks in an agile industrial software development project we applied a suite of structure and history measures and statistically analyzed the correlations between them we detected architecture issues by identifying outliers in the distributions of measured values and investigating the architectural significance of the associated classes we used a clustering method to identify sets of files that often change together without being structurally close together investigating whether architecture issues were among the root causes the development team confirmed that the identified clusters reflected significant architectural violations unstable key interfaces and important undocumented assumptions shared between modules the combined structure diagrams and history data justified a refactoring proposal that was accepted by the project manager and implemented 2013 ieee change history fault prediction measure software architecture structure refactoring packages of object oriented software using genetic algorithm based community detection technique refactoring is regarded as an effective way to address the software quality deterioration problem although many refactoring approaches have been proposed there is little work at the package level this paper proposes to use the community detection technique to refactor the packages of object oriented software it uses software class network to represent classes and their dependencies proposes a genetic algorithm based community detection algorithm to obtain the optimised package structures and finally provides a list of classes that should be moved by comparing the optimised package structures with the real package structures the empirical evaluation of the proposed approach has been performed in two open source java projects and the benefits of our approach are illustrated in comparison with the only one software refactoring approach at the package level viz adaptive k nearest neighbour algorithm and other five community detection algorithms used in the complex networks literature 2013 inderscience enterprises ltd community detection complex network genetic algorithm java object oriented open source package refactoring software software network where is the business logic one of the challenges in maintaining legacy systems is to be able to locate business logic in the code and isolate it for different purposes including implementing requested changes refactoring eliminating duplication unit testing and extracting business logic into a rule engine our new idea is an iterative method to identify the business logic in the code and visualize this information to gain better understanding of the logic distribution in the code as well as developing a domain specific business vocabulary this new method combines and extends several existing technologies including search aggregation and visualization we evaluated the visualization method on a large scale application and found that it yields useful results provided an appropriate vocabulary is available copyright 2013 acm business glossary business logic context based search tree map visualization obey optimal batched refactoring plan execution for class responsibility redistribution the redistribution of class responsibilities is a common reengineering practice in object oriented oo software evolution during the redistribution developers frequently construct batched refactoring plans for moving multiple methods and fields among various classes with an objective of carefully maintaining the cohesion and coupling degree of the class design executing a batched refactoring plan without introducing any objective violating side effect into the refactored code is essential however using most refactoring engines for batched refactoring plan execution introduces coupling increasing middle man bad smell in the final refactored code and therefore makes the refactoring execution suboptimal in achieving the redistribution objective this work proposes obey a methodology for optimal batched refactoring plan execution obey analyzes a batched refactoring plan identifies middle man symptoms that cause suboptimal execution and renovates the plan for optimal execution we have conducted an empirical study on three open source software projects to confirm the effectiveness of obey in a practical context 1976 2012 ieee batched refactoring execution change impact analysis class responsibility redistribution optimization reengineering identifying the move method refactoring opportunities based on evolutionary algorithm evolution is an intrinsic property of real world software which is usually accompanied by the degrading in software quality software refactoring is regarded as an effective way to improve the design of the code and many refactoring approaches have been proposed in this paper we transform the software refactoring problem as an optimisation problem and present a simple evolutionary algorithm ea to identify the move method refactorings it uses software networks at the feature i e method and attribute level namely sfn to represent features and their dependencies it uses an ea to obtain the optimised class structures in sfn it finally provides a list of methods that should be moved by comparing the optimised class structures with the real class structures the empirical evaluation of the proposed approach has been performed on one widely known refactoring example and the feasibility of our approach is illustrated copyright 2013 inderscience enterprises ltd community detection ea evolutionary algorithm refactoring software networks a scalable helmholtz solver in grapes over large scale multicore cluster this paper discusses performance optimization on the dynamical core of global numerical weather prediction model in global regional assimilation and prediction system grapes grapes is a new generation of numerical weather prediction system developed and currently used by chinese meteorology administration the computational performance of the dynamical core in grapes relies on the efficient solution of three dimensional helmholtz equations which lead to large scale and sparse linear systems formulated by the discretization in space and time we choose generalized conjugate residual gcr algorithm to solve the corresponding linear systems and further propose algorithm optimizations for large scale parallelism in two aspects i reduction of iteration number for solution and ii performance enhancement of each gcr iteration the reduction of iteration number is achieved by advanced preconditioning techniques combining block incomplete lu factorization k preconditioner over 7 diagonals of the coefficient matrix with the restricted additive schwarz method effectively the improvement for gcr iteration is to reduce the global communication operations by refactoring the gcr algorithm which decreases the communication overhead over large number of cores performance evaluation on the tianhe 1a system shows that the new preconditioning techniques reduce almost one third iterations for solving the linear systems the proposed methods can obtain 25 performance improvement on average compared with the original version of helmholtz solver in grapes and the speedup with our algorithms can reach 10 using 2048 cores compared with 256 cores copyright 2013 john wiley sons ltd additive schwarz method helmholtz equation ilu improved gcr algorithm numerical weather prediction monitor based instant software refactoring software refactoring is an effective method for improvement of software quality while software external behavior remains unchanged to facilitate software refactoring a number of tools have been proposed for code smell detection and or for automatic or semi automatic refactoring however these tools are passive and human driven thus making software refactoring dependent on developers spontaneity as a result software engineers with little experience in software refactoring might miss a number of potential refactorings or may conduct refactorings later than expected few refactorings might result in poor software quality and delayed refactorings may incur higher refactoring cost to this end we propose a monitor based instant refactoring framework to drive inexperienced software engineers to conduct more refactorings promptly changes in the source code are instantly analyzed by a monitor running in the background if these changes have the potential to introduce code smells i e signs of potential problems in the code that might require refactorings the monitor invokes corresponding smell detection tools and warns developers to resolve detected smells promptly feedback from developers i e whether detected smells have been acknowledged and resolved is consequently used to optimize smell detection algorithms the proposed framework has been implemented evaluated and compared with the traditional human driven refactoring tools evaluation results suggest that the proposed framework could drive inexperienced engineers to resolve more code smells by an increase of 140 percent promptly the average lifespan of resolved smells was reduced by 92 percent results also suggest that the proposed framework could help developers to avoid similar code smells through timely warnings at the early stages of software development thus reducing the total number of code smells by 51 percent 1976 2012 ieee code smell detection instant refactoring monitor software refactoring quantifying the effect of code smells on maintenance effort context code smells are assumed to indicate bad design that leads to less maintainable code however this assumption has not been investigated in controlled studies with professional software developers aim this paper investigates the relationship between code smells and maintenance effort method six developers were hired to perform three maintenance tasks each on four functionally equivalent java systems originally implemented by different companies each developer spent three to four weeks in total they modified 298 java files in the four systems an eclipse ide plug in measured the exact amount of time a developer spent maintaining each file regression analysis was used to explain the effort using file properties including the number of smells result none of the 12 investigated smells was significantly associated with increased effort after we adjusted for file size and the number of changes refused bequest was significantly associated with decreased effort file size and the number of changes explained almost all of the modeled variation in effort conclusion the effects of the 12 smells on maintenance effort were limited to reduce maintenance effort a focus on reducing code size and the work practices that limit the number of changes may be more beneficial than refactoring code smells 1976 2012 ieee code churn maintainability object oriented design product metrics a systematic mapping study on software product line evolution from legacy system reengineering to product line refactoring software product lines spls are used in industry to develop families of similar software systems legacy systems either highly configurable or with a story of versions and local variations are potential candidates for reconfiguration as spls using reengineering techniques existing spls can also be restructured using specific refactorings to improve their internal quality although many contributions including industrial experiences can be found in the literature we lack a global vision covering the whole life cycle of an evolving product line this study aims to survey existing research on the reengineering of legacy systems into spls and the refactoring of existing spls in order to identify proven approaches and pending challenges for future research in both subfields we launched a systematic mapping study to find as much literature as possible covering the diverse terms involved in the search string restructuring refactoring reengineering etc always connected with spls and filtering the papers using relevance criteria the 74 papers selected were classified with respect to several dimensions main focus research and contribution type academic or industrial validation if included etc we classified the research approaches and analyzed their feasibility for use in industry the results of the study indicate that the initial works focused on the adaptation of generic reengineering processes to spl extraction starting from that foundation several trends have been detected in recent research the integrated or guided reengineering of typically object oriented legacy code and requirements specific aspect oriented or feature oriented refactoring into spls and more recently refactoring for the evolution of existing product lines a majority of papers include academic or industrial case studies though only a few are based on quantitative data the degree of maturity of both subfields is different industry examples for the reengineering of the legacy system subfield are abundant although more evaluation research is needed to provide better evidence for adoption in industry product line evolution through refactoring is an emerging topic with some pending challenges although it has recently received some attention the theoretical foundation is rather limited in this subfield and should be addressed in the near future to sum up the main contributions of this work are the classification of research approaches as well as the analysis of remaining challenges open issues and research opportunities 2012 elsevier b v all rights reserved evolution legacy system reengineering refactoring software product line detecting refactored clones the availability of automated refactoring tools in modern development environments allows programmers to refactor their code with ease such tools however enable developers to inadvertently create code clones that quickly diverge in form but not in meaning furthermore in the hands of those looking to confuse plagiarism detection tools automated refactoring may be abused to avoid discovery of copied code we present cider an algorithm that can detect code clones regardless of various refactorings that may have been applied to some of the copies but not to others most significant is the ability to discover interprocedural clones where parts of one copy have been extracted to separate methods we evaluated cider on several open source java projects attempting to detect interprocedural clones between successive versions of each project interprocedural clones were detected in all evaluated projects demonstrating the pervasive nature of the problem compared to a manual assessment cider performed well in terms of both recall and precision 2013 springer verlag berlin heidelberg trading obliviousness for modularity with cooperative aspect oriented programming the potential of aspect oriented programming to adequately capture crosscutting concerns has yet to be fully realized for example authors have detailed significant challenges in creating reusable aspect component libraries one proposed solution is to introduce explicit join points ejps to increase modularity by reducing obliviousness enabling a cooperative aspect oriented programming co aop methodology where base code and aspects synergistically collaborate this article explores the trade offs between obliviousness and modularity we briefly introduce ejps and co aop and hypothesize how to balance obliviousness and modularity using co aop we build upon a prior empirical study to refactor three real life java applications to implement the exception handling concern using three distinct strategies 1 using fully oblivious aspects in aspectj 2 using ejps in a fully explicit fashion and 3 using ejps while following the co aop methodology we study other crosscutting concerns by refactoring a fourth application jhotdraw the differences in terms of common code metrics are analyzed and the impact on modularity is assessed using design structure matrices results indicate that the co aop methodology can in many cases significantly improve code quality attributes versus fully oblivious or fully explicit approaches we conclude with guiding principles on the proper use of ejps within the co aop methodology 2013 acm aspect oriented programming design structure matrix explicit join points modularity obliviousness sealion an eclipse based ide for answer set programming with advanced debugging support in this paper we present sealion an integrated development environment ide for answer set programming asp sealion provides source code editors for the languages of gringo and dlv and offers popular amenities like syntax highlighting syntax checking code completion visual program outline and refactoring functionality the tool has been realised in the context of a research project whose goal is the development of techniques to support the practical coding process of answer set programs in this respect sealion is the first ide for asp that provides debugging features that work for real world answer set programs and supports the rich languages of modern answer set solvers indeed sealion implements a stepping based debugging approach that allows the developer to quickly track down programming errors by simply following his or her intuitions on the intended semantics besides that sealion supports asp development using model driven engineering techniques including domain modelling with extended uml class diagrams and visualisation of answer sets in corresponding instance diagrams moreover customised visualisation as well as visual editing of answer sets is realised by the kara plugin of sealion further implemented features are a documentation generator based on the lana annotation language support for external solvers and interoperability with external tools sealion comes as a plugin of the popular eclipse platform and provides interfaces for future extensions of the ide copyright 2013 paula andra busoniu johannes oetsch jörg pührer peter skočovský and hans tompits discovering unexpected information using a building energy visualization tool building energy consumption is an important problem in construction field old buildings are gap of energy and they need to be refactored energy footprint of buildings needs to be reduced new buildings are designed to be suitable with energy eficiency paradigm to improve energy eficiency building management systems bms are used bms are it information technology systems composed by a rules engine and a database connected to sensors unfortunately bms are only monitoring systems they cannot predict and mine eficiently building information rider project has emerged from this observation this project is conducted by several french companies and universities ibm at montpellier france leads the project the main goal of this project is to create a smart and scalable bms this new kind of bms will be able to dig into data and predict events this it system is based on component paradigm and the core can be extended with external components some of them are developed during the project data mining building generation model and visualization all of these components will provide new features to improve rules used by the core in this paper we will focus on the visualization component this visualization use a volume rendering method based on sensors data interpolation and a correlation method to create new views we will present the visualization method used and which rules can be provided by this component 2013 spie is t analysis techniques data visualization volume dynamic profiling based approach to identifying cost effective refactorings context object oriented software undergoes continuous changes changes often made without consideration of the software s overall structure and design rationale hence over time the design quality of the software degrades causing software aging or software decay refactoring offers a means of restructuring software design to improve maintainability in practice efforts to invest in refactoring are restricted therefore the problem calls for a method for identifying cost effective refactorings that efficiently improve maintainability cost effectiveness of applied refactorings can be explained as maintainability improvement over invested refactoring effort cost for the system the more cost effective refactorings are applied the greater maintainability would be improved there have been several studies of supporting the arguments that changes are more prone to occur in the pieces of codes more frequently utilized by users hence applying refactorings in these parts would fast improve maintainability of software for this reason dynamic information is needed for identifying the entities involved in given scenarios functions of a system and within these entities refactoring candidates need to be extracted objective this paper provides an automated approach to identifying cost effective refactorings using dynamic information in object oriented software method to perform cost effective refactoring refactoring candidates are extracted in a way that reduces dependencies these are referred to as the dynamic information the dynamic profiling technique is used to obtain the dependencies of entities based on dynamic method calls based on those dynamic dependencies refactoring candidate extraction rules are defined and a maintainability evaluation function is established then refactoring candidates are extracted and assessed using the defined rules and the evaluation function respectively the best refactoring i e that which most improves maintainability is selected from among refactoring candidates then refactoring candidate extraction and assessment are re performed to select the next refactoring and the refactoring identification process is iterated until no more refactoring candidates for improving maintainability are found results we evaluate our proposed approach in three open source projects the first results show that dynamic information is helpful in identifying cost effective refactorings that fast improve maintainability and considering dynamic information in addition to static information provides even more opportunities to identify cost effective refactorings the second results show that dynamic information is helpful in extracting refactoring candidates in the classes where real changes had occurred in addition the results also offer the promising support for the contention that using dynamic information helps to extracting refactoring candidates from highly ranked frequently changed classes conclusion our proposed approach helps to identify cost effective refactorings and supports an automated refactoring identification process 2012 elsevier b v all rights reserved cost effective refactoring dynamic method call dynamic profiling maintainability improvement refactoring cost refactoring identification complete high dimensional inverse characterization of fractal surfaces and volumes in the present paper we are describing a methodology for the determination of the complete set of parameters associated with the weierstrass mandelbrot w m function that can describe a fractal scalar field distribution defined by measured or computed data distributed on a surface or in a volume our effort is motivated not only by the need for accurate fractal surface and volume reconstruction but also by the need to be able to describe analytically a scalar field quantity distribution on a surface or in a volume that corresponds to various material properties distributions for engineering and science applications our method involves utilizing a refactoring of the w m function that permits defining the characterization problem as a high dimensional inverse problem solved by singular value decomposition for the so called phases of the function coupled with this process is a second level exhaustive search that enables the determination of the density of the frequencies involved in defining the trigonometric functions participating in the definition of the w m function numerical applications of the proposed method on both synthetic and actual surface and volume data validate the efficiency and the accuracy of the proposed approach this approach constitutes a radical departure from the traditional fractal dimension characterization studies and opens the road for a very large number of applications copyright 2013 by asme refactoring software packages via community detection in complex software networks an intrinsic property of software in a real world environment is its need to evolve which is usually accompanied by the increase of software complexity and deterioration of software quality making software maintenance a tough problem refactoring is regarded as an effective way to address this problem many refactoring approaches at the method and class level have been proposed but the research on software refactoring at the package level is very little this paper presents a novel approach to refactor the package structures of object oriented software it uses software networks to represent classes and their dependencies it proposes a constrained community detection algorithm to obtain the optimized community structures in software networks which also correspond to the optimized package structures and it finally provides a list of classes as refactoring candidates by comparing the optimized package structures with the real package structures the empirical evaluation of the proposed approach has been performed in two open source java projects and the benefits of our approach are illustrated in comparison with the other three approaches 2013 institute of automation chinese academy of sciences and springer verlag berlin heidelberg community detection complex networks package refactoring software refactoring delta oriented software product lines delta oriented programming dop is an implementation approach to develop software product lines spl deltaoriented spls evolve over time due to new or changed requirements and need to be maintained to retain their value refactorings have been proposed as behavior preserving program transformations that improve the design and structure of object oriented software systems however there is a lack of refactoring support for software product lines since refactoring of spls is more complex than of single systems for refactoring spls we have to preserve the behavior of probably thousands of programs instead of only one in this paper we address the refactoring of software product lines by presenting a catalogue of refactorings for delta oriented spls additionally we propose code smells to guide developers to potential refactoring opportunities we show how code smells can aid the identification of spl refactorings and how these refactorings improve the evolvability and maintainability of delta oriented spls copyright 2013 acm delta oriented programming evolution refactoring software product lines aoasia 2013 proceedings of the 8th international workshop on advanced modularization techniques aoasia pacific the proceedings contain 7 papers the topics discussed include an aspect oriented cpu resource reservation framework integrated in mde tools aspect jquery an aspect oriented framework for jquery modularizing tenant specific schema customization in saas applications towards generating templates of method body based on method name and related identifiers interaction awareness for aspect refactoring hierarchical concern based pointcuts and towards aspect oriented state machine language for embedded software quality of merge refactorings for product lines in this paper we consider the problem of refactoring related software products specified in uml into annotative product line representations our approach relies on identifying commonalities and variabilities in existing products and further merging those into product line representations which reduce duplications and facilitate reuse varying merge strategies can lead to producing several semantically correct yet syntactically different refactoring results depending on the goal of the refactoring one result can be preferred to another we thus propose to capture the goal using a syntactic quality function and use that function to guide the merge strategy we define and implement a quality based merge refactoring framework for uml models containing class and statechart diagrams and report on our experience applying it on three case studies 2013 springer verlag identification of generalization refactoring opportunities generalization refactoring helps relate classes and share functions including both interfaces and implementation by inheritance to apply generalization refactoring developers should first identify potential generalization refactoring opportunities i e software entities that might benefit from generalization refactoring for non trivial software systems manual identification of these opportunities is challenging and time consuming however to the best of our knowledge no existing tools have been specif ically designed for this task as a result people have to identify these opportunities manually or with the help of tools designed for other purposes e g clone detectors to this end we propose a tool genreferee generalization referee to identify potential refactoring opportunities according to conceptual relationship implementation similarity structural correspondence and inheritance hierarchies it was first calibrated on two non trivial open source applications and then evaluated on another three evaluation results suggest that the proposed approach is effective and efficient 2012 springer science business media llc generalization refactoring opportunity identification software maintenance software quality software refactoring tool support qualitative analysis for the impact of accounting for special methods in object oriented class cohesion measurement class cohesion is a key object oriented software quality attribute it refers to the degree of relatedness of class attributes and methods several class cohesion metrics are proposed in the literature however the impact of considering the special methods i e constructors destructors and access and delegation methods in cohesion calculation is not thoroughly theoretically studied for most of the existing cohesion metrics an incorrect determination of whether to include or exclude the special methods in cohesion measurement can lead to improper refactoring decisions according to the misleading class cohesion values that are obtained in this paper we qualitatively analyze the impact of including or excluding the special methods in cohesion measurement on the values that are obtained by applying 19 popular class cohesion metrics the study is based on analyzing the definitions and formulas that are proposed for the metrics the results show that including excluding special methods has a considerable effect on the cohesion values that are obtained and that this effect varies from one metric to another the study shows the importance of considering the types of methods that must be accounted for when proposing a cohesion metric 2013 academy publisher class cohesion class quality cohesion metric object oriented design special methods objective evaluation of software architectures in driver assistance systems methods quality model metrics this paper describes methods and the obtained results for objective evaluation of software architectures in the automotive embedded domain software architecture is the key factor for influencing and fulfilling non functional requirements that are addressed to a software system among others scalability extensibility and portability are to be mentioned as major criteria until today however there is no approach that allows evaluating and measuring the quality of such software architectures objectively and quantitatively the approach described here tries to close this gap and offers software architects methods and tools to be applied automatically to any existing architecture draft measuring an objective quality value initially a quality model is developed which consists of several quality characteristics and quality attributes which are highly adapted and specialized to the specific needs of the automotive embedded software domain after the identification of relevant quality attributes eight objective architecture metrics are developed and presented the whole methodology is fully integrable into existing development processes the suggested steps and artifacts can be added as optional upgrade for a better understanding of the surrounding environment the current development process and necessary extensions are also explained all metrics have been implemented in a fully functioning prototypical tool which can be operated via a graphical user interface gui on any java compliant system without further requirements the user can freely configure which metrics shall be applied and how they are weighted to do an individual evaluation according to the software s specific needs or requirements to prove its benefit for automotive applications and long term establishment in the software development process the approach is evaluated this is done in two consecutive steps firstly the general functioning and applicability is approved by using the metrics for several small case studies which also helped getting to know the metrics better in detail to create an initial balancing and weighting secondly the approach was applied to a complex and real practical example out of the driver assistance domain the whole longitudinal dynamics software architecture of bmw s driver assistance systems was refactored using the metrics to monitor the success and keep up a goal oriented iterative and incremental procedure 2011 springer verlag automotive embedded software driver assistance systems objective metrics software architecture software quality suggesting extract class refactoring opportunities by measuring strength of method interactions 2013 ieee for improving the modularity of a large software system metrics can be valuable to help finding refactoring opportunities for classes we define a novel metric that is intended to suggest how closely connected are the elements of a class the metric characterises the strength of the coupling between methods of a class based on invocations and the size of the parameters involved as well as attribute accesses the assessment of the strength of interactions turns out to be valuable in providing an indication on the possible changes that classes need to become more modular and prone to be reused according to the computed metric and the assessment of system wide relationships between classes we are able to suggest extract class refactoring opportunities the capability of the proposed approach to evaluate object oriented systems is demonstrated by analysing a large software system metrics modularity refactoring a clustering method for pruning false positive of clonde code detection 2013 ieee there are some false positives when detect syntax similar cloned code with clone code technology based on token in this paper we propose a novel algorithm to automatically prune false positives of clone code detection by performing clustering with different attribute and weights first closely related statements are grouped into a cluster by performing clustering second compare the hash values of the statements in the two clusters to prune false positives the experimental results show that our method can effectively prune clone code false positives caused by switching the orders of same structure statments it not only improves the accuracy of cloned code detection and cloned code related defects detection but also contribute to the following study of cloned code refactoring cloned code clustering false positives refactoring style identifying extract method opportunities based on variable references copyright 2013 by knowledge systems institute graduate school long methods are usually difficult to read and comprehend due to the length and complexity of the code as a result maintenance can be time consuming and costly one strategy to lower overall cost of software development for large systems is to produce smaller and less complex methods through method refactoring this paper presents a new technique to automate the selection process of program fragments for refactoring the soundness of this technique has been demonstrated through experiments on several different software systems long method defects can effectively be resolved by extracting code fragments identified with the support of a tool we have developed extract method refactoring long method defects placement tree sql schema comparer support of multi language refactoring with relational databases refactoring is a method to change a source code s structure without modifying its semantics and was first introduced for object oriented code since then refactorings were defined for relational databases too but database refactorings must be treated differently because a database schema s structure defines semantics used by other applications to access the data in the schema thus many database refactorings may break interaction with other applications if not treated appropriately we discuss problems of database refactoring in regard to java code and present sql schema comparer a library to detect refactorings of database schemes the sql schema comparer library is our first step to more advanced tools supporting developers in their database refactoring efforts 2013 ieee measuring the structural similarity between source code entities copyright 2013 by knowledge systems institute graduate school similarity coefficients are widely used in software engineering for several purposes such as identification of refactoring opportunities and system remodularizations although the literature provides several similarity coefficients that vary on the computing strategy there is a tendency among researchers to make habitual use of certain coefficients that others in their field are using consequently some approaches might be using an inadequate coefficient for their purpose in this paper we conduct a quantitative study that compares 18 coefficients to identify which one is the most appropriate in determining where a class should be located our evaluation contemplates 111 open source systems from qualitas corpus which totalizes more than 70 000 classes as a result we observed that jaccard one of the most used coefficients in our area has not presented the best results while jaccard correctly indicated the suitable module to 22 of the classes other coefficients were able to indicate 60 a catalog of bad smells in design by contract methodologies with java modeling language bad smells are usually related to program source code arising from bad design and programming practices refactoring activities are often motivated by the detection of bad smells with the increasing adoption of design by contract dbc methodologies in formal software development evidence of bad design practices can similarly be found in programs that combine actual production code with interface contracts these contracts can be written in languages such as the java modeling language jml an extension to the java syntax this paper presents a catalog of bad smells that appear during dbc practice considering jml as the language for specifying contracts these smells are described over jml constructs although several can appear in other dbc languages the catalog contains 6 dbc smells we evaluate the recurrence of dbc smells in two ways first by describing a small study with graduate student projects and second by counting occurrences of smells in contracts from the jml models application programming interface api this api contains classes with more than 1 600 lines in contracts along with the documented smells suggestions are provided for minimizing the impact or even removing a bad smell it is believed that initiatives towards the cataloging of bad smells are useful for establishing good design practices in dbc 2013 the korean institute of information scientists and engineers bad smells design by contract java modeling language refactoring how to extract differences from similar programs a cohesion metric approach merging similar programs is a promising solution to improve the maintainability of source code before merging programs any syntactic difference has to be extracted as a new method however it is difficult for a developer to identify and extract differences from programs appropriately because he she has to consider not only syntactic and semantic correctness but also the modularity of the programs after merging in this paper we propose a slice based cohesion metrics approach to suggesting the extractions of differences from similar java methods this approach identifies syntactic differences from two methods and then suggests sets of cohesive regions including those differences the case study shows that the proposed approach can suggest refactorings that not only merge two methods but also increase the cohesiveness 2013 ieee supporting requirements traceability through refactoring modern traceability tools employ information retrieval ir methods to generate candidate traceability links these methods track textual signs embedded in the system to establish relationships between software artifacts however as software systems evolve new and inconsistent terminology finds its way into the system s taxonomy thus corrupting its lexical structure and distorting its traceability tracks in this paper we argue that the distorted lexical tracks of the system can be systematically re established through refactoring a set of behavior preserving transformations for keeping the system quality under control during evolution to test this novel hypothesis we investigate the effect of integrating various types of refactoring on the performance of requirements to code automated tracing methods in particular we identify the problems of missing misplaced and duplicated signs in software artifacts and then examine to what extent refactorings that restore move and remove textual information can overcome these problems respectively we conduct our experimental analysis using three datasets from different application domains results show that restoring textual information in the system has a positive impact on tracing in contrast refactorings that remove redundant information impact tracing negatively refactorings that move information among the system modules are found to have no significant effect our findings address several issues related to code and requirements evolution as well as refactoring as a mechanism to enhance the practicality of automated tracing tools 2013 ieee information retrieval refactoring traceability research on the merging of feature models feature models provide an effective way to organize and reuse software requirements in a specific domain constructing a feature model needs a systematic analysis of as many applications as possible in a domain to identify commonality variability and dependencies among requirements with the increasing complexity of domains the scale of feature models can be extremely large and the construction of large feature models is an overwhelming task for human that computer aided automation is needed a feasible way is to merge existing feature models into a large one and human developers only need to do some refactoring work in this paper we survey six methods of merging feature models we propose a conceptual framework first and then analyze and compare the six methods finally we identify three problems in existing research and propose possible ideas to handle these problems algorithm feature model model merge software reuse information and knowledge retrieval within software projects and their graphical representation for collaborative programming this paper proposes information and knowledge mining in the source code of medium and large enterprise projects our methods try to recognize structures and types of source code identify authors and users to enhance collaborative programming and support knowledge management in software companies developers within and outside the teams can receive and utilize visualized information from the code and apply it to their projects this new level of aggregated 3d visualization improves refactoring source code reusing implementing new features and exchanging knowledge authors code tagging collaborative programming information and knowledge mining knowledge management recognition source code type users visualization refactoring boundary we argue that the limit of the propagation of the heap effects of a source code modification is determined by the aliasing structure of method parameters in a trace of the method calls that cross a boundary which partitions the heap further that this aliasing structure is sufficient to uniquely determine the state of the part of the heap which has not been affected and we give a definition of what it means for a part of the heap to be unaffected by a source code modification this can be used to determine the correctness of a refactoring object oriented refactoring on proving the concept of an ontology aided software refactoring tool through years more and more software is produced the quality of software architecture however has an important role in systems exploitation as it determines the maintainability and extensibility of an application recently more emphasis is put on quality of the design so that new features can be added with ease to preserve code readability and extensibility software architecture must be refactored from time to time to cope with the modifications nevertheless reviewing the whole source code is time consuming and does not return any surplus thus it is often skipped causing the software architecture to decay in time over several modifications and making it harder to add new functionality in the future an automated method of recognizing bad code would help to solve some of the issues in this article the authors propose a concept of a refactoring tool which uses ontology to find smelly design and tackle the aforementioned problems several aspects of the tool are discussed how it works and how it can be used to improve the software architecture thus augment the quality 2013 the authors and ios press all rights reserved ontology software architecture improvement software refactoring a field study of refactoring challenges and benefits it is widely believed that refactoring improves software quality and developer productivity however few empirical studies quantitatively assess refactoring benefits or investigate developers perception towards these benefits this paper presents a field study of refactoring benefits and challenges at microsoft through three complementary study methods a survey semi structured interviews with professional software engineers and quantitative analysis of version history data our survey finds that the refactoring definition in practice is not confined to a rigorous definition of semantics preserving code transformations and that developers perceive that refactoring involves substantial cost and risks we also report on interviews with a designated refactoring team that has led a multi year centralized effort on refactoring windows the quantitative analysis of windows 7 version history finds that the binary modules refactored by this team experienced significant reduction in the number of inter module dependencies and post release defects indicating a visible benefit of refactoring 2012 acm churn component dependencies defects empirical study refactoring software evolution detecting inconsistent names of source code using nlp software developers use refactoring in order to improve quality of source code refactoring is a disciplined technique for restructuring an existing body of code without changing its external behavior 3 for example extract method is the one of the refactoring approaches to improving readability of the large scale method by splitting them into several small scale methods in refactoring code smell indicates any symptom in the source code that possibly causes a deeper problem although inconsistent names of source code elements as one of the code smells are crucial it is hardly achieved by going through the whole source code furthermore it generally can be handled by several developers that understand the source code and also is easy to pass without checking because it does not affect software execution 2012 springer verlag quantifying quality of software design to measure the impact of refactoring software design plays a vital role in a software system a flexible maintainable extensible and re usable software design enables easier integration of new requirements in the current era of software development refactoring is used periodically to fine tune a software design refactoring limits technical debt and improves overall quality of a software design however providing a quantitative measure to estimate the impact of a refactoring exercise on a software design is a non trivial challenge in this paper we present a method to estimate the quality extendibility and flexibility aspects of a software design the method proposes an index namely software design quality index sdqi to estimate the quality of a software design the index can be employed to measure the impact of a refactoring exercise on software design moreover the method can be used to benchmark and compare software design quality of different software systems 2012 ieee refactoring software design quality software design quality index sdqi code smell detecting tool and code smell structure bug relationship this paper proposes an approach for detecting the socalled bad smells in software known as code smell in considering software bad smells object oriented software metrics were used to detect the source code whereby eclipse plugins were developed for detecting in which location of java source code the bad smell appeared so that software refactoring could then take place the detected source code was classified into 7 types large class long method parallel inheritance hierarchy long parameter list lazy class switch statement and data class this work conducted analysis by using 323 java classes to ascertain the relationship between the code smell and structural defects of software by using the data mining techniques of naive bayes and association rules the result of the naive bayes test showed that the lazy class caused structural defects in dls de and se also data class caused structural defects in uwf de and se while long method large class data class and switch statement caused structural defects in uwf and se finally parallel inheritance hierarchy caused structural defects in se however long parameter list caused no structural defects whatsoever the results of the association rules test found that the lazy class code smell caused structural defects in dls and de which corresponded to the results of the naive bayes test 2012 ieee code smell refactoring software metric structural bugs ecoop 2012 object oriented programming 26th european conference proceedings the proceedings contain 30 papers the topics discussed include is it dangerous to use version control histories to study source code evolution evaluating the design of the r language objects and functions for data analysis mcsaf a static analysis framework for matlab multiple aggregate entry points for ownership types inference and checking of object ownership object initialization in x10 lock inference in the presence of large libraries an analysis of the mozilla jetpack extension framework smaller footprint for java collections enhancing javascript with transactions javascript as an embedded dsl correlation tracking for points to analysis of javascript constraint based refactoring with foresight magda a new language for modularity and marco safe expressive macros for any language parameter based refactoring and the relationship with fan in fan out coupling in this paper we analyze the effect of particular refactorings on class coupling for different aggregate releases of four object oriented open source os java software systems azureus jtopen jedit and tomcat as representative of general java os systems specifically the add parameter to a method and remove parameter from a method refactorings as defined according to fowler may in uence class coupling changing fan in and fan out of classes they are applied to we investi gate both qualitatively and quantitatively using a statistical approach the global effect of the application of such refactorings providing best fitting statistical distributions able to describe the changes in fan in and fan out couplings results show a net tendency of developers to apply such refactorings to classes with relatively high fan in and fan out and a persistence of the same statistical distribution for fan in and fan out before and after refactoring finally we provide a detailed analysis of the best fitting parameters and of their changes when refactoring occurs which may be useful for estimating the effect of refactoring on coupling before it is applied since refactoring requires time and effort these estimates may help in determining costs and benefits jot 2011 coupling fan in fan out metric distribution refactoring