a semantic web based approach for design pattern detection from source code design patterns provide experience reusability and increase quality of object oriented designs knowing which design patterns are implemented in a software is important in comprehending maintaining and refactoring its design however despite the interest in using design patterns traditionally their usage is not explicitly documented therefore a method is required to reveal this information from some artifacts of the systems e g source codes models and executables in this paper an approach is proposed which uses the semantic web technologies for automatically detecting design patterns from java source code it is based on the semantic data model as the internal representation and on sparql query execution as the analysis mechanism experimental evaluations demonstrate that this approach is both feasible and effective and it reduces the complexity of detecting design patterns to creating a set of sparql queries 2012 ieee design pattern ontology semantic web software analysis source code what kind of and how clones are refactored a case study of three oss projects although code clone i e a code fragment that has similar or identical fragments is regarded as one of the most typical bad smells tools for identification of clone refactoring i e merge code clones into a single method are not commonly used to promote the development of more widely used tools for clone refactoring we present an investigation of actual clone refactorings performed in the developments of three open source software oss projects from the results we confirmed that clone refactorings are mostly archived by two refactoring patterns and token sequences of refactored code clones are suggested to have a difference of 50 2012 acm code clone levenshtein distance refactoring using dynamic analysis to discover polynomial and array invariants dynamic invariant analysis identifies likely properties over variables from observed program traces these properties can aid programmers in refactoring documenting and debugging tasks by making dynamic patterns visible statically two useful forms of invariants involve relations among polynomials over program variables and relations among array variables current dynamic analysis methods support such invariants in only very limited forms we combine mathematical techniques that have not previously been applied to this problem namely equation solving polyhedra construction and smt solving to bring new capabilities to dynamic invariant detection using these methods we show how to find equalities and inequalities among nonlinear polynomials over program variables and linear relations among array variables of multiple dimensions preliminary experiments on 24 mathematical algorithms and an implementation of aes encryption provide evidence that the approach is effective at finding these invariants 2012 ieee array invariants dynamic analysis invariant generation nonlinear invariants program analysis use disuse and misuse of automated refactorings though refactoring tools have been available for more than a decade research has shown that programmers underutilize such tools however little is known about why programmers do not take advantage of these tools we have conducted a field study on programmers in their natural settings working on their code as a result we collected a set of interaction data from about 1268 hours of programming using our minimally intrusive data collectors our quantitative data show that programmers prefer lightweight methods of invoking refactorings usually perform small changes using the refactoring tool proceed with an automated refactoring even when it may change the behavior of the program and rarely preview the automated refactorings we also interviewed nine of our participants to provide deeper insight about the patterns that we observed in the behavioral data we found that programmers use predictable automated refactorings even if they have rare bugs or change the behavior of the program this paper reports some of the factors that affect the use of automated refactorings such as invocation method awareness naming trust and predictability and the major mismatches between programmers expectations and automated refactorings the results of this work contribute to producing more effective tools for refactoring complex software 2012 ieee human computer interaction human factors programming environments software engineering software maintenance user interfaces reducing the class coupling of legacy code by a metrics based relocation of class members with the rapid growth of the complexity of software systems the problem of integrating and maintaining legacy software is more relevant than ever to overcome this problem many methods for refactoring legacy code have already been proposed such as renaming classes or extracting interfaces to perform a real modularization methods have to be moved between classes however moving a single method is often not possible due to code dependencies in this article we present an approach to modularize legacy software by moving multiple related class members it is shown how to identify groups of class members with similar concerns we present two different code patterns that the related members and their dependent classes must match to allow a relocation of the related members we also demonstrate how our pattern based approach for automated modularization of legacy software can be applied to two open source projects 2012 springer verlag class decoupling code metrics legacy software pattern based code refactoring a methodology to assess the impact of design patterns on software quality context software quality is considered to be one of the most important concerns of software production teams additionally design patterns are documented solutions to common design problems that are expected to enhance software quality until now the results on the effect of design patterns on software quality are controversial aims this study aims to propose a methodology for comparing design patterns to alternative designs with an analytical method additionally the study illustrates the methodology by comparing three design patterns with two alternative solutions with respect to several quality attributes method the paper introduces a theoretical analytical methodology to compare sets of canonical solutions to design problems the study is theoretical in the sense that the solutions are disconnected from real systems even though they stem from concrete problems the study is analytical in the sense that the solutions are compared based on their possible numbers of classes and on equations representing the values of the various structural quality attributes in function of these numbers of classes the exploratory designs have been produced by studying the literature by investigating open source projects and by using design patterns in addition to that we have created a tool that helps practitioners in choosing the optimal design solution according to their special needs results the results of our research suggest that the decision of applying a design pattern is usually a trade off because patterns are not universally good or bad patterns typically improve certain aspects of software quality while they might weaken some other conclusions concluding the proposed methodology is applicable for comparing patterns and alternative designs and highlights existing threshold that when surpassed the design pattern is getting more or less beneficial than the alternative design more specifically the identification of such thresholds can become very useful for decision making during system design and refactoring 2011 elsevier b v all rights reserved design patterns object oriented metrics quality structural quality using software quality attributes to classify refactoring to patterns refactoring to patterns allows software designers to safely move their designs towards specific design patterns by applying multiple low level refactorings there are many different refactoring to pattern techniques each with a particular purpose and a varying effect on software quality attributes thus far software designers do not have a clear means to choose refactoring to pattern techniques to improve certain quality attributes this paper takes the first step towards a classification of refactoring to pattern techniques based on their measurable effect on software quality attributes this classification helps software designers in selecting the appropriate refactoring to pattern techniques that will improve the quality of their design based on their design objectives it also enables them to predict the quality drift caused by using specific refactoring to pattern techniques 2012 academy publisher refactoring to patterns software metrics software quality on the use of genetic programming for automated refactoring and the introduction of design patterns maintaining an object oriented design for a piece of software is a difficult time consuming task prior approaches to automated design refactoring have focused on making small iterative changes to a given software design however such approaches do not take advantage of composition of design changes thus limiting the richness of the refactoring strategies that they can generate in order to address this problem this paper introduces an approach that supports composition of design changes and makes the introduction of design patterns a primary goal of the refactoring process the proposed approach uses genetic programming and software engineering metrics to identify the most suitable set of refactorings to apply to a software design we illustrate the efficacy of this approach by applying it to a large set of published models as well as a real world case study copyright 2010 acm design patterns evolutionary computation intelligent search object oriented design refactoring search based software engineering software metrics barriers to systematic model transformation testing introduction model driven engineering mde techniques support extensive use of models in order to manage the increasing complexity of software systems appropriate abstractions of software system elements can ease reasoning and understanding and thus limit the risk of errors in large systems automatic model transformations play a critical role in mde since they automate complex tedious error prone and recurrent software development tasks airbus uses automatic code synthesis from scade models to generate the code for embedded controllers in the airbus a380 commercial tools for model transformations exist objecteering and together from borland are tools that can automatically add design patterns in a uml class model esterel technologies have a tool for automatic code synthesis for safety critical systems other examples of transformations are refinement of a design model by adding details pertaining to a particular target platform refactoring a model by changing its structure to enhance design quality or reverse engineering code to obtain an abstract model these software development tasks are critical and thus the model transformations that automate them must be validated a fault in a transformation can introduce a fault in the transformed model which if undetected and not removed can propagate to other models in successive development steps as a fault propagates across transformations it becomes more difficult to detect and isolate since model transformations are meant to be reused faults present in them may result in many faulty models model transformations constitute a class of programs with unique characteristics that make testing them challenging the complexity of input and output data lack of model management tools and the heterogeneity of transformation languages pose special problems to testers of transformations in this paper we identify current model transformation characteristics that contribute to the difficulty of systematically testing transformations we present promising solutions and propose possible ways to overcome these barriers 2010 acm system evolution at the attribute level an empirical study of three java oss and their refactorings in this paper we focus on the net changes in attributes across versions of oss and use net class change data class additions and deletions as well as refactoring data from a previous study to inform our understanding of how those three systems evolved as they did while the majority of new attributes were added at levels 1 and 2 of the inheritance these patterns were not consistent the research question addresses the evolutionary relationship between classes and attributes as well as the connection between those changes and refactorings although some evidence of attributes following patterns conformant with class additions was found we also identified occurrences of attributes being added unilaterally a strong correspondence was also found between attribute addition and the refactoring data finally we explore features of a fourth system with seven inheritance levels for similar characteristics attribute evolution oo refactoring pro php refactoring many businesses and organizations depend on older high value php software that risks abandonment because it is impossible to maintain the reasons for this may be that the software is not well designed there is only one developer the one who created the system who can develop it because he didn t use common design patterns and documentation or the code is procedural not object oriented with this book you ll learn to identify problem code and refactor it to create more effective applications using test driven design copyright 2010 by francesco trucchia and jacopo romei all rights reserved an empirical study of java system evolution at the method level exploring the evolution of systems can provide valuable insights into the traits of developers and inform our understanding of system dynamics while we usually expect an objectoriented system to grow in classes as it ages what are not so obvious are patterns in the evolution of specific class features in this paper we explore empirical traits of four java open source systems using data extracted by two tools and informed by a previous study of inheritance depth evolution we analyse evolution at a lower level of granularity given by the methods of a class on an incremental change per version basis rather than absolute class size per version evolution at a finer grain can identify trends not possible on a class wide basis the approach thus represents a white box view of the investigation of evolutionary forces our analysis also allowed direct comparison with a set of low level refactorings extracted by an automated tool in a previous study scrutiny of trends in methods was further motivated by the fact that the vast majority of refactorings apply not at the class level but at the method level 2009 ieee empirical evolution java method oss system evolution at the attribute level an empirical study of three java oss and their refactorings in this paper we focus on the net changes in attributes across versions of oss and use net class change data class additions and deletions as well as refactoring data from a previous study to inform our understanding of how those three systems evolved as they did while the majority of new attributes were added at levels 1 and 2 of the inheritance these patterns were not consistent the research question addresses the evolutionary relationship between classes and attributes as well as the connection between those changes and refactorings although some evidence of attributes following patterns conformant with class additions was found we also identified occurrences of attributes being added unilaterally a strong correspondence was also found between attribute addition and the refactoring data finally we explore features of a fourth system with seven inheritance levels for similar characteristics attribute evolution oo refactoring client based cohesion metrics for java programs one purpose of software metrics is to measure the quality of programs the results can be for example used to predict maintenance costs or improve code quality an emerging view is that if software metrics are going to be used to improve quality they must help in finding code that should be refactored often refactoring or applying a design pattern is related to the role of the class to be refactored in client based metrics a project gives the class a context these metrics measure how a class is used by other classes in the context we present a new client based metric lcic lack of coherence in clients which analyses if the class being measured has a coherent set of roles in the program interfaces represent the roles of classes if a class does not have a coherent set of roles it should be refactored or a new interface should be defined for the class we have implemented a tool for measuring the metric lcic for java projects in the eclipse environment we calculated lcic values for classes of several open source projects we compare these results with results of other related metrics and inspect the measured classes to find out what kind of refactorings are needed we also analyse the relation of different design patterns and refactorings to our metric our experiments reveal the usefulness of client based metrics to improve the quality of code 2009 elsevier b v all rights reserved cohesion design patterns java metrics refactoring re approaching the refactoring rubicon fowler saw the availability of automated support for the extract method refactoring in modern ides as an indication for the crossing of the refactoring rubicon in spite of the advances in refactoring technology it seems that this rubicon has not yet been crossed and refactoring support in modern ides leaves a lot to be desired we performed a case study in which we converted a java servlet to use the model view controller pattern using as much automated support as available we found that while the whole conversion could be described as a series of refactorings most of these were inadequately supported by the ide and some were not supported at all based on these findings we outline the requirements from a refactoring framework that will support much more of the conversion process and will also enable the composition of small refactorings into larger ones copyright 2008 acm a software metric for coherence of class roles in java programs the purpose of software metrics is to measure the quality of programs the results can be for example used to predict maintenance costs or improve code quality an emerging view is that if software metrics are going to be used to improve quality they must help in finding code that should be refactored often refactoring or applying a design pattern is related to the role of the class to be refactored in client based metrics a project gives the class a context these metrics measure how a class is used by other classes in the context we present a new client based metric lcic lack of coherence in clients which analyses if the class being measured has a coherent set of roles in the program interfaces represent the roles of classes if a class does not have a coherent set of roles it should be refactored or a new interface should be defined for the class we have implemented a tool for measuring the metric lcic for java projects in the eclipse environment we calculated lcic values for classes of several open source projects we compare these results with results of other related metrics and inspect the measured classes to find out what kind of refactorings are needed we also analyse the relation of different design patterns and refactorings to our metric our experiments reveal the usefulness of client based metrics to improve the quality of code copyright 2007 acm cohesion design patterns java metrics refactoring tool support for object oriented patterns springer verlag berhn heidelberg 1997 a software design pattern describes a general solution for a recurring design problem the solution is mostly described in terms of an abstract design structure expressed in design elements such as classes methods and relationships inheritance associations this paper describes a prototype tool that supports working with design patterns when developing or maintaining object oriented programs the tool provides three integrated views on a program the code classes methods etc a design view abstraction of the code plus additional information not in the code and occurrences of design patterns in the program the tool assists developers using patterns in three ways ● generating program elements e g classes hierarchies for a new instance of a pattern taken from an extensible collection of template patterns ● integrating pattern occurrences with the rest of the program by binding program elements to a role in a pattern e g indicating that an existing class plays a particular role in a pattern instance ●checking whether occurrences of patterns still meet the invariants governing the patterns and repairing the program in case of problems through the use of an existing refactoring package the tool supports the use of patterns both in forward engineering and in backwards engineering i e documenting occurrences of patterns in existing programs and modifying the program to better reflect the pattern s structure the tool is implemented in smalltalk and has been applied to identify pattern occurrences in several non trivial smalltalk applications and to reorganize these subsequently